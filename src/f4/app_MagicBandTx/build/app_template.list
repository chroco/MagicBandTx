
build/app_template.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <_vectors>:
 8000000:	20000400 	.word	0x20000400
 8000004:	08000301 	.word	0x08000301
 8000008:	08000303 	.word	0x08000303
 800000c:	08000303 	.word	0x08000303
 8000010:	08000303 	.word	0x08000303
 8000014:	08000303 	.word	0x08000303
 8000018:	08000303 	.word	0x08000303
 800001c:	08000303 	.word	0x08000303
 8000020:	08000303 	.word	0x08000303
 8000024:	08000303 	.word	0x08000303
 8000028:	08000303 	.word	0x08000303
 800002c:	08002801 	.word	0x08002801
 8000030:	08000303 	.word	0x08000303
 8000034:	08000303 	.word	0x08000303
 8000038:	08000303 	.word	0x08000303
 800003c:	08000303 	.word	0x08000303
 8000040:	08000303 	.word	0x08000303
 8000044:	08000303 	.word	0x08000303
 8000048:	08000303 	.word	0x08000303
 800004c:	08000303 	.word	0x08000303
 8000050:	08000303 	.word	0x08000303
 8000054:	08000303 	.word	0x08000303
 8000058:	08000303 	.word	0x08000303
 800005c:	08000303 	.word	0x08000303
 8000060:	08000303 	.word	0x08000303
 8000064:	08000303 	.word	0x08000303
 8000068:	08000303 	.word	0x08000303
 800006c:	08000303 	.word	0x08000303
 8000070:	08000303 	.word	0x08000303
 8000074:	08000303 	.word	0x08000303
 8000078:	08000303 	.word	0x08000303
 800007c:	08000303 	.word	0x08000303
 8000080:	08000303 	.word	0x08000303
 8000084:	08000303 	.word	0x08000303
 8000088:	08000303 	.word	0x08000303
 800008c:	08000303 	.word	0x08000303
 8000090:	08000303 	.word	0x08000303
 8000094:	08000303 	.word	0x08000303
 8000098:	08000303 	.word	0x08000303
 800009c:	08000303 	.word	0x08000303
 80000a0:	08000303 	.word	0x08000303
 80000a4:	08001121 	.word	0x08001121
 80000a8:	08000303 	.word	0x08000303
 80000ac:	080010f1 	.word	0x080010f1
 80000b0:	08001361 	.word	0x08001361
 80000b4:	08001151 	.word	0x08001151
 80000b8:	08000303 	.word	0x08000303
 80000bc:	08000303 	.word	0x08000303
 80000c0:	08000303 	.word	0x08000303
 80000c4:	08000303 	.word	0x08000303
 80000c8:	08000303 	.word	0x08000303
 80000cc:	08000303 	.word	0x08000303
 80000d0:	08000303 	.word	0x08000303
 80000d4:	08000303 	.word	0x08000303
 80000d8:	080010c1 	.word	0x080010c1
 80000dc:	08000303 	.word	0x08000303
 80000e0:	08000303 	.word	0x08000303
 80000e4:	08000303 	.word	0x08000303
 80000e8:	08000303 	.word	0x08000303
 80000ec:	08000303 	.word	0x08000303
 80000f0:	08000303 	.word	0x08000303
 80000f4:	08000303 	.word	0x08000303
 80000f8:	08000303 	.word	0x08000303
 80000fc:	08000303 	.word	0x08000303
 8000100:	08000303 	.word	0x08000303
 8000104:	08000303 	.word	0x08000303
 8000108:	08000303 	.word	0x08000303
 800010c:	08000303 	.word	0x08000303
 8000110:	08000303 	.word	0x08000303
 8000114:	08000303 	.word	0x08000303
 8000118:	08000303 	.word	0x08000303
 800011c:	08000303 	.word	0x08000303
 8000120:	08000303 	.word	0x08000303
 8000124:	08000303 	.word	0x08000303
 8000128:	08000303 	.word	0x08000303
 800012c:	08000303 	.word	0x08000303
 8000130:	08000303 	.word	0x08000303
 8000134:	08000303 	.word	0x08000303
 8000138:	08000303 	.word	0x08000303
 800013c:	08000303 	.word	0x08000303
 8000140:	08000303 	.word	0x08000303
 8000144:	08000303 	.word	0x08000303
 8000148:	08000303 	.word	0x08000303
 800014c:	08000303 	.word	0x08000303
 8000150:	08000303 	.word	0x08000303
 8000154:	08000303 	.word	0x08000303
 8000158:	08000303 	.word	0x08000303
 800015c:	08000303 	.word	0x08000303
 8000160:	08000303 	.word	0x08000303
 8000164:	08000303 	.word	0x08000303
 8000168:	08000303 	.word	0x08000303
 800016c:	08000303 	.word	0x08000303
 8000170:	08000303 	.word	0x08000303
 8000174:	08000303 	.word	0x08000303
 8000178:	08000303 	.word	0x08000303
 800017c:	08000303 	.word	0x08000303
 8000180:	08000303 	.word	0x08000303
 8000184:	08000303 	.word	0x08000303
 8000188:	08000303 	.word	0x08000303
 800018c:	08000303 	.word	0x08000303
 8000190:	08000303 	.word	0x08000303
 8000194:	08000303 	.word	0x08000303
 8000198:	08000303 	.word	0x08000303
 800019c:	08000303 	.word	0x08000303
 80001a0:	08000303 	.word	0x08000303
 80001a4:	08000303 	.word	0x08000303
 80001a8:	08000303 	.word	0x08000303
 80001ac:	08000303 	.word	0x08000303
 80001b0:	08000303 	.word	0x08000303
 80001b4:	08000303 	.word	0x08000303
 80001b8:	08000303 	.word	0x08000303
 80001bc:	08000303 	.word	0x08000303
 80001c0:	08000303 	.word	0x08000303
 80001c4:	08000303 	.word	0x08000303
 80001c8:	08000303 	.word	0x08000303
 80001cc:	08000303 	.word	0x08000303
 80001d0:	08000303 	.word	0x08000303
 80001d4:	08000303 	.word	0x08000303
 80001d8:	08000303 	.word	0x08000303
 80001dc:	08000303 	.word	0x08000303

Disassembly of section .text:

080001e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001e2:	4839      	ldr	r0, [pc, #228]	; (80002c8 <endfiniloop+0x6>)
                msr     MSP, r0
 80001e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001e8:	4838      	ldr	r0, [pc, #224]	; (80002cc <endfiniloop+0xa>)
                msr     PSP, r0
 80001ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                ldr     r0, =_vectors
 80001ee:	4838      	ldr	r0, [pc, #224]	; (80002d0 <endfiniloop+0xe>)
                movw    r1, #SCB_VTOR & 0xFFFF
 80001f0:	f64e 5108 	movw	r1, #60680	; 0xed08
                movt    r1, #SCB_VTOR >> 16
 80001f4:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 80001f8:	6008      	str	r0, [r1, #0]
#endif

#if CRT0_INIT_FPU == TRUE
                /* FPU FPCCR initialization.*/
                movw    r0, #CRT0_FPCCR_INIT & 0xFFFF
 80001fa:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_FPCCR_INIT >> 16
 80001fe:	f2cc 0000 	movt	r0, #49152	; 0xc000
                movw    r1, #SCB_FPCCR & 0xFFFF
 8000202:	f64e 7134 	movw	r1, #61236	; 0xef34
                movt    r1, #SCB_FPCCR >> 16
 8000206:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800020a:	6008      	str	r0, [r1, #0]
                dsb
 800020c:	f3bf 8f4f 	dsb	sy
                isb
 8000210:	f3bf 8f6f 	isb	sy

                /* CPACR initialization.*/
                movw    r0, #CRT0_CPACR_INIT & 0xFFFF
 8000214:	f240 0000 	movw	r0, #0
                movt    r0, #CRT0_CPACR_INIT >> 16
 8000218:	f2c0 00f0 	movt	r0, #240	; 0xf0
                movw    r1, #SCB_CPACR & 0xFFFF
 800021c:	f64e 5188 	movw	r1, #60808	; 0xed88
                movt    r1, #SCB_CPACR >> 16
 8000220:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 8000224:	6008      	str	r0, [r1, #0]
                dsb
 8000226:	f3bf 8f4f 	dsb	sy
                isb
 800022a:	f3bf 8f6f 	isb	sy

                /* FPU FPSCR initially cleared.*/
                mov     r0, #0
 800022e:	f04f 0000 	mov.w	r0, #0
                vmsr    FPSCR, r0
 8000232:	eee1 0a10 	vmsr	fpscr, r0

                /* FPU FPDSCR initially cleared.*/
                movw    r1, #SCB_FPDSCR & 0xFFFF
 8000236:	f64e 713c 	movw	r1, #61244	; 0xef3c
                movt    r1, #SCB_FPDSCR >> 16
 800023a:	f2ce 0100 	movt	r1, #57344	; 0xe000
                str     r0, [r1]
 800023e:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA
 8000240:	2006      	movs	r0, #6
#else
                movs    r0, #CRT0_CONTROL_INIT
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 8000242:	f380 8814 	msr	CONTROL, r0
                isb
 8000246:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 800024a:	f001 f909 	bl	8001460 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 800024e:	f000 ff2f 	bl	80010b0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000252:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 8000256:	491f      	ldr	r1, [pc, #124]	; (80002d4 <endfiniloop+0x12>)
                ldr     r2, =__main_stack_end__
 8000258:	4a1b      	ldr	r2, [pc, #108]	; (80002c8 <endfiniloop+0x6>)

0800025a <msloop>:
msloop:
                cmp     r1, r2
 800025a:	4291      	cmp	r1, r2
                itt     lo
 800025c:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800025e:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000262:	e7fa      	bcc.n	800025a <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000264:	491c      	ldr	r1, [pc, #112]	; (80002d8 <endfiniloop+0x16>)
                ldr     r2, =__process_stack_end__
 8000266:	4a19      	ldr	r2, [pc, #100]	; (80002cc <endfiniloop+0xa>)

08000268 <psloop>:
psloop:
                cmp     r1, r2
 8000268:	4291      	cmp	r1, r2
                itt     lo
 800026a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800026c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000270:	e7fa      	bcc.n	8000268 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 8000272:	491a      	ldr	r1, [pc, #104]	; (80002dc <endfiniloop+0x1a>)
                ldr     r2, =_data_start
 8000274:	4a1a      	ldr	r2, [pc, #104]	; (80002e0 <endfiniloop+0x1e>)
                ldr     r3, =_data_end
 8000276:	4b1b      	ldr	r3, [pc, #108]	; (80002e4 <endfiniloop+0x22>)

08000278 <dloop>:
dloop:
                cmp     r2, r3
 8000278:	429a      	cmp	r2, r3
                ittt    lo
 800027a:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 800027c:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000280:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000284:	e7f8      	bcc.n	8000278 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000286:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000288:	4917      	ldr	r1, [pc, #92]	; (80002e8 <endfiniloop+0x26>)
                ldr     r2, =_bss_end
 800028a:	4a18      	ldr	r2, [pc, #96]	; (80002ec <endfiniloop+0x2a>)

0800028c <bloop>:
bloop:
                cmp     r1, r2
 800028c:	4291      	cmp	r1, r2
                itt     lo
 800028e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000290:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000294:	e7fa      	bcc.n	800028c <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000296:	f001 f8b3 	bl	8001400 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800029a:	f001 f8d9 	bl	8001450 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800029e:	4c14      	ldr	r4, [pc, #80]	; (80002f0 <endfiniloop+0x2e>)
                ldr     r5, =__init_array_end
 80002a0:	4d14      	ldr	r5, [pc, #80]	; (80002f4 <endfiniloop+0x32>)

080002a2 <initloop>:
initloop:
                cmp     r4, r5
 80002a2:	42ac      	cmp	r4, r5
                bge     endinitloop
 80002a4:	da03      	bge.n	80002ae <endinitloop>
                ldr     r1, [r4], #4
 80002a6:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80002aa:	4788      	blx	r1
                b       initloop
 80002ac:	e7f9      	b.n	80002a2 <initloop>

080002ae <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 80002ae:	f002 fa67 	bl	8002780 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 80002b2:	4c11      	ldr	r4, [pc, #68]	; (80002f8 <endfiniloop+0x36>)
                ldr     r5, =__fini_array_end
 80002b4:	4d11      	ldr	r5, [pc, #68]	; (80002fc <endfiniloop+0x3a>)

080002b6 <finiloop>:
finiloop:
                cmp     r4, r5
 80002b6:	42ac      	cmp	r4, r5
                bge     endfiniloop
 80002b8:	da03      	bge.n	80002c2 <endfiniloop>
                ldr     r1, [r4], #4
 80002ba:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 80002be:	4788      	blx	r1
                b       finiloop
 80002c0:	e7f9      	b.n	80002b6 <finiloop>

080002c2 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 80002c2:	f001 b8bd 	b.w	8001440 <__default_exit>
 80002c6:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 80002c8:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 80002cc:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 80002d0:	08000000 	.word	0x08000000
                ldr     r1, =__main_stack_base__
 80002d4:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 80002d8:	20000400 	.word	0x20000400
                ldr     r1, =_textdata_start
 80002dc:	080031dc 	.word	0x080031dc
                ldr     r2, =_data_start
 80002e0:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 80002e4:	20000840 	.word	0x20000840
                ldr     r1, =_bss_start
 80002e8:	20000840 	.word	0x20000840
                ldr     r2, =_bss_end
 80002ec:	20001344 	.word	0x20001344
                ldr     r4, =__init_array_start
 80002f0:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end
 80002f4:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_start
 80002f8:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end
 80002fc:	080001e0 	.word	0x080001e0

08000300 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 8000300:	e76e      	b.n	80001e0 <_crt0_entry>

08000302 <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 8000302:	f000 f800 	bl	8000306 <_unhandled_exception>

08000306 <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 8000306:	e7fe      	b.n	8000306 <_unhandled_exception>

08000308 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 8000308:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
 800030c:	ed2d 8a10 	vpush	{s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 8000310:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 8000314:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 8000316:	469d      	mov	sp, r3
#else
                ldr     sp, [r0, #CONTEXT_OFFSET]
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
 8000318:	ecbd 8a10 	vpop	{s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 800031c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000320 <_port_thread_start>:
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_thread_start
_port_thread_start:
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 8000320:	f001 ff7e 	bl	8002220 <_dbg_check_unlock>
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 8000324:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 8000326:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 800032a:	4628      	mov	r0, r5
                blx     r4
 800032c:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 800032e:	2000      	movs	r0, #0
                bl      chThdExit
 8000330:	f001 ffe6 	bl	8002300 <chThdExit>

08000334 <_zombies>:
_zombies:       b       _zombies
 8000334:	e7fe      	b.n	8000334 <_zombies>

08000336 <_port_switch_from_isr>:
_port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
 8000336:	f001 ffa3 	bl	8002280 <_dbg_check_lock>
#endif
                bl      chSchDoReschedule
 800033a:	f001 fd01 	bl	8001d40 <chSchDoReschedule>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_unlock
 800033e:	f001 ff6f 	bl	8002220 <_dbg_check_unlock>

08000342 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000342:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000344:	e7fe      	b.n	8000344 <_port_exit_from_isr+0x2>
	...

08000348 <memcpy>:
 8000348:	e352000f 	cmp	r2, #15
 800034c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
 8000350:	9a000029 	bls	80003fc <memcpy+0xb4>
 8000354:	e1813000 	orr	r3, r1, r0
 8000358:	e3130003 	tst	r3, #3
 800035c:	1a000031 	bne	8000428 <memcpy+0xe0>
 8000360:	e1a0e002 	mov	lr, r2
 8000364:	e280c010 	add	ip, r0, #16
 8000368:	e2813010 	add	r3, r1, #16
 800036c:	e5137010 	ldr	r7, [r3, #-16]
 8000370:	e513600c 	ldr	r6, [r3, #-12]
 8000374:	e5135008 	ldr	r5, [r3, #-8]
 8000378:	e5134004 	ldr	r4, [r3, #-4]
 800037c:	e24ee010 	sub	lr, lr, #16
 8000380:	e35e000f 	cmp	lr, #15
 8000384:	e50c7010 	str	r7, [ip, #-16]
 8000388:	e50c600c 	str	r6, [ip, #-12]
 800038c:	e50c5008 	str	r5, [ip, #-8]
 8000390:	e50c4004 	str	r4, [ip, #-4]
 8000394:	e2833010 	add	r3, r3, #16
 8000398:	e28cc010 	add	ip, ip, #16
 800039c:	8afffff2 	bhi	800036c <memcpy+0x24>
 80003a0:	e2423010 	sub	r3, r2, #16
 80003a4:	e3c3300f 	bic	r3, r3, #15
 80003a8:	e202600f 	and	r6, r2, #15
 80003ac:	e2833010 	add	r3, r3, #16
 80003b0:	e3560003 	cmp	r6, #3
 80003b4:	e0811003 	add	r1, r1, r3
 80003b8:	e0803003 	add	r3, r0, r3
 80003bc:	9a00001b 	bls	8000430 <memcpy+0xe8>
 80003c0:	e1a04001 	mov	r4, r1
 80003c4:	e1a0c006 	mov	ip, r6
 80003c8:	e243e004 	sub	lr, r3, #4
 80003cc:	e24cc004 	sub	ip, ip, #4
 80003d0:	e4945004 	ldr	r5, [r4], #4
 80003d4:	e35c0003 	cmp	ip, #3
 80003d8:	e5ae5004 	str	r5, [lr, #4]!
 80003dc:	8afffffa 	bhi	80003cc <memcpy+0x84>
 80003e0:	e246c004 	sub	ip, r6, #4
 80003e4:	e3ccc003 	bic	ip, ip, #3
 80003e8:	e28cc004 	add	ip, ip, #4
 80003ec:	e083300c 	add	r3, r3, ip
 80003f0:	e081100c 	add	r1, r1, ip
 80003f4:	e2022003 	and	r2, r2, #3
 80003f8:	ea000000 	b	8000400 <memcpy+0xb8>
 80003fc:	e1a03000 	mov	r3, r0
 8000400:	e3520000 	cmp	r2, #0
 8000404:	0a000005 	beq	8000420 <memcpy+0xd8>
 8000408:	e2433001 	sub	r3, r3, #1
 800040c:	e0812002 	add	r2, r1, r2
 8000410:	e4d1c001 	ldrb	ip, [r1], #1
 8000414:	e1510002 	cmp	r1, r2
 8000418:	e5e3c001 	strb	ip, [r3, #1]!
 800041c:	1afffffb 	bne	8000410 <memcpy+0xc8>
 8000420:	e8bd40f0 	pop	{r4, r5, r6, r7, lr}
 8000424:	e12fff1e 	bx	lr
 8000428:	e1a03000 	mov	r3, r0
 800042c:	eafffff5 	b	8000408 <memcpy+0xc0>
 8000430:	e1a02006 	mov	r2, r6
 8000434:	eafffff1 	b	8000400 <memcpy+0xb8>
	...

08000440 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000440:	e7fe      	b.n	8000440 <_idle_thread>
 8000442:	bf00      	nop
	...

08000450 <gpio_init>:
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000450:	684b      	ldr	r3, [r1, #4]
 8000452:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000454:	688b      	ldr	r3, [r1, #8]
 8000456:	6083      	str	r3, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8000458:	68cb      	ldr	r3, [r1, #12]
 800045a:	60c3      	str	r3, [r0, #12]
  gpiop->ODR     = config->odr;
 800045c:	690b      	ldr	r3, [r1, #16]
 800045e:	6143      	str	r3, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8000460:	694b      	ldr	r3, [r1, #20]
 8000462:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8000464:	698b      	ldr	r3, [r1, #24]
 8000466:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000468:	680b      	ldr	r3, [r1, #0]
 800046a:	6003      	str	r3, [r0, #0]
 800046c:	4770      	bx	lr
 800046e:	bf00      	nop

08000470 <stm32_gpio_init>:
}

static void stm32_gpio_init(void) {
 8000470:	b510      	push	{r4, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8000472:	4b1e      	ldr	r3, [pc, #120]	; (80004ec <stm32_gpio_init+0x7c>)
 8000474:	691a      	ldr	r2, [r3, #16]
 8000476:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 800047a:	611a      	str	r2, [r3, #16]
 800047c:	691a      	ldr	r2, [r3, #16]
 800047e:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8000482:	611a      	str	r2, [r3, #16]
 8000484:	691a      	ldr	r2, [r3, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8000486:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8000488:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 800048c:	631a      	str	r2, [r3, #48]	; 0x30
 800048e:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8000490:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 8000494:	651a      	str	r2, [r3, #80]	; 0x50
 8000496:	6d1b      	ldr	r3, [r3, #80]	; 0x50

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 8000498:	4c15      	ldr	r4, [pc, #84]	; (80004f0 <stm32_gpio_init+0x80>)
 800049a:	4621      	mov	r1, r4
 800049c:	4815      	ldr	r0, [pc, #84]	; (80004f4 <stm32_gpio_init+0x84>)
 800049e:	f7ff ffd7 	bl	8000450 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 80004a2:	f104 011c 	add.w	r1, r4, #28
 80004a6:	4814      	ldr	r0, [pc, #80]	; (80004f8 <stm32_gpio_init+0x88>)
 80004a8:	f7ff ffd2 	bl	8000450 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 80004ac:	f104 0138 	add.w	r1, r4, #56	; 0x38
 80004b0:	4812      	ldr	r0, [pc, #72]	; (80004fc <stm32_gpio_init+0x8c>)
 80004b2:	f7ff ffcd 	bl	8000450 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 80004b6:	f104 0154 	add.w	r1, r4, #84	; 0x54
 80004ba:	4811      	ldr	r0, [pc, #68]	; (8000500 <stm32_gpio_init+0x90>)
 80004bc:	f7ff ffc8 	bl	8000450 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 80004c0:	f104 0170 	add.w	r1, r4, #112	; 0x70
 80004c4:	480f      	ldr	r0, [pc, #60]	; (8000504 <stm32_gpio_init+0x94>)
 80004c6:	f7ff ffc3 	bl	8000450 <gpio_init>
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
 80004ca:	f104 018c 	add.w	r1, r4, #140	; 0x8c
 80004ce:	480e      	ldr	r0, [pc, #56]	; (8000508 <stm32_gpio_init+0x98>)
 80004d0:	f7ff ffbe 	bl	8000450 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
 80004d4:	f104 01a8 	add.w	r1, r4, #168	; 0xa8
 80004d8:	480c      	ldr	r0, [pc, #48]	; (800050c <stm32_gpio_init+0x9c>)
 80004da:	f7ff ffb9 	bl	8000450 <gpio_init>
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 80004de:	f104 01c4 	add.w	r1, r4, #196	; 0xc4
 80004e2:	480b      	ldr	r0, [pc, #44]	; (8000510 <stm32_gpio_init+0xa0>)
 80004e4:	f7ff ffb4 	bl	8000450 <gpio_init>
 80004e8:	bd10      	pop	{r4, pc}
 80004ea:	bf00      	nop
 80004ec:	40023800 	.word	0x40023800
 80004f0:	08002e50 	.word	0x08002e50
 80004f4:	40020000 	.word	0x40020000
 80004f8:	40020400 	.word	0x40020400
 80004fc:	40020800 	.word	0x40020800
 8000500:	40020c00 	.word	0x40020c00
 8000504:	40021000 	.word	0x40021000
 8000508:	40021400 	.word	0x40021400
 800050c:	40021800 	.word	0x40021800
 8000510:	40021c00 	.word	0x40021c00
	...

08000520 <notify2>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE | USART_CR1_TCIE;
 8000520:	4a02      	ldr	r2, [pc, #8]	; (800052c <notify2+0xc>)
 8000522:	68d3      	ldr	r3, [r2, #12]
 8000524:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
 8000528:	60d3      	str	r3, [r2, #12]
 800052a:	4770      	bx	lr
 800052c:	40004400 	.word	0x40004400

08000530 <usart_init>:
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 8000530:	b410      	push	{r4}
  USART_TypeDef *u = sdp->usart;
 8000532:	6f43      	ldr	r3, [r0, #116]	; 0x74
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
 8000534:	4a1e      	ldr	r2, [pc, #120]	; (80005b0 <usart_init+0x80>)
 8000536:	4293      	cmp	r3, r2
 8000538:	d02a      	beq.n	8000590 <usart_init+0x60>
 800053a:	f502 6280 	add.w	r2, r2, #1024	; 0x400
 800053e:	4293      	cmp	r3, r2
 8000540:	d026      	beq.n	8000590 <usart_init+0x60>
    fck = STM32_PCLK1 / config->speed;
 8000542:	680c      	ldr	r4, [r1, #0]
 8000544:	4a1b      	ldr	r2, [pc, #108]	; (80005b4 <usart_init+0x84>)
 8000546:	fbb2 f2f4 	udiv	r2, r2, r4
  if (config->cr1 & USART_CR1_OVER8)
 800054a:	f9b1 4004 	ldrsh.w	r4, [r1, #4]
 800054e:	2c00      	cmp	r4, #0
 8000550:	db23      	blt.n	800059a <usart_init+0x6a>
  u->BRR = fck;
 8000552:	609a      	str	r2, [r3, #8]
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000554:	88ca      	ldrh	r2, [r1, #6]
 8000556:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800055a:	611a      	str	r2, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800055c:	890a      	ldrh	r2, [r1, #8]
 800055e:	f042 0201 	orr.w	r2, r2, #1
 8000562:	615a      	str	r2, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000564:	888a      	ldrh	r2, [r1, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 8000566:	f442 5204 	orr.w	r2, r2, #8448	; 0x2100
 800056a:	f042 022c 	orr.w	r2, r2, #44	; 0x2c
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800056e:	60da      	str	r2, [r3, #12]
  u->SR = 0;
 8000570:	2200      	movs	r2, #0
 8000572:	601a      	str	r2, [r3, #0]
  (void)u->SR;  /* SR reset step 1.*/
 8000574:	681a      	ldr	r2, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8000576:	685b      	ldr	r3, [r3, #4]
  if ((config->cr1 & (USART_CR1_M | USART_CR1_PCE)) == USART_CR1_PCE) {
 8000578:	888b      	ldrh	r3, [r1, #4]
 800057a:	f403 53a0 	and.w	r3, r3, #5120	; 0x1400
 800057e:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 8000582:	d011      	beq.n	80005a8 <usart_init+0x78>
    sdp->rxmask = 0xFF;
 8000584:	23ff      	movs	r3, #255	; 0xff
 8000586:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
}
 800058a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800058e:	4770      	bx	lr
    fck = STM32_PCLK2 / config->speed;
 8000590:	680c      	ldr	r4, [r1, #0]
 8000592:	4a09      	ldr	r2, [pc, #36]	; (80005b8 <usart_init+0x88>)
 8000594:	fbb2 f2f4 	udiv	r2, r2, r4
 8000598:	e7d7      	b.n	800054a <usart_init+0x1a>
    fck = ((fck & ~7) * 2) | (fck & 7);
 800059a:	f022 0407 	bic.w	r4, r2, #7
 800059e:	f002 0207 	and.w	r2, r2, #7
 80005a2:	ea42 0244 	orr.w	r2, r2, r4, lsl #1
 80005a6:	e7d4      	b.n	8000552 <usart_init+0x22>
    sdp->rxmask = 0x7F;
 80005a8:	237f      	movs	r3, #127	; 0x7f
 80005aa:	f880 3078 	strb.w	r3, [r0, #120]	; 0x78
 80005ae:	e7ec      	b.n	800058a <usart_init+0x5a>
 80005b0:	40011000 	.word	0x40011000
 80005b4:	0280de80 	.word	0x0280de80
 80005b8:	0501bd00 	.word	0x0501bd00
 80005bc:	00000000 	.word	0x00000000

080005c0 <pwm_lld_serve_interrupt>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 80005c0:	b538      	push	{r3, r4, r5, lr}
 80005c2:	4605      	mov	r5, r0
  uint32_t sr;

  sr  = pwmp->tim->SR;
 80005c4:	6983      	ldr	r3, [r0, #24]
 80005c6:	691c      	ldr	r4, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 80005c8:	68da      	ldr	r2, [r3, #12]
 80005ca:	b2d2      	uxtb	r2, r2
 80005cc:	4014      	ands	r4, r2
  pwmp->tim->SR = ~sr;
 80005ce:	43e2      	mvns	r2, r4
 80005d0:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 80005d2:	f014 0f02 	tst.w	r4, #2
 80005d6:	d003      	beq.n	80005e0 <pwm_lld_serve_interrupt+0x20>
      (pwmp->config->channels[0].callback != NULL))
 80005d8:	6843      	ldr	r3, [r0, #4]
 80005da:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 80005dc:	b103      	cbz	r3, 80005e0 <pwm_lld_serve_interrupt+0x20>
    pwmp->config->channels[0].callback(pwmp);
 80005de:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 80005e0:	f014 0f04 	tst.w	r4, #4
 80005e4:	d004      	beq.n	80005f0 <pwm_lld_serve_interrupt+0x30>
      (pwmp->config->channels[1].callback != NULL))
 80005e6:	686b      	ldr	r3, [r5, #4]
 80005e8:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 80005ea:	b10b      	cbz	r3, 80005f0 <pwm_lld_serve_interrupt+0x30>
    pwmp->config->channels[1].callback(pwmp);
 80005ec:	4628      	mov	r0, r5
 80005ee:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 80005f0:	f014 0f08 	tst.w	r4, #8
 80005f4:	d004      	beq.n	8000600 <pwm_lld_serve_interrupt+0x40>
      (pwmp->config->channels[2].callback != NULL))
 80005f6:	686b      	ldr	r3, [r5, #4]
 80005f8:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 80005fa:	b10b      	cbz	r3, 8000600 <pwm_lld_serve_interrupt+0x40>
    pwmp->config->channels[2].callback(pwmp);
 80005fc:	4628      	mov	r0, r5
 80005fe:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8000600:	f014 0f10 	tst.w	r4, #16
 8000604:	d004      	beq.n	8000610 <pwm_lld_serve_interrupt+0x50>
      (pwmp->config->channels[3].callback != NULL))
 8000606:	686b      	ldr	r3, [r5, #4]
 8000608:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 800060a:	b10b      	cbz	r3, 8000610 <pwm_lld_serve_interrupt+0x50>
    pwmp->config->channels[3].callback(pwmp);
 800060c:	4628      	mov	r0, r5
 800060e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8000610:	f014 0f01 	tst.w	r4, #1
 8000614:	d004      	beq.n	8000620 <pwm_lld_serve_interrupt+0x60>
 8000616:	686b      	ldr	r3, [r5, #4]
 8000618:	689b      	ldr	r3, [r3, #8]
 800061a:	b10b      	cbz	r3, 8000620 <pwm_lld_serve_interrupt+0x60>
    pwmp->config->callback(pwmp);
 800061c:	4628      	mov	r0, r5
 800061e:	4798      	blx	r3
 8000620:	bd38      	pop	{r3, r4, r5, pc}
 8000622:	bf00      	nop
	...

08000630 <pwm_lld_enable_channel_notification>:
                                         pwmchannel_t channel) {
 8000630:	b410      	push	{r4}
  uint32_t dier = pwmp->tim->DIER;
 8000632:	6984      	ldr	r4, [r0, #24]
 8000634:	68e2      	ldr	r2, [r4, #12]
  if ((dier & (2 << channel)) == 0) {
 8000636:	2302      	movs	r3, #2
 8000638:	fa03 f101 	lsl.w	r1, r3, r1
 800063c:	420a      	tst	r2, r1
 800063e:	d104      	bne.n	800064a <pwm_lld_enable_channel_notification+0x1a>
    pwmp->tim->SR   = ~(2 << channel);
 8000640:	43cb      	mvns	r3, r1
 8000642:	6123      	str	r3, [r4, #16]
    pwmp->tim->DIER = dier | (2 << channel);
 8000644:	6983      	ldr	r3, [r0, #24]
 8000646:	4311      	orrs	r1, r2
 8000648:	60d9      	str	r1, [r3, #12]
}
 800064a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800064e:	4770      	bx	lr

08000650 <pwm_lld_enable_periodic_notification>:
  uint32_t dier = pwmp->tim->DIER;
 8000650:	6982      	ldr	r2, [r0, #24]
 8000652:	68d3      	ldr	r3, [r2, #12]
  if ((dier & STM32_TIM_DIER_UIE) == 0) {
 8000654:	f013 0f01 	tst.w	r3, #1
 8000658:	d106      	bne.n	8000668 <pwm_lld_enable_periodic_notification+0x18>
    pwmp->tim->SR   = ~STM32_TIM_SR_UIF;
 800065a:	f06f 0101 	mvn.w	r1, #1
 800065e:	6111      	str	r1, [r2, #16]
    pwmp->tim->DIER = dier | STM32_TIM_DIER_UIE;
 8000660:	6982      	ldr	r2, [r0, #24]
 8000662:	f043 0301 	orr.w	r3, r3, #1
 8000666:	60d3      	str	r3, [r2, #12]
 8000668:	4770      	bx	lr
 800066a:	bf00      	nop
 800066c:	0000      	movs	r0, r0
	...

08000670 <pwm_lld_enable_channel>:
  pwmp->tim->CCR[channel] = width;
 8000670:	6983      	ldr	r3, [r0, #24]
 8000672:	310c      	adds	r1, #12
 8000674:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 8000678:	605a      	str	r2, [r3, #4]
 800067a:	4770      	bx	lr
 800067c:	0000      	movs	r0, r0
	...

08000680 <icu_lld_serve_interrupt>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_serve_interrupt(ICUDriver *icup) {
 8000680:	b538      	push	{r3, r4, r5, lr}
 8000682:	4605      	mov	r5, r0
  uint32_t sr;

  sr  = icup->tim->SR;
 8000684:	68c3      	ldr	r3, [r0, #12]
 8000686:	691c      	ldr	r4, [r3, #16]
  sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8000688:	68da      	ldr	r2, [r3, #12]
 800068a:	b2d2      	uxtb	r2, r2
 800068c:	4014      	ands	r4, r2
  icup->tim->SR = ~sr;
 800068e:	43e2      	mvns	r2, r4
 8000690:	611a      	str	r2, [r3, #16]
  if (icup->config->channel == ICU_CHANNEL_1) {
 8000692:	6843      	ldr	r3, [r0, #4]
 8000694:	7d1a      	ldrb	r2, [r3, #20]
 8000696:	b9ea      	cbnz	r2, 80006d4 <icu_lld_serve_interrupt+0x54>
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 8000698:	f014 0f04 	tst.w	r4, #4
 800069c:	d002      	beq.n	80006a4 <icu_lld_serve_interrupt+0x24>
      _icu_isr_invoke_width_cb(icup);
 800069e:	7802      	ldrb	r2, [r0, #0]
 80006a0:	2a04      	cmp	r2, #4
 80006a2:	d00b      	beq.n	80006bc <icu_lld_serve_interrupt+0x3c>
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 80006a4:	f014 0f02 	tst.w	r4, #2
 80006a8:	d004      	beq.n	80006b4 <icu_lld_serve_interrupt+0x34>
      _icu_isr_invoke_period_cb(icup);
 80006aa:	782b      	ldrb	r3, [r5, #0]
 80006ac:	2b04      	cmp	r3, #4
 80006ae:	d00a      	beq.n	80006c6 <icu_lld_serve_interrupt+0x46>
 80006b0:	2304      	movs	r3, #4
 80006b2:	702b      	strb	r3, [r5, #0]
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
      _icu_isr_invoke_width_cb(icup);
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
      _icu_isr_invoke_period_cb(icup);
  }
  if ((sr & STM32_TIM_SR_UIF) != 0)
 80006b4:	f014 0f01 	tst.w	r4, #1
 80006b8:	d127      	bne.n	800070a <icu_lld_serve_interrupt+0x8a>
 80006ba:	bd38      	pop	{r3, r4, r5, pc}
      _icu_isr_invoke_width_cb(icup);
 80006bc:	689b      	ldr	r3, [r3, #8]
 80006be:	2b00      	cmp	r3, #0
 80006c0:	d0f0      	beq.n	80006a4 <icu_lld_serve_interrupt+0x24>
 80006c2:	4798      	blx	r3
 80006c4:	e7ee      	b.n	80006a4 <icu_lld_serve_interrupt+0x24>
      _icu_isr_invoke_period_cb(icup);
 80006c6:	686b      	ldr	r3, [r5, #4]
 80006c8:	68db      	ldr	r3, [r3, #12]
 80006ca:	2b00      	cmp	r3, #0
 80006cc:	d0f0      	beq.n	80006b0 <icu_lld_serve_interrupt+0x30>
 80006ce:	4628      	mov	r0, r5
 80006d0:	4798      	blx	r3
 80006d2:	e7ed      	b.n	80006b0 <icu_lld_serve_interrupt+0x30>
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 80006d4:	f014 0f02 	tst.w	r4, #2
 80006d8:	d002      	beq.n	80006e0 <icu_lld_serve_interrupt+0x60>
      _icu_isr_invoke_width_cb(icup);
 80006da:	7802      	ldrb	r2, [r0, #0]
 80006dc:	2a04      	cmp	r2, #4
 80006de:	d008      	beq.n	80006f2 <icu_lld_serve_interrupt+0x72>
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 80006e0:	f014 0f04 	tst.w	r4, #4
 80006e4:	d0e6      	beq.n	80006b4 <icu_lld_serve_interrupt+0x34>
      _icu_isr_invoke_period_cb(icup);
 80006e6:	782b      	ldrb	r3, [r5, #0]
 80006e8:	2b04      	cmp	r3, #4
 80006ea:	d007      	beq.n	80006fc <icu_lld_serve_interrupt+0x7c>
 80006ec:	2304      	movs	r3, #4
 80006ee:	702b      	strb	r3, [r5, #0]
 80006f0:	e7e0      	b.n	80006b4 <icu_lld_serve_interrupt+0x34>
      _icu_isr_invoke_width_cb(icup);
 80006f2:	689b      	ldr	r3, [r3, #8]
 80006f4:	2b00      	cmp	r3, #0
 80006f6:	d0f3      	beq.n	80006e0 <icu_lld_serve_interrupt+0x60>
 80006f8:	4798      	blx	r3
 80006fa:	e7f1      	b.n	80006e0 <icu_lld_serve_interrupt+0x60>
      _icu_isr_invoke_period_cb(icup);
 80006fc:	686b      	ldr	r3, [r5, #4]
 80006fe:	68db      	ldr	r3, [r3, #12]
 8000700:	2b00      	cmp	r3, #0
 8000702:	d0f3      	beq.n	80006ec <icu_lld_serve_interrupt+0x6c>
 8000704:	4628      	mov	r0, r5
 8000706:	4798      	blx	r3
 8000708:	e7f0      	b.n	80006ec <icu_lld_serve_interrupt+0x6c>
    _icu_isr_invoke_overflow_cb(icup);
 800070a:	686b      	ldr	r3, [r5, #4]
 800070c:	691b      	ldr	r3, [r3, #16]
 800070e:	4628      	mov	r0, r5
 8000710:	4798      	blx	r3
 8000712:	2303      	movs	r3, #3
 8000714:	702b      	strb	r3, [r5, #0]
 8000716:	e7d0      	b.n	80006ba <icu_lld_serve_interrupt+0x3a>
	...

08000720 <stm32_clock_init>:
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000720:	4b3b      	ldr	r3, [pc, #236]	; (8000810 <stm32_clock_init+0xf0>)
 8000722:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000726:	641a      	str	r2, [r3, #64]	; 0x40
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8000728:	f44f 4140 	mov.w	r1, #49152	; 0xc000
 800072c:	4a39      	ldr	r2, [pc, #228]	; (8000814 <stm32_clock_init+0xf4>)
 800072e:	6011      	str	r1, [r2, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8000730:	681a      	ldr	r2, [r3, #0]
 8000732:	f042 0201 	orr.w	r2, r2, #1
 8000736:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8000738:	4b35      	ldr	r3, [pc, #212]	; (8000810 <stm32_clock_init+0xf0>)
 800073a:	681b      	ldr	r3, [r3, #0]
 800073c:	f013 0f02 	tst.w	r3, #2
 8000740:	d0fa      	beq.n	8000738 <stm32_clock_init+0x18>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 8000742:	4a33      	ldr	r2, [pc, #204]	; (8000810 <stm32_clock_init+0xf0>)
 8000744:	6893      	ldr	r3, [r2, #8]
 8000746:	f023 0303 	bic.w	r3, r3, #3
 800074a:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800074c:	4b30      	ldr	r3, [pc, #192]	; (8000810 <stm32_clock_init+0xf0>)
 800074e:	689b      	ldr	r3, [r3, #8]
 8000750:	f013 0f0c 	tst.w	r3, #12
 8000754:	d1fa      	bne.n	800074c <stm32_clock_init+0x2c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8000756:	4b2e      	ldr	r3, [pc, #184]	; (8000810 <stm32_clock_init+0xf0>)
 8000758:	681a      	ldr	r2, [r3, #0]
 800075a:	f002 02f9 	and.w	r2, r2, #249	; 0xf9
 800075e:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8000760:	2200      	movs	r2, #0
 8000762:	609a      	str	r2, [r3, #8]
  
#if STM32_HSE_ENABLED
  /* HSE activation.*/
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 8000764:	681a      	ldr	r2, [r3, #0]
 8000766:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
 800076a:	601a      	str	r2, [r3, #0]
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 800076c:	4b28      	ldr	r3, [pc, #160]	; (8000810 <stm32_clock_init+0xf0>)
 800076e:	681b      	ldr	r3, [r3, #0]
 8000770:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 8000774:	d0fa      	beq.n	800076c <stm32_clock_init+0x4c>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8000776:	4a26      	ldr	r2, [pc, #152]	; (8000810 <stm32_clock_init+0xf0>)
 8000778:	6f53      	ldr	r3, [r2, #116]	; 0x74
 800077a:	f043 0301 	orr.w	r3, r3, #1
 800077e:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8000780:	4b23      	ldr	r3, [pc, #140]	; (8000810 <stm32_clock_init+0xf0>)
 8000782:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8000784:	f013 0f02 	tst.w	r3, #2
 8000788:	d0fa      	beq.n	8000780 <stm32_clock_init+0x60>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 800078a:	4b21      	ldr	r3, [pc, #132]	; (8000810 <stm32_clock_init+0xf0>)
 800078c:	4a22      	ldr	r2, [pc, #136]	; (8000818 <stm32_clock_init+0xf8>)
 800078e:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8000790:	681a      	ldr	r2, [r3, #0]
 8000792:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000796:	601a      	str	r2, [r3, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8000798:	4b1e      	ldr	r3, [pc, #120]	; (8000814 <stm32_clock_init+0xf4>)
 800079a:	685b      	ldr	r3, [r3, #4]
 800079c:	f413 4f80 	tst.w	r3, #16384	; 0x4000
 80007a0:	d0fa      	beq.n	8000798 <stm32_clock_init+0x78>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80007a2:	4b1b      	ldr	r3, [pc, #108]	; (8000810 <stm32_clock_init+0xf0>)
 80007a4:	681b      	ldr	r3, [r3, #0]
 80007a6:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 80007aa:	d0fa      	beq.n	80007a2 <stm32_clock_init+0x82>
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
#if !defined(STM32F413xx)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 80007ac:	4b18      	ldr	r3, [pc, #96]	; (8000810 <stm32_clock_init+0xf0>)
 80007ae:	4a1b      	ldr	r2, [pc, #108]	; (800081c <stm32_clock_init+0xfc>)
 80007b0:	609a      	str	r2, [r3, #8]
  /* Special case, in those devices STM32_CK48MSEL is located in the
     DCKCFGR register.*/
    dckcfgr |= STM32_CK48MSEL;
#endif
#if !defined(STM32F413xx)
    RCC->DCKCFGR = dckcfgr |
 80007b2:	2203      	movs	r2, #3
 80007b4:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
  }
#endif

#if STM32_HAS_RCC_DCKCFGR2
  /* DCKCFGR2 register initialization.*/
  RCC->DCKCFGR2 = STM32_CK48MSEL;
 80007b8:	2200      	movs	r2, #0
 80007ba:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80007be:	4b18      	ldr	r3, [pc, #96]	; (8000820 <stm32_clock_init+0x100>)
 80007c0:	681a      	ldr	r2, [r3, #0]
 80007c2:	4b18      	ldr	r3, [pc, #96]	; (8000824 <stm32_clock_init+0x104>)
 80007c4:	429a      	cmp	r2, r3
 80007c6:	d019      	beq.n	80007fc <stm32_clock_init+0xdc>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80007c8:	f240 7205 	movw	r2, #1797	; 0x705
 80007cc:	4b16      	ldr	r3, [pc, #88]	; (8000828 <stm32_clock_init+0x108>)
 80007ce:	601a      	str	r2, [r3, #0]
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80007d0:	4a0f      	ldr	r2, [pc, #60]	; (8000810 <stm32_clock_init+0xf0>)
 80007d2:	6893      	ldr	r3, [r2, #8]
 80007d4:	f043 0302 	orr.w	r3, r3, #2
 80007d8:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80007da:	4b0d      	ldr	r3, [pc, #52]	; (8000810 <stm32_clock_init+0xf0>)
 80007dc:	689b      	ldr	r3, [r3, #8]
 80007de:	f003 030c 	and.w	r3, r3, #12
 80007e2:	2b08      	cmp	r3, #8
 80007e4:	d1f9      	bne.n	80007da <stm32_clock_init+0xba>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 80007e6:	4b0a      	ldr	r3, [pc, #40]	; (8000810 <stm32_clock_init+0xf0>)
 80007e8:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 80007ea:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80007ee:	645a      	str	r2, [r3, #68]	; 0x44
 80007f0:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 80007f2:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80007f6:	665a      	str	r2, [r3, #100]	; 0x64
 80007f8:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80007fa:	4770      	bx	lr
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80007fc:	4b0b      	ldr	r3, [pc, #44]	; (800082c <stm32_clock_init+0x10c>)
 80007fe:	681a      	ldr	r2, [r3, #0]
 8000800:	4b0b      	ldr	r3, [pc, #44]	; (8000830 <stm32_clock_init+0x110>)
 8000802:	429a      	cmp	r2, r3
 8000804:	d1e0      	bne.n	80007c8 <stm32_clock_init+0xa8>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 8000806:	f240 1205 	movw	r2, #261	; 0x105
 800080a:	4b07      	ldr	r3, [pc, #28]	; (8000828 <stm32_clock_init+0x108>)
 800080c:	601a      	str	r2, [r3, #0]
 800080e:	e7df      	b.n	80007d0 <stm32_clock_init+0xb0>
 8000810:	40023800 	.word	0x40023800
 8000814:	40007000 	.word	0x40007000
 8000818:	07405408 	.word	0x07405408
 800081c:	38889400 	.word	0x38889400
 8000820:	e0042000 	.word	0xe0042000
 8000824:	20006411 	.word	0x20006411
 8000828:	40023c00 	.word	0x40023c00
 800082c:	e000ed00 	.word	0xe000ed00
 8000830:	410fc241 	.word	0x410fc241
	...

08000840 <hal_lld_backup_domain_init>:
  PWR->CR |= PWR_CR_DBP;
 8000840:	4a0b      	ldr	r2, [pc, #44]	; (8000870 <hal_lld_backup_domain_init+0x30>)
 8000842:	6813      	ldr	r3, [r2, #0]
 8000844:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000848:	6013      	str	r3, [r2, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800084a:	4b0a      	ldr	r3, [pc, #40]	; (8000874 <hal_lld_backup_domain_init+0x34>)
 800084c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800084e:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8000852:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000856:	d005      	beq.n	8000864 <hal_lld_backup_domain_init+0x24>
    RCC->BDCR = RCC_BDCR_BDRST;
 8000858:	4b06      	ldr	r3, [pc, #24]	; (8000874 <hal_lld_backup_domain_init+0x34>)
 800085a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 800085e:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8000860:	2200      	movs	r2, #0
 8000862:	671a      	str	r2, [r3, #112]	; 0x70
  PWR->CSR &= ~PWR_CSR_BRE;
 8000864:	4a02      	ldr	r2, [pc, #8]	; (8000870 <hal_lld_backup_domain_init+0x30>)
 8000866:	6853      	ldr	r3, [r2, #4]
 8000868:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 800086c:	6053      	str	r3, [r2, #4]
 800086e:	4770      	bx	lr
 8000870:	40007000 	.word	0x40007000
 8000874:	40023800 	.word	0x40023800
	...

08000880 <nvicEnableVector>:

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000880:	0109      	lsls	r1, r1, #4
 8000882:	b2c9      	uxtb	r1, r1
 8000884:	4a08      	ldr	r2, [pc, #32]	; (80008a8 <nvicEnableVector+0x28>)
 8000886:	1813      	adds	r3, r2, r0
 8000888:	f883 1300 	strb.w	r1, [r3, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800088c:	0941      	lsrs	r1, r0, #5
 800088e:	f000 001f 	and.w	r0, r0, #31
 8000892:	2301      	movs	r3, #1
 8000894:	fa03 f000 	lsl.w	r0, r3, r0
 8000898:	f101 0360 	add.w	r3, r1, #96	; 0x60
 800089c:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80008a0:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
 80008a4:	4770      	bx	lr
 80008a6:	bf00      	nop
 80008a8:	e000e100 	.word	0xe000e100
 80008ac:	00000000 	.word	0x00000000

080008b0 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 80008b0:	b538      	push	{r3, r4, r5, lr}
 80008b2:	4604      	mov	r4, r0

  if (config == NULL)
 80008b4:	460d      	mov	r5, r1
 80008b6:	b139      	cbz	r1, 80008c8 <sd_lld_start+0x18>
    config = &default_config;

  if (sdp->state == SD_STOP) {
 80008b8:	7a23      	ldrb	r3, [r4, #8]
 80008ba:	2b01      	cmp	r3, #1
 80008bc:	d006      	beq.n	80008cc <sd_lld_start+0x1c>
      rccEnableUART8(true);
      nvicEnableVector(STM32_UART8_NUMBER, STM32_SERIAL_UART8_PRIORITY);
    }
#endif
  }
  usart_init(sdp, config);
 80008be:	4629      	mov	r1, r5
 80008c0:	4620      	mov	r0, r4
 80008c2:	f7ff fe35 	bl	8000530 <usart_init>
 80008c6:	bd38      	pop	{r3, r4, r5, pc}
    config = &default_config;
 80008c8:	4d09      	ldr	r5, [pc, #36]	; (80008f0 <sd_lld_start+0x40>)
 80008ca:	e7f5      	b.n	80008b8 <sd_lld_start+0x8>
    if (&SD2 == sdp) {
 80008cc:	4b09      	ldr	r3, [pc, #36]	; (80008f4 <sd_lld_start+0x44>)
 80008ce:	429c      	cmp	r4, r3
 80008d0:	d1f5      	bne.n	80008be <sd_lld_start+0xe>
      rccEnableUSART2(true);
 80008d2:	4b09      	ldr	r3, [pc, #36]	; (80008f8 <sd_lld_start+0x48>)
 80008d4:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80008d6:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 80008da:	641a      	str	r2, [r3, #64]	; 0x40
 80008dc:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80008de:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 80008e2:	661a      	str	r2, [r3, #96]	; 0x60
 80008e4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
      nvicEnableVector(STM32_USART2_NUMBER, STM32_SERIAL_USART2_PRIORITY);
 80008e6:	210c      	movs	r1, #12
 80008e8:	2026      	movs	r0, #38	; 0x26
 80008ea:	f7ff ffc9 	bl	8000880 <nvicEnableVector>
 80008ee:	e7e6      	b.n	80008be <sd_lld_start+0xe>
 80008f0:	08002e44 	.word	0x08002e44
 80008f4:	200009d4 	.word	0x200009d4
 80008f8:	40023800 	.word	0x40023800
 80008fc:	00000000 	.word	0x00000000

08000900 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8000900:	b508      	push	{r3, lr}

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8000902:	4b12      	ldr	r3, [pc, #72]	; (800094c <st_lld_init+0x4c>)
 8000904:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 8000906:	f042 0201 	orr.w	r2, r2, #1
 800090a:	641a      	str	r2, [r3, #64]	; 0x40
 800090c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800090e:	f042 0201 	orr.w	r2, r2, #1
 8000912:	661a      	str	r2, [r3, #96]	; 0x60
 8000914:	6e1b      	ldr	r3, [r3, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8000916:	4a0e      	ldr	r2, [pc, #56]	; (8000950 <st_lld_init+0x50>)
 8000918:	6893      	ldr	r3, [r2, #8]
 800091a:	f043 0301 	orr.w	r3, r3, #1
 800091e:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8000920:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000924:	f242 02cf 	movw	r2, #8399	; 0x20cf
 8000928:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 800092a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800092e:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8000930:	2200      	movs	r2, #0
 8000932:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8000934:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->DIER   = 0;
 8000936:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8000938:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800093a:	2201      	movs	r2, #1
 800093c:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 800093e:	601a      	str	r2, [r3, #0]

  /* IRQ enabled.*/
  nvicEnableVector(ST_NUMBER, STM32_ST_IRQ_PRIORITY);
 8000940:	2108      	movs	r1, #8
 8000942:	201c      	movs	r0, #28
 8000944:	f7ff ff9c 	bl	8000880 <nvicEnableVector>
 8000948:	bd08      	pop	{r3, pc}
 800094a:	bf00      	nop
 800094c:	40023800 	.word	0x40023800
 8000950:	e0042000 	.word	0xe0042000
	...

08000960 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8000960:	b508      	push	{r3, lr}

#if HAL_USE_PAL
  nvicEnableVector(EXTI0_IRQn, STM32_IRQ_EXTI0_PRIORITY);
 8000962:	2106      	movs	r1, #6
 8000964:	4608      	mov	r0, r1
 8000966:	f7ff ff8b 	bl	8000880 <nvicEnableVector>
  nvicEnableVector(EXTI1_IRQn, STM32_IRQ_EXTI1_PRIORITY);
 800096a:	2106      	movs	r1, #6
 800096c:	2007      	movs	r0, #7
 800096e:	f7ff ff87 	bl	8000880 <nvicEnableVector>
  nvicEnableVector(EXTI2_IRQn, STM32_IRQ_EXTI2_PRIORITY);
 8000972:	2106      	movs	r1, #6
 8000974:	2008      	movs	r0, #8
 8000976:	f7ff ff83 	bl	8000880 <nvicEnableVector>
  nvicEnableVector(EXTI3_IRQn, STM32_IRQ_EXTI3_PRIORITY);
 800097a:	2106      	movs	r1, #6
 800097c:	2009      	movs	r0, #9
 800097e:	f7ff ff7f 	bl	8000880 <nvicEnableVector>
  nvicEnableVector(EXTI4_IRQn, STM32_IRQ_EXTI4_PRIORITY);
 8000982:	2106      	movs	r1, #6
 8000984:	200a      	movs	r0, #10
 8000986:	f7ff ff7b 	bl	8000880 <nvicEnableVector>
  nvicEnableVector(EXTI9_5_IRQn, STM32_IRQ_EXTI5_9_PRIORITY);
 800098a:	2106      	movs	r1, #6
 800098c:	2017      	movs	r0, #23
 800098e:	f7ff ff77 	bl	8000880 <nvicEnableVector>
  nvicEnableVector(EXTI15_10_IRQn, STM32_IRQ_EXTI10_15_PRIORITY);
 8000992:	2106      	movs	r1, #6
 8000994:	2028      	movs	r0, #40	; 0x28
 8000996:	f7ff ff73 	bl	8000880 <nvicEnableVector>
 800099a:	bd08      	pop	{r3, pc}
 800099c:	0000      	movs	r0, r0
	...

080009a0 <hal_lld_init>:
void hal_lld_init(void) {
 80009a0:	b508      	push	{r3, lr}
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 80009a2:	4b16      	ldr	r3, [pc, #88]	; (80009fc <hal_lld_init+0x5c>)
 80009a4:	691a      	ldr	r2, [r3, #16]
 80009a6:	f062 02ff 	orn	r2, r2, #255	; 0xff
 80009aa:	611a      	str	r2, [r3, #16]
 80009ac:	691a      	ldr	r2, [r3, #16]
 80009ae:	b2d2      	uxtb	r2, r2
 80009b0:	611a      	str	r2, [r3, #16]
 80009b2:	691a      	ldr	r2, [r3, #16]
  rccResetAHB2(~0);
 80009b4:	695a      	ldr	r2, [r3, #20]
 80009b6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80009ba:	6158      	str	r0, [r3, #20]
 80009bc:	695a      	ldr	r2, [r3, #20]
 80009be:	2100      	movs	r1, #0
 80009c0:	6159      	str	r1, [r3, #20]
 80009c2:	695a      	ldr	r2, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80009c4:	6a1a      	ldr	r2, [r3, #32]
 80009c6:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
 80009ca:	621a      	str	r2, [r3, #32]
 80009cc:	6a1a      	ldr	r2, [r3, #32]
 80009ce:	f002 5280 	and.w	r2, r2, #268435456	; 0x10000000
 80009d2:	621a      	str	r2, [r3, #32]
 80009d4:	6a1a      	ldr	r2, [r3, #32]
  rccResetAPB2(~0);
 80009d6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80009d8:	6258      	str	r0, [r3, #36]	; 0x24
 80009da:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80009dc:	6259      	str	r1, [r3, #36]	; 0x24
 80009de:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  rccEnablePWRInterface(true);
 80009e0:	6c1a      	ldr	r2, [r3, #64]	; 0x40
 80009e2:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80009e6:	641a      	str	r2, [r3, #64]	; 0x40
 80009e8:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 80009ea:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80009ee:	661a      	str	r2, [r3, #96]	; 0x60
 80009f0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
  hal_lld_backup_domain_init();
 80009f2:	f7ff ff25 	bl	8000840 <hal_lld_backup_domain_init>
  irqInit();
 80009f6:	f7ff ffb3 	bl	8000960 <irqInit>
 80009fa:	bd08      	pop	{r3, pc}
 80009fc:	40023800 	.word	0x40023800

08000a00 <pwmObjectInit>:
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 8000a00:	2301      	movs	r3, #1
 8000a02:	7003      	strb	r3, [r0, #0]
  pwmp->config   = NULL;
 8000a04:	2300      	movs	r3, #0
 8000a06:	6043      	str	r3, [r0, #4]
  pwmp->enabled  = 0;
 8000a08:	60c3      	str	r3, [r0, #12]
  pwmp->channels = 0;
 8000a0a:	7403      	strb	r3, [r0, #16]
 8000a0c:	4770      	bx	lr
 8000a0e:	bf00      	nop

08000a10 <pwm_lld_init>:
void pwm_lld_init(void) {
 8000a10:	b510      	push	{r4, lr}
  pwmObjectInit(&PWMD1);
 8000a12:	4c04      	ldr	r4, [pc, #16]	; (8000a24 <pwm_lld_init+0x14>)
 8000a14:	4620      	mov	r0, r4
 8000a16:	f7ff fff3 	bl	8000a00 <pwmObjectInit>
  PWMD1.channels = STM32_TIM1_CHANNELS;
 8000a1a:	2304      	movs	r3, #4
 8000a1c:	7423      	strb	r3, [r4, #16]
  PWMD1.tim = STM32_TIM1;
 8000a1e:	4b02      	ldr	r3, [pc, #8]	; (8000a28 <pwm_lld_init+0x18>)
 8000a20:	61a3      	str	r3, [r4, #24]
 8000a22:	bd10      	pop	{r4, pc}
 8000a24:	200009b8 	.word	0x200009b8
 8000a28:	40010000 	.word	0x40010000
 8000a2c:	00000000 	.word	0x00000000

08000a30 <pwmInit>:
void pwmInit(void) {
 8000a30:	b508      	push	{r3, lr}
  pwm_lld_init();
 8000a32:	f7ff ffed 	bl	8000a10 <pwm_lld_init>
 8000a36:	bd08      	pop	{r3, pc}
	...

08000a40 <icuObjectInit>:
 *
 * @init
 */
void icuObjectInit(ICUDriver *icup) {

  icup->state  = ICU_STOP;
 8000a40:	2301      	movs	r3, #1
 8000a42:	7003      	strb	r3, [r0, #0]
  icup->config = NULL;
 8000a44:	2300      	movs	r3, #0
 8000a46:	6043      	str	r3, [r0, #4]
 8000a48:	4770      	bx	lr
 8000a4a:	bf00      	nop
 8000a4c:	0000      	movs	r0, r0
	...

08000a50 <icu_lld_init>:
void icu_lld_init(void) {
 8000a50:	b510      	push	{r4, lr}
  icuObjectInit(&ICUD3);
 8000a52:	4c03      	ldr	r4, [pc, #12]	; (8000a60 <icu_lld_init+0x10>)
 8000a54:	4620      	mov	r0, r4
 8000a56:	f7ff fff3 	bl	8000a40 <icuObjectInit>
  ICUD3.tim = STM32_TIM3;
 8000a5a:	4b02      	ldr	r3, [pc, #8]	; (8000a64 <icu_lld_init+0x14>)
 8000a5c:	60e3      	str	r3, [r4, #12]
 8000a5e:	bd10      	pop	{r4, pc}
 8000a60:	20000840 	.word	0x20000840
 8000a64:	40000400 	.word	0x40000400
	...

08000a70 <icuInit>:
void icuInit(void) {
 8000a70:	b508      	push	{r3, lr}
  icu_lld_init();
 8000a72:	f7ff ffed 	bl	8000a50 <icu_lld_init>
 8000a76:	bd08      	pop	{r3, pc}
	...

08000a80 <oqObjectInit>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000a80:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 8000a82:	6040      	str	r0, [r0, #4]
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000a84:	6082      	str	r2, [r0, #8]
  oqp->q_buffer  = bp;
 8000a86:	60c1      	str	r1, [r0, #12]
  oqp->q_rdptr   = bp;
 8000a88:	6181      	str	r1, [r0, #24]
  oqp->q_wrptr   = bp;
 8000a8a:	6141      	str	r1, [r0, #20]
  oqp->q_top     = bp + size;
 8000a8c:	4411      	add	r1, r2
 8000a8e:	6101      	str	r1, [r0, #16]
  oqp->q_notify  = onfy;
 8000a90:	61c3      	str	r3, [r0, #28]
  oqp->q_link    = link;
 8000a92:	9b00      	ldr	r3, [sp, #0]
 8000a94:	6203      	str	r3, [r0, #32]
 8000a96:	4770      	bx	lr
	...

08000aa0 <iqObjectInit>:
                  qnotify_t infy, void *link) {
 8000aa0:	b410      	push	{r4}
  tqp->next = (thread_t *)tqp;
 8000aa2:	6000      	str	r0, [r0, #0]
  tqp->prev = (thread_t *)tqp;
 8000aa4:	6040      	str	r0, [r0, #4]
  iqp->q_counter = 0;
 8000aa6:	2400      	movs	r4, #0
 8000aa8:	6084      	str	r4, [r0, #8]
  iqp->q_buffer  = bp;
 8000aaa:	60c1      	str	r1, [r0, #12]
  iqp->q_rdptr   = bp;
 8000aac:	6181      	str	r1, [r0, #24]
  iqp->q_wrptr   = bp;
 8000aae:	6141      	str	r1, [r0, #20]
  iqp->q_top     = bp + size;
 8000ab0:	440a      	add	r2, r1
 8000ab2:	6102      	str	r2, [r0, #16]
  iqp->q_notify  = infy;
 8000ab4:	61c3      	str	r3, [r0, #28]
  iqp->q_link    = link;
 8000ab6:	9b01      	ldr	r3, [sp, #4]
 8000ab8:	6203      	str	r3, [r0, #32]
}
 8000aba:	f85d 4b04 	ldr.w	r4, [sp], #4
 8000abe:	4770      	bx	lr

08000ac0 <sdObjectInit>:
 * @init
 */
#if !defined(SERIAL_ADVANCED_BUFFERING_SUPPORT) ||                          \
    (SERIAL_ADVANCED_BUFFERING_SUPPORT == FALSE) ||                         \
    defined(__DOXYGEN__)
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 8000ac0:	b530      	push	{r4, r5, lr}
 8000ac2:	b083      	sub	sp, #12
 8000ac4:	4604      	mov	r4, r0
 8000ac6:	4615      	mov	r5, r2

  sdp->vmt = &vmt;
 8000ac8:	4603      	mov	r3, r0
 8000aca:	4a0c      	ldr	r2, [pc, #48]	; (8000afc <sdObjectInit+0x3c>)
 8000acc:	f843 2b04 	str.w	r2, [r3], #4
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8000ad0:	6043      	str	r3, [r0, #4]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8000ad2:	2301      	movs	r3, #1
 8000ad4:	7203      	strb	r3, [r0, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 8000ad6:	9000      	str	r0, [sp, #0]
 8000ad8:	460b      	mov	r3, r1
 8000ada:	2210      	movs	r2, #16
 8000adc:	f100 0154 	add.w	r1, r0, #84	; 0x54
 8000ae0:	300c      	adds	r0, #12
 8000ae2:	f7ff ffdd 	bl	8000aa0 <iqObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 8000ae6:	9400      	str	r4, [sp, #0]
 8000ae8:	462b      	mov	r3, r5
 8000aea:	2210      	movs	r2, #16
 8000aec:	f104 0164 	add.w	r1, r4, #100	; 0x64
 8000af0:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8000af4:	f7ff ffc4 	bl	8000a80 <oqObjectInit>
}
 8000af8:	b003      	add	sp, #12
 8000afa:	bd30      	pop	{r4, r5, pc}
 8000afc:	08002fd0 	.word	0x08002fd0

08000b00 <sd_lld_init>:
void sd_lld_init(void) {
 8000b00:	b510      	push	{r4, lr}
  sdObjectInit(&SD2, NULL, notify2);
 8000b02:	4c04      	ldr	r4, [pc, #16]	; (8000b14 <sd_lld_init+0x14>)
 8000b04:	4a04      	ldr	r2, [pc, #16]	; (8000b18 <sd_lld_init+0x18>)
 8000b06:	2100      	movs	r1, #0
 8000b08:	4620      	mov	r0, r4
 8000b0a:	f7ff ffd9 	bl	8000ac0 <sdObjectInit>
  SD2.usart = USART2;
 8000b0e:	4b03      	ldr	r3, [pc, #12]	; (8000b1c <sd_lld_init+0x1c>)
 8000b10:	6763      	str	r3, [r4, #116]	; 0x74
 8000b12:	bd10      	pop	{r4, pc}
 8000b14:	200009d4 	.word	0x200009d4
 8000b18:	08000521 	.word	0x08000521
 8000b1c:	40004400 	.word	0x40004400

08000b20 <sdInit>:
void sdInit(void) {
 8000b20:	b508      	push	{r3, lr}
  sd_lld_init();
 8000b22:	f7ff ffed 	bl	8000b00 <sd_lld_init>
 8000b26:	bd08      	pop	{r3, pc}
	...

08000b30 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8000b30:	b508      	push	{r3, lr}

  st_lld_init();
 8000b32:	f7ff fee5 	bl	8000900 <st_lld_init>
 8000b36:	bd08      	pop	{r3, pc}
	...

08000b40 <set_error>:
static void set_error(SerialDriver *sdp, uint16_t sr) {
 8000b40:	b508      	push	{r3, lr}
  if (sr & USART_SR_ORE)
 8000b42:	f011 0f08 	tst.w	r1, #8
 8000b46:	d114      	bne.n	8000b72 <set_error+0x32>
  eventflags_t sts = 0;
 8000b48:	2300      	movs	r3, #0
  if (sr & USART_SR_PE)
 8000b4a:	f011 0f01 	tst.w	r1, #1
 8000b4e:	d001      	beq.n	8000b54 <set_error+0x14>
    sts |= SD_PARITY_ERROR;
 8000b50:	f043 0320 	orr.w	r3, r3, #32
  if (sr & USART_SR_FE)
 8000b54:	f011 0f02 	tst.w	r1, #2
 8000b58:	d001      	beq.n	8000b5e <set_error+0x1e>
    sts |= SD_FRAMING_ERROR;
 8000b5a:	f043 0340 	orr.w	r3, r3, #64	; 0x40
  if (sr & USART_SR_NE)
 8000b5e:	f011 0f04 	tst.w	r1, #4
 8000b62:	d001      	beq.n	8000b68 <set_error+0x28>
    sts |= SD_NOISE_ERROR;
 8000b64:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8000b68:	4619      	mov	r1, r3
 8000b6a:	3004      	adds	r0, #4
 8000b6c:	f001 fea8 	bl	80028c0 <chEvtBroadcastFlagsI>
 8000b70:	bd08      	pop	{r3, pc}
    sts |= SD_OVERRUN_ERROR;
 8000b72:	2380      	movs	r3, #128	; 0x80
 8000b74:	e7e9      	b.n	8000b4a <set_error+0xa>
 8000b76:	bf00      	nop
	...

08000b80 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
 8000b80:	b538      	push	{r3, r4, r5, lr}
 8000b82:	4604      	mov	r4, r0

  osalDbgCheckClassI();
 8000b84:	f001 f85c 	bl	8001c40 <chDbgCheckClassI>

  /* Queue data check.*/
  if (!oqIsEmptyI(oqp)) {
 8000b88:	69a3      	ldr	r3, [r4, #24]
 8000b8a:	6962      	ldr	r2, [r4, #20]
 8000b8c:	429a      	cmp	r2, r3
 8000b8e:	d012      	beq.n	8000bb6 <oqGetI+0x36>
 8000b90:	2200      	movs	r2, #0
 8000b92:	b9aa      	cbnz	r2, 8000bc0 <oqGetI+0x40>
    uint8_t b;

    oqp->q_counter++;
 8000b94:	68a2      	ldr	r2, [r4, #8]
 8000b96:	3201      	adds	r2, #1
 8000b98:	60a2      	str	r2, [r4, #8]
    b = *oqp->q_rdptr++;
 8000b9a:	1c5a      	adds	r2, r3, #1
 8000b9c:	61a2      	str	r2, [r4, #24]
 8000b9e:	781d      	ldrb	r5, [r3, #0]
    if (oqp->q_rdptr >= oqp->q_top) {
 8000ba0:	6923      	ldr	r3, [r4, #16]
 8000ba2:	429a      	cmp	r2, r3
 8000ba4:	d301      	bcc.n	8000baa <oqGetI+0x2a>
      oqp->q_rdptr = oqp->q_buffer;
 8000ba6:	68e3      	ldr	r3, [r4, #12]
 8000ba8:	61a3      	str	r3, [r4, #24]
  chThdDequeueNextI(tqp, msg);
 8000baa:	2100      	movs	r1, #0
 8000bac:	4620      	mov	r0, r4
 8000bae:	f001 febf 	bl	8002930 <chThdDequeueNextI>
    }

    osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);

    return (msg_t)b;
 8000bb2:	4628      	mov	r0, r5
 8000bb4:	bd38      	pop	{r3, r4, r5, pc}
  if (!oqIsEmptyI(oqp)) {
 8000bb6:	68a2      	ldr	r2, [r4, #8]
 8000bb8:	2a00      	cmp	r2, #0
 8000bba:	d0ea      	beq.n	8000b92 <oqGetI+0x12>
 8000bbc:	2201      	movs	r2, #1
 8000bbe:	e7e8      	b.n	8000b92 <oqGetI+0x12>
  }

  return MSG_TIMEOUT;
 8000bc0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8000bc4:	bd38      	pop	{r3, r4, r5, pc}
 8000bc6:	bf00      	nop
	...

08000bd0 <iqPutI>:
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
 8000bd0:	b538      	push	{r3, r4, r5, lr}
 8000bd2:	4604      	mov	r4, r0
 8000bd4:	460d      	mov	r5, r1
  osalDbgCheckClassI();
 8000bd6:	f001 f833 	bl	8001c40 <chDbgCheckClassI>
  if (!iqIsFullI(iqp)) {
 8000bda:	6963      	ldr	r3, [r4, #20]
 8000bdc:	69a2      	ldr	r2, [r4, #24]
 8000bde:	4293      	cmp	r3, r2
 8000be0:	d013      	beq.n	8000c0a <iqPutI+0x3a>
 8000be2:	2200      	movs	r2, #0
 8000be4:	b9b2      	cbnz	r2, 8000c14 <iqPutI+0x44>
    iqp->q_counter++;
 8000be6:	68a2      	ldr	r2, [r4, #8]
 8000be8:	3201      	adds	r2, #1
 8000bea:	60a2      	str	r2, [r4, #8]
    *iqp->q_wrptr++ = b;
 8000bec:	1c5a      	adds	r2, r3, #1
 8000bee:	6162      	str	r2, [r4, #20]
 8000bf0:	701d      	strb	r5, [r3, #0]
    if (iqp->q_wrptr >= iqp->q_top) {
 8000bf2:	6962      	ldr	r2, [r4, #20]
 8000bf4:	6923      	ldr	r3, [r4, #16]
 8000bf6:	429a      	cmp	r2, r3
 8000bf8:	d301      	bcc.n	8000bfe <iqPutI+0x2e>
      iqp->q_wrptr = iqp->q_buffer;
 8000bfa:	68e3      	ldr	r3, [r4, #12]
 8000bfc:	6163      	str	r3, [r4, #20]
 8000bfe:	2100      	movs	r1, #0
 8000c00:	4620      	mov	r0, r4
 8000c02:	f001 fe95 	bl	8002930 <chThdDequeueNextI>
    return MSG_OK;
 8000c06:	2000      	movs	r0, #0
 8000c08:	bd38      	pop	{r3, r4, r5, pc}
  if (!iqIsFullI(iqp)) {
 8000c0a:	68a2      	ldr	r2, [r4, #8]
 8000c0c:	2a00      	cmp	r2, #0
 8000c0e:	d0e9      	beq.n	8000be4 <iqPutI+0x14>
 8000c10:	2201      	movs	r2, #1
 8000c12:	e7e7      	b.n	8000be4 <iqPutI+0x14>
  return MSG_TIMEOUT;
 8000c14:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
 8000c18:	bd38      	pop	{r3, r4, r5, pc}
 8000c1a:	bf00      	nop
 8000c1c:	0000      	movs	r0, r0
	...

08000c20 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8000c20:	b508      	push	{r3, lr}
 8000c22:	4604      	mov	r4, r0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000c24:	b672      	cpsid	i

  port_disable();

  /* Logging the event.*/
  _trace_halt(reason);
 8000c26:	f000 ff53 	bl	8001ad0 <_trace_halt>

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 8000c2a:	4b01      	ldr	r3, [pc, #4]	; (8000c30 <chSysHalt+0x10>)
 8000c2c:	62dc      	str	r4, [r3, #44]	; 0x2c
 8000c2e:	e7fe      	b.n	8000c2e <chSysHalt+0xe>
 8000c30:	20000a50 	.word	0x20000a50
	...

08000c40 <pwm_lld_start>:
void pwm_lld_start(PWMDriver *pwmp) {
 8000c40:	b510      	push	{r4, lr}
 8000c42:	4604      	mov	r4, r0
  if (pwmp->state == PWM_STOP) {
 8000c44:	7803      	ldrb	r3, [r0, #0]
 8000c46:	2b01      	cmp	r3, #1
 8000c48:	d01c      	beq.n	8000c84 <pwm_lld_start+0x44>
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 8000c4a:	6982      	ldr	r2, [r0, #24]
 8000c4c:	2300      	movs	r3, #0
 8000c4e:	6013      	str	r3, [r2, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 8000c50:	6982      	ldr	r2, [r0, #24]
 8000c52:	6353      	str	r3, [r2, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 8000c54:	6982      	ldr	r2, [r0, #24]
 8000c56:	6393      	str	r3, [r2, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 8000c58:	6982      	ldr	r2, [r0, #24]
 8000c5a:	63d3      	str	r3, [r2, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 8000c5c:	6982      	ldr	r2, [r0, #24]
 8000c5e:	6413      	str	r3, [r2, #64]	; 0x40
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 8000c60:	6982      	ldr	r2, [r0, #24]
 8000c62:	6253      	str	r3, [r2, #36]	; 0x24
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8000c64:	6961      	ldr	r1, [r4, #20]
 8000c66:	6863      	ldr	r3, [r4, #4]
 8000c68:	6818      	ldr	r0, [r3, #0]
 8000c6a:	fbb1 f3f0 	udiv	r3, r1, r0
 8000c6e:	1e5a      	subs	r2, r3, #1
  osalDbgAssert((psc <= 0xFFFF) &&
 8000c70:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8000c74:	d203      	bcs.n	8000c7e <pwm_lld_start+0x3e>
 8000c76:	fb03 f300 	mul.w	r3, r3, r0
 8000c7a:	4299      	cmp	r1, r3
 8000c7c:	d02a      	beq.n	8000cd4 <pwm_lld_start+0x94>
 8000c7e:	483d      	ldr	r0, [pc, #244]	; (8000d74 <pwm_lld_start+0x134>)
 8000c80:	f7ff ffce 	bl	8000c20 <chSysHalt>
    if (&PWMD1 == pwmp) {
 8000c84:	4b3c      	ldr	r3, [pc, #240]	; (8000d78 <pwm_lld_start+0x138>)
 8000c86:	4298      	cmp	r0, r3
 8000c88:	d006      	beq.n	8000c98 <pwm_lld_start+0x58>
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8000c8a:	69a2      	ldr	r2, [r4, #24]
 8000c8c:	f646 0368 	movw	r3, #26728	; 0x6868
 8000c90:	6193      	str	r3, [r2, #24]
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 8000c92:	69a2      	ldr	r2, [r4, #24]
 8000c94:	61d3      	str	r3, [r2, #28]
 8000c96:	e7e5      	b.n	8000c64 <pwm_lld_start+0x24>
      rccEnableTIM1(true);
 8000c98:	4b38      	ldr	r3, [pc, #224]	; (8000d7c <pwm_lld_start+0x13c>)
 8000c9a:	6c5a      	ldr	r2, [r3, #68]	; 0x44
 8000c9c:	f042 0201 	orr.w	r2, r2, #1
 8000ca0:	645a      	str	r2, [r3, #68]	; 0x44
 8000ca2:	6e5a      	ldr	r2, [r3, #100]	; 0x64
 8000ca4:	f042 0201 	orr.w	r2, r2, #1
 8000ca8:	665a      	str	r2, [r3, #100]	; 0x64
 8000caa:	6e5a      	ldr	r2, [r3, #100]	; 0x64
      rccResetTIM1();
 8000cac:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000cae:	f042 0201 	orr.w	r2, r2, #1
 8000cb2:	625a      	str	r2, [r3, #36]	; 0x24
 8000cb4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000cb6:	f022 0201 	bic.w	r2, r2, #1
 8000cba:	625a      	str	r2, [r3, #36]	; 0x24
 8000cbc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      nvicEnableVector(STM32_TIM1_UP_NUMBER, STM32_PWM_TIM1_IRQ_PRIORITY);
 8000cbe:	2107      	movs	r1, #7
 8000cc0:	2019      	movs	r0, #25
 8000cc2:	f7ff fddd 	bl	8000880 <nvicEnableVector>
      nvicEnableVector(STM32_TIM1_CC_NUMBER, STM32_PWM_TIM1_IRQ_PRIORITY);
 8000cc6:	2107      	movs	r1, #7
 8000cc8:	201b      	movs	r0, #27
 8000cca:	f7ff fdd9 	bl	8000880 <nvicEnableVector>
      pwmp->clock = STM32_TIMCLK2;
 8000cce:	4b2c      	ldr	r3, [pc, #176]	; (8000d80 <pwm_lld_start+0x140>)
 8000cd0:	6163      	str	r3, [r4, #20]
 8000cd2:	e7da      	b.n	8000c8a <pwm_lld_start+0x4a>
  pwmp->tim->PSC  = psc;
 8000cd4:	69a3      	ldr	r3, [r4, #24]
 8000cd6:	629a      	str	r2, [r3, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
 8000cd8:	69a2      	ldr	r2, [r4, #24]
 8000cda:	68a3      	ldr	r3, [r4, #8]
 8000cdc:	3b01      	subs	r3, #1
 8000cde:	62d3      	str	r3, [r2, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 8000ce0:	69a3      	ldr	r3, [r4, #24]
 8000ce2:	6862      	ldr	r2, [r4, #4]
 8000ce4:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8000ce6:	605a      	str	r2, [r3, #4]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8000ce8:	6862      	ldr	r2, [r4, #4]
 8000cea:	68d3      	ldr	r3, [r2, #12]
 8000cec:	f003 030f 	and.w	r3, r3, #15
 8000cf0:	2b01      	cmp	r3, #1
 8000cf2:	d003      	beq.n	8000cfc <pwm_lld_start+0xbc>
 8000cf4:	2b02      	cmp	r3, #2
 8000cf6:	d03b      	beq.n	8000d70 <pwm_lld_start+0x130>
  ccer = 0;
 8000cf8:	2300      	movs	r3, #0
 8000cfa:	e002      	b.n	8000d02 <pwm_lld_start+0xc2>
 8000cfc:	2300      	movs	r3, #0
    ccer |= STM32_TIM_CCER_CC1E;
 8000cfe:	f043 0301 	orr.w	r3, r3, #1
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 8000d02:	6951      	ldr	r1, [r2, #20]
 8000d04:	f001 010f 	and.w	r1, r1, #15
 8000d08:	2901      	cmp	r1, #1
 8000d0a:	d003      	beq.n	8000d14 <pwm_lld_start+0xd4>
 8000d0c:	2902      	cmp	r1, #2
 8000d0e:	d103      	bne.n	8000d18 <pwm_lld_start+0xd8>
    ccer |= STM32_TIM_CCER_CC2P;
 8000d10:	f043 0320 	orr.w	r3, r3, #32
    ccer |= STM32_TIM_CCER_CC2E;
 8000d14:	f043 0310 	orr.w	r3, r3, #16
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 8000d18:	69d1      	ldr	r1, [r2, #28]
 8000d1a:	f001 010f 	and.w	r1, r1, #15
 8000d1e:	2901      	cmp	r1, #1
 8000d20:	d003      	beq.n	8000d2a <pwm_lld_start+0xea>
 8000d22:	2902      	cmp	r1, #2
 8000d24:	d103      	bne.n	8000d2e <pwm_lld_start+0xee>
    ccer |= STM32_TIM_CCER_CC3P;
 8000d26:	f443 7300 	orr.w	r3, r3, #512	; 0x200
    ccer |= STM32_TIM_CCER_CC3E;
 8000d2a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 8000d2e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8000d30:	f002 020f 	and.w	r2, r2, #15
 8000d34:	2a01      	cmp	r2, #1
 8000d36:	d003      	beq.n	8000d40 <pwm_lld_start+0x100>
 8000d38:	2a02      	cmp	r2, #2
 8000d3a:	d103      	bne.n	8000d44 <pwm_lld_start+0x104>
    ccer |= STM32_TIM_CCER_CC4P;
 8000d3c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
    ccer |= STM32_TIM_CCER_CC4E;
 8000d40:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
  pwmp->tim->CCER  = ccer;
 8000d44:	69a2      	ldr	r2, [r4, #24]
 8000d46:	6213      	str	r3, [r2, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8000d48:	69a3      	ldr	r3, [r4, #24]
 8000d4a:	2201      	movs	r2, #1
 8000d4c:	615a      	str	r2, [r3, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8000d4e:	69a3      	ldr	r3, [r4, #24]
 8000d50:	2200      	movs	r2, #0
 8000d52:	611a      	str	r2, [r3, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8000d54:	69a2      	ldr	r2, [r4, #24]
 8000d56:	6863      	ldr	r3, [r4, #4]
 8000d58:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8000d5a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8000d5e:	60d3      	str	r3, [r2, #12]
  pwmp->tim->BDTR  = STM32_TIM_BDTR_MOE;
 8000d60:	69a3      	ldr	r3, [r4, #24]
 8000d62:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8000d66:	645a      	str	r2, [r3, #68]	; 0x44
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 8000d68:	69a3      	ldr	r3, [r4, #24]
 8000d6a:	2285      	movs	r2, #133	; 0x85
 8000d6c:	601a      	str	r2, [r3, #0]
 8000d6e:	bd10      	pop	{r4, pc}
    ccer |= STM32_TIM_CCER_CC1P;
 8000d70:	2302      	movs	r3, #2
 8000d72:	e7c4      	b.n	8000cfe <pwm_lld_start+0xbe>
 8000d74:	08002d68 	.word	0x08002d68
 8000d78:	200009b8 	.word	0x200009b8
 8000d7c:	40023800 	.word	0x40023800
 8000d80:	0a037a00 	.word	0x0a037a00
	...

08000d90 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8000d90:	b538      	push	{r3, r4, r5, lr}
 8000d92:	4604      	mov	r4, r0
 8000d94:	460d      	mov	r5, r1

  osalDbgCheckClassI();
 8000d96:	f000 ff53 	bl	8001c40 <chDbgCheckClassI>
  osalDbgCheck(sdp != NULL);
 8000d9a:	b14c      	cbz	r4, 8000db0 <sdIncomingDataI+0x20>

  if (iqIsEmptyI(&sdp->iqueue))
 8000d9c:	6963      	ldr	r3, [r4, #20]
 8000d9e:	b153      	cbz	r3, 8000db6 <sdIncomingDataI+0x26>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
 8000da0:	4629      	mov	r1, r5
 8000da2:	f104 000c 	add.w	r0, r4, #12
 8000da6:	f7ff ff13 	bl	8000bd0 <iqPutI>
 8000daa:	2800      	cmp	r0, #0
 8000dac:	db08      	blt.n	8000dc0 <sdIncomingDataI+0x30>
 8000dae:	bd38      	pop	{r3, r4, r5, pc}
  osalDbgCheck(sdp != NULL);
 8000db0:	4806      	ldr	r0, [pc, #24]	; (8000dcc <sdIncomingDataI+0x3c>)
 8000db2:	f7ff ff35 	bl	8000c20 <chSysHalt>
  chEvtBroadcastFlagsI(esp, flags);
 8000db6:	2104      	movs	r1, #4
 8000db8:	1860      	adds	r0, r4, r1
 8000dba:	f001 fd81 	bl	80028c0 <chEvtBroadcastFlagsI>
 8000dbe:	e7ef      	b.n	8000da0 <sdIncomingDataI+0x10>
 8000dc0:	f44f 6180 	mov.w	r1, #1024	; 0x400
 8000dc4:	1d20      	adds	r0, r4, #4
 8000dc6:	f001 fd7b 	bl	80028c0 <chEvtBroadcastFlagsI>
 8000dca:	e7f0      	b.n	8000dae <sdIncomingDataI+0x1e>
 8000dcc:	08002de8 	.word	0x08002de8

08000dd0 <serve_interrupt>:
static void serve_interrupt(SerialDriver *sdp) {
 8000dd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000dd2:	4606      	mov	r6, r0
  USART_TypeDef *u = sdp->usart;
 8000dd4:	6f45      	ldr	r5, [r0, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8000dd6:	68ef      	ldr	r7, [r5, #12]
  uint16_t sr = u->SR;
 8000dd8:	682b      	ldr	r3, [r5, #0]
 8000dda:	b29c      	uxth	r4, r3
  if (sr & USART_SR_LBD) {
 8000ddc:	f413 7f80 	tst.w	r3, #256	; 0x100
 8000de0:	d105      	bne.n	8000dee <serve_interrupt+0x1e>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000de2:	2320      	movs	r3, #32
 8000de4:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chSysLockFromISR(void) {

  port_lock_from_isr();
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
 8000de8:	f001 f9ca 	bl	8002180 <_dbg_check_lock_from_isr>
 8000dec:	e019      	b.n	8000e22 <serve_interrupt+0x52>
 8000dee:	2320      	movs	r3, #32
 8000df0:	f383 8811 	msr	BASEPRI, r3
 8000df4:	f001 f9c4 	bl	8002180 <_dbg_check_lock_from_isr>
 8000df8:	f44f 7100 	mov.w	r1, #512	; 0x200
 8000dfc:	1d30      	adds	r0, r6, #4
 8000dfe:	f001 fd5f 	bl	80028c0 <chEvtBroadcastFlagsI>
    u->SR = ~USART_SR_LBD;
 8000e02:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8000e06:	602b      	str	r3, [r5, #0]
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {

  _dbg_check_unlock_from_isr();
 8000e08:	f001 f9a2 	bl	8002150 <_dbg_check_unlock_from_isr>
 8000e0c:	2300      	movs	r3, #0
 8000e0e:	f383 8811 	msr	BASEPRI, r3
 8000e12:	e7e6      	b.n	8000de2 <serve_interrupt+0x12>
      set_error(sdp, sr);
 8000e14:	4621      	mov	r1, r4
 8000e16:	4630      	mov	r0, r6
 8000e18:	f7ff fe92 	bl	8000b40 <set_error>
 8000e1c:	e007      	b.n	8000e2e <serve_interrupt+0x5e>
    sr = u->SR;
 8000e1e:	682c      	ldr	r4, [r5, #0]
 8000e20:	b2a4      	uxth	r4, r4
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8000e22:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8000e26:	d00d      	beq.n	8000e44 <serve_interrupt+0x74>
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8000e28:	f014 0f0f 	tst.w	r4, #15
 8000e2c:	d1f2      	bne.n	8000e14 <serve_interrupt+0x44>
    b = (uint8_t)u->DR & sdp->rxmask;
 8000e2e:	6869      	ldr	r1, [r5, #4]
 8000e30:	f896 3078 	ldrb.w	r3, [r6, #120]	; 0x78
 8000e34:	4019      	ands	r1, r3
    if (sr & USART_SR_RXNE)
 8000e36:	f014 0f20 	tst.w	r4, #32
 8000e3a:	d0f0      	beq.n	8000e1e <serve_interrupt+0x4e>
      sdIncomingDataI(sdp, b);
 8000e3c:	4630      	mov	r0, r6
 8000e3e:	f7ff ffa7 	bl	8000d90 <sdIncomingDataI>
 8000e42:	e7ec      	b.n	8000e1e <serve_interrupt+0x4e>
 8000e44:	f001 f984 	bl	8002150 <_dbg_check_unlock_from_isr>
 8000e48:	2300      	movs	r3, #0
 8000e4a:	f383 8811 	msr	BASEPRI, r3
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8000e4e:	f017 0f80 	tst.w	r7, #128	; 0x80
 8000e52:	d002      	beq.n	8000e5a <serve_interrupt+0x8a>
 8000e54:	f014 0f80 	tst.w	r4, #128	; 0x80
 8000e58:	d106      	bne.n	8000e68 <serve_interrupt+0x98>
  if ((cr1 & USART_CR1_TCIE) && (sr & USART_SR_TC)) {
 8000e5a:	f017 0f40 	tst.w	r7, #64	; 0x40
 8000e5e:	d002      	beq.n	8000e66 <serve_interrupt+0x96>
 8000e60:	f014 0f40 	tst.w	r4, #64	; 0x40
 8000e64:	d11b      	bne.n	8000e9e <serve_interrupt+0xce>
 8000e66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000e68:	2320      	movs	r3, #32
 8000e6a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8000e6e:	f001 f987 	bl	8002180 <_dbg_check_lock_from_isr>
    b = oqGetI(&sdp->oqueue);
 8000e72:	f106 0030 	add.w	r0, r6, #48	; 0x30
 8000e76:	f7ff fe83 	bl	8000b80 <oqGetI>
    if (b < MSG_OK) {
 8000e7a:	2800      	cmp	r0, #0
 8000e7c:	db06      	blt.n	8000e8c <serve_interrupt+0xbc>
      u->DR = b;
 8000e7e:	6068      	str	r0, [r5, #4]
  _dbg_check_unlock_from_isr();
 8000e80:	f001 f966 	bl	8002150 <_dbg_check_unlock_from_isr>
 8000e84:	2300      	movs	r3, #0
 8000e86:	f383 8811 	msr	BASEPRI, r3
 8000e8a:	e7e6      	b.n	8000e5a <serve_interrupt+0x8a>
 8000e8c:	2108      	movs	r1, #8
 8000e8e:	1d30      	adds	r0, r6, #4
 8000e90:	f001 fd16 	bl	80028c0 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TXEIE;
 8000e94:	f64f 737f 	movw	r3, #65407	; 0xff7f
 8000e98:	403b      	ands	r3, r7
 8000e9a:	60eb      	str	r3, [r5, #12]
 8000e9c:	e7f0      	b.n	8000e80 <serve_interrupt+0xb0>
 8000e9e:	2320      	movs	r3, #32
 8000ea0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 8000ea4:	f001 f96c 	bl	8002180 <_dbg_check_lock_from_isr>
    if (oqIsEmptyI(&sdp->oqueue)) {
 8000ea8:	6c72      	ldr	r2, [r6, #68]	; 0x44
 8000eaa:	6cb3      	ldr	r3, [r6, #72]	; 0x48
 8000eac:	429a      	cmp	r2, r3
 8000eae:	d007      	beq.n	8000ec0 <serve_interrupt+0xf0>
 8000eb0:	2300      	movs	r3, #0
 8000eb2:	b953      	cbnz	r3, 8000eca <serve_interrupt+0xfa>
  _dbg_check_unlock_from_isr();
 8000eb4:	f001 f94c 	bl	8002150 <_dbg_check_unlock_from_isr>
 8000eb8:	2300      	movs	r3, #0
 8000eba:	f383 8811 	msr	BASEPRI, r3
 8000ebe:	e7d2      	b.n	8000e66 <serve_interrupt+0x96>
 8000ec0:	6bb3      	ldr	r3, [r6, #56]	; 0x38
 8000ec2:	2b00      	cmp	r3, #0
 8000ec4:	d0f5      	beq.n	8000eb2 <serve_interrupt+0xe2>
 8000ec6:	2301      	movs	r3, #1
 8000ec8:	e7f3      	b.n	8000eb2 <serve_interrupt+0xe2>
 8000eca:	2110      	movs	r1, #16
 8000ecc:	1d30      	adds	r0, r6, #4
 8000ece:	f001 fcf7 	bl	80028c0 <chEvtBroadcastFlagsI>
      u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000ed2:	f027 0740 	bic.w	r7, r7, #64	; 0x40
 8000ed6:	043f      	lsls	r7, r7, #16
 8000ed8:	0c3f      	lsrs	r7, r7, #16
 8000eda:	60ef      	str	r7, [r5, #12]
 8000edc:	e7ea      	b.n	8000eb4 <serve_interrupt+0xe4>
 8000ede:	bf00      	nop

08000ee0 <_ctl>:
static msg_t _ctl(void *ip, unsigned int operation, void *arg) {
 8000ee0:	b508      	push	{r3, lr}
  osalDbgCheck(sdp != NULL);
 8000ee2:	b130      	cbz	r0, 8000ef2 <_ctl+0x12>
  switch (operation) {
 8000ee4:	b141      	cbz	r1, 8000ef8 <_ctl+0x18>
 8000ee6:	2901      	cmp	r1, #1
 8000ee8:	d109      	bne.n	8000efe <_ctl+0x1e>
    osalDbgCheck(arg == NULL);
 8000eea:	b142      	cbz	r2, 8000efe <_ctl+0x1e>
 8000eec:	4805      	ldr	r0, [pc, #20]	; (8000f04 <_ctl+0x24>)
 8000eee:	f7ff fe97 	bl	8000c20 <chSysHalt>
  osalDbgCheck(sdp != NULL);
 8000ef2:	4804      	ldr	r0, [pc, #16]	; (8000f04 <_ctl+0x24>)
 8000ef4:	f7ff fe94 	bl	8000c20 <chSysHalt>
    osalDbgAssert(false, "invalid CTL operation");
 8000ef8:	4802      	ldr	r0, [pc, #8]	; (8000f04 <_ctl+0x24>)
 8000efa:	f7ff fe91 	bl	8000c20 <chSysHalt>
}
 8000efe:	2000      	movs	r0, #0
 8000f00:	bd08      	pop	{r3, pc}
 8000f02:	bf00      	nop
 8000f04:	08002dd8 	.word	0x08002dd8
	...

08000f10 <oq_write>:
static size_t oq_write(output_queue_t *oqp, const uint8_t *bp, size_t n) {
 8000f10:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  osalDbgCheck(n > 0U);
 8000f14:	b1ca      	cbz	r2, 8000f4a <oq_write+0x3a>
 8000f16:	4604      	mov	r4, r0
 8000f18:	460f      	mov	r7, r1
 8000f1a:	4615      	mov	r5, r2
  if (n > oqGetEmptyI(oqp)) {
 8000f1c:	6883      	ldr	r3, [r0, #8]
 8000f1e:	429a      	cmp	r2, r3
 8000f20:	d900      	bls.n	8000f24 <oq_write+0x14>
    n = oqGetEmptyI(oqp);
 8000f22:	6885      	ldr	r5, [r0, #8]
  s1 = (size_t)(oqp->q_top - oqp->q_wrptr);
 8000f24:	6926      	ldr	r6, [r4, #16]
 8000f26:	6960      	ldr	r0, [r4, #20]
 8000f28:	1a36      	subs	r6, r6, r0
  if (n < s1) {
 8000f2a:	42b5      	cmp	r5, r6
 8000f2c:	d310      	bcc.n	8000f50 <oq_write+0x40>
  else if (n > s1) {
 8000f2e:	42b5      	cmp	r5, r6
 8000f30:	d816      	bhi.n	8000f60 <oq_write+0x50>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000f32:	462a      	mov	r2, r5
 8000f34:	4639      	mov	r1, r7
 8000f36:	f7ff fa07 	bl	8000348 <memcpy>
    oqp->q_wrptr = oqp->q_buffer;
 8000f3a:	68e3      	ldr	r3, [r4, #12]
 8000f3c:	6163      	str	r3, [r4, #20]
  oqp->q_counter -= n;
 8000f3e:	68a3      	ldr	r3, [r4, #8]
 8000f40:	1b5b      	subs	r3, r3, r5
 8000f42:	60a3      	str	r3, [r4, #8]
}
 8000f44:	4628      	mov	r0, r5
 8000f46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  osalDbgCheck(n > 0U);
 8000f4a:	480d      	ldr	r0, [pc, #52]	; (8000f80 <oq_write+0x70>)
 8000f4c:	f7ff fe68 	bl	8000c20 <chSysHalt>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, n);
 8000f50:	462a      	mov	r2, r5
 8000f52:	4639      	mov	r1, r7
 8000f54:	f7ff f9f8 	bl	8000348 <memcpy>
    oqp->q_wrptr += n;
 8000f58:	6963      	ldr	r3, [r4, #20]
 8000f5a:	442b      	add	r3, r5
 8000f5c:	6163      	str	r3, [r4, #20]
 8000f5e:	e7ee      	b.n	8000f3e <oq_write+0x2e>
    memcpy((void *)oqp->q_wrptr, (const void *)bp, s1);
 8000f60:	4632      	mov	r2, r6
 8000f62:	4639      	mov	r1, r7
 8000f64:	f7ff f9f0 	bl	8000348 <memcpy>
    s2 = n - s1;
 8000f68:	eba5 0806 	sub.w	r8, r5, r6
    memcpy((void *)oqp->q_buffer, (const void *)bp, s2);
 8000f6c:	4642      	mov	r2, r8
 8000f6e:	19b9      	adds	r1, r7, r6
 8000f70:	68e0      	ldr	r0, [r4, #12]
 8000f72:	f7ff f9e9 	bl	8000348 <memcpy>
    oqp->q_wrptr = oqp->q_buffer + s2;
 8000f76:	68e2      	ldr	r2, [r4, #12]
 8000f78:	4442      	add	r2, r8
 8000f7a:	6162      	str	r2, [r4, #20]
 8000f7c:	e7df      	b.n	8000f3e <oq_write+0x2e>
 8000f7e:	bf00      	nop
 8000f80:	08002e00 	.word	0x08002e00
	...

08000f90 <iq_read>:
static size_t iq_read(input_queue_t *iqp, uint8_t *bp, size_t n) {
 8000f90:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  osalDbgCheck(n > 0U);
 8000f94:	b1ca      	cbz	r2, 8000fca <iq_read+0x3a>
 8000f96:	4604      	mov	r4, r0
 8000f98:	460f      	mov	r7, r1
 8000f9a:	4615      	mov	r5, r2
  if (n > iqGetFullI(iqp)) {
 8000f9c:	6883      	ldr	r3, [r0, #8]
 8000f9e:	429a      	cmp	r2, r3
 8000fa0:	d900      	bls.n	8000fa4 <iq_read+0x14>
    n = iqGetFullI(iqp);
 8000fa2:	6885      	ldr	r5, [r0, #8]
  s1 = (size_t)(iqp->q_top - iqp->q_rdptr);
 8000fa4:	6926      	ldr	r6, [r4, #16]
 8000fa6:	69a1      	ldr	r1, [r4, #24]
 8000fa8:	1a76      	subs	r6, r6, r1
  if (n < s1) {
 8000faa:	42b5      	cmp	r5, r6
 8000fac:	d310      	bcc.n	8000fd0 <iq_read+0x40>
  else if (n > s1) {
 8000fae:	42b5      	cmp	r5, r6
 8000fb0:	d816      	bhi.n	8000fe0 <iq_read+0x50>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000fb2:	462a      	mov	r2, r5
 8000fb4:	4638      	mov	r0, r7
 8000fb6:	f7ff f9c7 	bl	8000348 <memcpy>
    iqp->q_rdptr = iqp->q_buffer;
 8000fba:	68e3      	ldr	r3, [r4, #12]
 8000fbc:	61a3      	str	r3, [r4, #24]
  iqp->q_counter -= n;
 8000fbe:	68a3      	ldr	r3, [r4, #8]
 8000fc0:	1b5b      	subs	r3, r3, r5
 8000fc2:	60a3      	str	r3, [r4, #8]
}
 8000fc4:	4628      	mov	r0, r5
 8000fc6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  osalDbgCheck(n > 0U);
 8000fca:	480d      	ldr	r0, [pc, #52]	; (8001000 <iq_read+0x70>)
 8000fcc:	f7ff fe28 	bl	8000c20 <chSysHalt>
    memcpy((void *)bp, (void *)iqp->q_rdptr, n);
 8000fd0:	462a      	mov	r2, r5
 8000fd2:	4638      	mov	r0, r7
 8000fd4:	f7ff f9b8 	bl	8000348 <memcpy>
    iqp->q_rdptr += n;
 8000fd8:	69a3      	ldr	r3, [r4, #24]
 8000fda:	442b      	add	r3, r5
 8000fdc:	61a3      	str	r3, [r4, #24]
 8000fde:	e7ee      	b.n	8000fbe <iq_read+0x2e>
    memcpy((void *)bp, (void *)iqp->q_rdptr, s1);
 8000fe0:	4632      	mov	r2, r6
 8000fe2:	4638      	mov	r0, r7
 8000fe4:	f7ff f9b0 	bl	8000348 <memcpy>
    s2 = n - s1;
 8000fe8:	eba5 0806 	sub.w	r8, r5, r6
    memcpy((void *)bp, (void *)iqp->q_buffer, s2);
 8000fec:	4642      	mov	r2, r8
 8000fee:	68e1      	ldr	r1, [r4, #12]
 8000ff0:	19b8      	adds	r0, r7, r6
 8000ff2:	f7ff f9a9 	bl	8000348 <memcpy>
    iqp->q_rdptr = iqp->q_buffer + s2;
 8000ff6:	68e2      	ldr	r2, [r4, #12]
 8000ff8:	4442      	add	r2, r8
 8000ffa:	61a2      	str	r2, [r4, #24]
 8000ffc:	e7df      	b.n	8000fbe <iq_read+0x2e>
 8000ffe:	bf00      	nop
 8001000:	08002df8 	.word	0x08002df8
	...

08001010 <chSysInit>:
void chSysInit(void) {
 8001010:	b538      	push	{r3, r4, r5, lr}
  _scheduler_init();
 8001012:	f000 fd3d 	bl	8001a90 <_scheduler_init>
  _vt_init();
 8001016:	f000 fd4b 	bl	8001ab0 <_vt_init>
  _trace_init();
 800101a:	f000 fdb9 	bl	8001b90 <_trace_init>
  ch.dbg.isr_cnt  = (cnt_t)0;
 800101e:	4c1c      	ldr	r4, [pc, #112]	; (8001090 <chSysInit+0x80>)
 8001020:	2500      	movs	r5, #0
 8001022:	6325      	str	r5, [r4, #48]	; 0x30
  ch.dbg.lock_cnt = (cnt_t)0;
 8001024:	6365      	str	r5, [r4, #52]	; 0x34
  _tm_init();
 8001026:	f001 fc6b 	bl	8002900 <_tm_init>
  _core_init();
 800102a:	f001 fc39 	bl	80028a0 <_core_init>
  _heap_init();
 800102e:	f001 fc27 	bl	8002880 <_heap_init>
  _factory_init();
 8001032:	f001 fbf5 	bl	8002820 <_factory_init>
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8001036:	2280      	movs	r2, #128	; 0x80
 8001038:	4916      	ldr	r1, [pc, #88]	; (8001094 <chSysInit+0x84>)
 800103a:	f504 6004 	add.w	r0, r4, #2112	; 0x840
 800103e:	f000 fcef 	bl	8001a20 <_thread_init>
 8001042:	61a0      	str	r0, [r4, #24]
    currp->wabase = &__main_thread_stack_base__;
 8001044:	4b14      	ldr	r3, [pc, #80]	; (8001098 <chSysInit+0x88>)
 8001046:	61c3      	str	r3, [r0, #28]
  currp->state = CH_STATE_CURRENT;
 8001048:	2301      	movs	r3, #1
 800104a:	f880 3020 	strb.w	r3, [r0, #32]
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 800104e:	4b13      	ldr	r3, [pc, #76]	; (800109c <chSysInit+0x8c>)
 8001050:	68d9      	ldr	r1, [r3, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001052:	f421 61e0 	bic.w	r1, r1, #1792	; 0x700
 8001056:	0409      	lsls	r1, r1, #16
 8001058:	0c09      	lsrs	r1, r1, #16
  reg_value  =  (reg_value                                   |
 800105a:	4a11      	ldr	r2, [pc, #68]	; (80010a0 <chSysInit+0x90>)
 800105c:	430a      	orrs	r2, r1
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
  SCB->AIRCR =  reg_value;
 800105e:	60da      	str	r2, [r3, #12]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001060:	4910      	ldr	r1, [pc, #64]	; (80010a4 <chSysInit+0x94>)
 8001062:	68ca      	ldr	r2, [r1, #12]
 8001064:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001068:	60ca      	str	r2, [r1, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800106a:	490f      	ldr	r1, [pc, #60]	; (80010a8 <chSysInit+0x98>)
 800106c:	680a      	ldr	r2, [r1, #0]
 800106e:	f042 0201 	orr.w	r2, r2, #1
 8001072:	600a      	str	r2, [r1, #0]
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001074:	2210      	movs	r2, #16
 8001076:	77da      	strb	r2, [r3, #31]
 8001078:	2220      	movs	r2, #32
 800107a:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  _dbg_check_enable();
 800107e:	f001 f9c7 	bl	8002410 <_dbg_check_enable>
 8001082:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
 8001086:	b662      	cpsie	i
    (void) chThdCreate(&idle_descriptor);
 8001088:	4808      	ldr	r0, [pc, #32]	; (80010ac <chSysInit+0x9c>)
 800108a:	f001 f9a1 	bl	80023d0 <chThdCreate>
 800108e:	bd38      	pop	{r3, r4, r5, pc}
 8001090:	20000a50 	.word	0x20000a50
 8001094:	08002e2c 	.word	0x08002e2c
 8001098:	20000400 	.word	0x20000400
 800109c:	e000ed00 	.word	0xe000ed00
 80010a0:	05fa0300 	.word	0x05fa0300
 80010a4:	e000edf0 	.word	0xe000edf0
 80010a8:	e0001000 	.word	0xe0001000
 80010ac:	08002f30 	.word	0x08002f30

080010b0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 80010b0:	b508      	push	{r3, lr}

  stm32_gpio_init();
 80010b2:	f7ff f9dd 	bl	8000470 <stm32_gpio_init>
  stm32_clock_init();
 80010b6:	f7ff fb33 	bl	8000720 <stm32_clock_init>
 80010ba:	bd08      	pop	{r3, pc}
 80010bc:	0000      	movs	r0, r0
	...

080010c0 <VectorD8>:
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 80010c0:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80010c2:	4c08      	ldr	r4, [pc, #32]	; (80010e4 <VectorD8+0x24>)
 80010c4:	4620      	mov	r0, r4
 80010c6:	f000 fd43 	bl	8001b50 <_trace_isr_enter>
 80010ca:	f001 f821 	bl	8002110 <_dbg_check_enter_isr>
  serve_interrupt(&SD2);
 80010ce:	4806      	ldr	r0, [pc, #24]	; (80010e8 <VectorD8+0x28>)
 80010d0:	f7ff fe7e 	bl	8000dd0 <serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 80010d4:	f000 fffc 	bl	80020d0 <_dbg_check_leave_isr>
 80010d8:	4620      	mov	r0, r4
 80010da:	f000 fd19 	bl	8001b10 <_trace_isr_leave>
 80010de:	f001 fb5f 	bl	80027a0 <_port_irq_epilogue>
 80010e2:	bd10      	pop	{r4, pc}
 80010e4:	08002d8c 	.word	0x08002d8c
 80010e8:	200009d4 	.word	0x200009d4
 80010ec:	00000000 	.word	0x00000000

080010f0 <VectorAC>:
OSAL_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
 80010f0:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 80010f2:	4c08      	ldr	r4, [pc, #32]	; (8001114 <VectorAC+0x24>)
 80010f4:	4620      	mov	r0, r4
 80010f6:	f000 fd2b 	bl	8001b50 <_trace_isr_enter>
 80010fa:	f001 f809 	bl	8002110 <_dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD1);
 80010fe:	4806      	ldr	r0, [pc, #24]	; (8001118 <VectorAC+0x28>)
 8001100:	f7ff fa5e 	bl	80005c0 <pwm_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 8001104:	f000 ffe4 	bl	80020d0 <_dbg_check_leave_isr>
 8001108:	4620      	mov	r0, r4
 800110a:	f000 fd01 	bl	8001b10 <_trace_isr_leave>
 800110e:	f001 fb47 	bl	80027a0 <_port_irq_epilogue>
 8001112:	bd10      	pop	{r4, pc}
 8001114:	08002d38 	.word	0x08002d38
 8001118:	200009b8 	.word	0x200009b8
 800111c:	00000000 	.word	0x00000000

08001120 <VectorA4>:
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
 8001120:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001122:	4c08      	ldr	r4, [pc, #32]	; (8001144 <VectorA4+0x24>)
 8001124:	4620      	mov	r0, r4
 8001126:	f000 fd13 	bl	8001b50 <_trace_isr_enter>
 800112a:	f000 fff1 	bl	8002110 <_dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD1);
 800112e:	4806      	ldr	r0, [pc, #24]	; (8001148 <VectorA4+0x28>)
 8001130:	f7ff fa46 	bl	80005c0 <pwm_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 8001134:	f000 ffcc 	bl	80020d0 <_dbg_check_leave_isr>
 8001138:	4620      	mov	r0, r4
 800113a:	f000 fce9 	bl	8001b10 <_trace_isr_leave>
 800113e:	f001 fb2f 	bl	80027a0 <_port_irq_epilogue>
 8001142:	bd10      	pop	{r4, pc}
 8001144:	08002d1c 	.word	0x08002d1c
 8001148:	200009b8 	.word	0x200009b8
 800114c:	00000000 	.word	0x00000000

08001150 <VectorB4>:
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8001150:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001152:	4c08      	ldr	r4, [pc, #32]	; (8001174 <VectorB4+0x24>)
 8001154:	4620      	mov	r0, r4
 8001156:	f000 fcfb 	bl	8001b50 <_trace_isr_enter>
 800115a:	f000 ffd9 	bl	8002110 <_dbg_check_enter_isr>
  icu_lld_serve_interrupt(&ICUD3);
 800115e:	4806      	ldr	r0, [pc, #24]	; (8001178 <VectorB4+0x28>)
 8001160:	f7ff fa8e 	bl	8000680 <icu_lld_serve_interrupt>
  OSAL_IRQ_EPILOGUE();
 8001164:	f000 ffb4 	bl	80020d0 <_dbg_check_leave_isr>
 8001168:	4620      	mov	r0, r4
 800116a:	f000 fcd1 	bl	8001b10 <_trace_isr_leave>
 800116e:	f001 fb17 	bl	80027a0 <_port_irq_epilogue>
 8001172:	bd10      	pop	{r4, pc}
 8001174:	08002d5c 	.word	0x08002d5c
 8001178:	20000840 	.word	0x20000840
 800117c:	00000000 	.word	0x00000000

08001180 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8001180:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001184:	f002 0903 	and.w	r9, r2, #3
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8001188:	f3c2 0e80 	ubfx	lr, r2, #2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800118c:	f3c2 07c1 	ubfx	r7, r2, #3, #2
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8001190:	f3c2 1641 	ubfx	r6, r2, #5, #2
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8001194:	f3c2 12c3 	ubfx	r2, r2, #7, #4
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001198:	464d      	mov	r5, r9
  uint32_t bit     = 0;
 800119a:	2400      	movs	r4, #0
 800119c:	e027      	b.n	80011ee <_pal_lld_setgroupmode+0x6e>
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 800119e:	2c07      	cmp	r4, #7
 80011a0:	d80e      	bhi.n	80011c0 <_pal_lld_setgroupmode+0x40>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80011a2:	f8d0 a020 	ldr.w	sl, [r0, #32]
 80011a6:	ea2a 0c0c 	bic.w	ip, sl, ip
 80011aa:	ea48 080c 	orr.w	r8, r8, ip
 80011ae:	f8c0 8020 	str.w	r8, [r0, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 80011b2:	f8d0 c000 	ldr.w	ip, [r0]
 80011b6:	ea03 030c 	and.w	r3, r3, ip
 80011ba:	432b      	orrs	r3, r5
 80011bc:	6003      	str	r3, [r0, #0]
 80011be:	e00e      	b.n	80011de <_pal_lld_setgroupmode+0x5e>
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80011c0:	f8d0 a024 	ldr.w	sl, [r0, #36]	; 0x24
 80011c4:	ea2a 0c0c 	bic.w	ip, sl, ip
 80011c8:	ea48 080c 	orr.w	r8, r8, ip
 80011cc:	f8c0 8024 	str.w	r8, [r0, #36]	; 0x24
 80011d0:	e7ef      	b.n	80011b2 <_pal_lld_setgroupmode+0x32>
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80011d2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 80011d4:	ea23 0c0c 	bic.w	ip, r3, ip
 80011d8:	ea48 030c 	orr.w	r3, r8, ip
 80011dc:	6243      	str	r3, [r0, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 80011de:	0849      	lsrs	r1, r1, #1
 80011e0:	d044      	beq.n	800126c <_pal_lld_setgroupmode+0xec>
      return;
    otyper <<= 1;
 80011e2:	ea4f 0e4e 	mov.w	lr, lr, lsl #1
    ospeedr <<= 2;
 80011e6:	00bf      	lsls	r7, r7, #2
    pupdr <<= 2;
 80011e8:	00b6      	lsls	r6, r6, #2
    moder <<= 2;
 80011ea:	00ad      	lsls	r5, r5, #2
    bit++;
 80011ec:	3401      	adds	r4, #1
    if ((mask & 1) != 0) {
 80011ee:	f011 0f01 	tst.w	r1, #1
 80011f2:	d0f4      	beq.n	80011de <_pal_lld_setgroupmode+0x5e>
      altrmask = altr << ((bit & 7) * 4);
 80011f4:	f004 0c07 	and.w	ip, r4, #7
 80011f8:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 80011fc:	fa02 f80c 	lsl.w	r8, r2, ip
      m1 = 1 << bit;
 8001200:	2301      	movs	r3, #1
 8001202:	fa03 fa04 	lsl.w	sl, r3, r4
      m2 = 3 << (bit * 2);
 8001206:	fa04 f303 	lsl.w	r3, r4, r3
 800120a:	f04f 0b03 	mov.w	fp, #3
 800120e:	fa0b fb03 	lsl.w	fp, fp, r3
      m4 = 15 << ((bit & 7) * 4);
 8001212:	230f      	movs	r3, #15
 8001214:	fa03 fc0c 	lsl.w	ip, r3, ip
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001218:	6843      	ldr	r3, [r0, #4]
 800121a:	ea23 030a 	bic.w	r3, r3, sl
 800121e:	ea4e 0303 	orr.w	r3, lr, r3
 8001222:	6043      	str	r3, [r0, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001224:	f8d0 a008 	ldr.w	sl, [r0, #8]
 8001228:	ea6f 030b 	mvn.w	r3, fp
 800122c:	ea0a 0a03 	and.w	sl, sl, r3
 8001230:	ea47 0a0a 	orr.w	sl, r7, sl
 8001234:	f8c0 a008 	str.w	sl, [r0, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001238:	f8d0 a00c 	ldr.w	sl, [r0, #12]
 800123c:	ea03 0a0a 	and.w	sl, r3, sl
 8001240:	ea46 0a0a 	orr.w	sl, r6, sl
 8001244:	f8c0 a00c 	str.w	sl, [r0, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8001248:	f1b9 0f02 	cmp.w	r9, #2
 800124c:	d0a7      	beq.n	800119e <_pal_lld_setgroupmode+0x1e>
        port->MODER   = (port->MODER & ~m2) | moder;
 800124e:	f8d0 a000 	ldr.w	sl, [r0]
 8001252:	ea03 030a 	and.w	r3, r3, sl
 8001256:	432b      	orrs	r3, r5
 8001258:	6003      	str	r3, [r0, #0]
        if (bit < 8)
 800125a:	2c07      	cmp	r4, #7
 800125c:	d8b9      	bhi.n	80011d2 <_pal_lld_setgroupmode+0x52>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800125e:	6a03      	ldr	r3, [r0, #32]
 8001260:	ea23 0c0c 	bic.w	ip, r3, ip
 8001264:	ea48 030c 	orr.w	r3, r8, ip
 8001268:	6203      	str	r3, [r0, #32]
 800126a:	e7b8      	b.n	80011de <_pal_lld_setgroupmode+0x5e>
 800126c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08001270 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8001270:	b508      	push	{r3, lr}
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8001272:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001276:	68db      	ldr	r3, [r3, #12]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 8001278:	f013 0f02 	tst.w	r3, #2
 800127c:	d003      	beq.n	8001286 <stSetAlarm+0x16>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800127e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001282:	6358      	str	r0, [r3, #52]	; 0x34
 8001284:	bd08      	pop	{r3, pc}
 8001286:	4801      	ldr	r0, [pc, #4]	; (800128c <stSetAlarm+0x1c>)
 8001288:	f7ff fcca 	bl	8000c20 <chSysHalt>
 800128c:	08002d50 	.word	0x08002d50

08001290 <stStopAlarm>:
  STM32_ST_TIM->DIER = 0;
 8001290:	2200      	movs	r2, #0
 8001292:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001296:	60da      	str	r2, [r3, #12]
 8001298:	4770      	bx	lr
 800129a:	bf00      	nop
 800129c:	0000      	movs	r0, r0
	...

080012a0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80012a0:	b570      	push	{r4, r5, r6, lr}

  chDbgCheckClassI();
 80012a2:	f000 fccd 	bl	8001c40 <chDbgCheckClassI>
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();
 80012a6:	f000 fccb 	bl	8001c40 <chDbgCheckClassI>
  virtual_timer_t *vtp;
  systime_t now;
  sysinterval_t delta, nowdelta;

  /* Looping through timers.*/
  vtp = ch.vtlist.next;
 80012aa:	4b2b      	ldr	r3, [pc, #172]	; (8001358 <chSysTimerHandlerI+0xb8>)
 80012ac:	69dc      	ldr	r4, [r3, #28]
  return (systime_t)STM32_ST_TIM->CNT;
 80012ae:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80012b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  while (true) {

    /* Getting the system time as reference.*/
    now = chVTGetSystemTimeX();
    nowdelta = chTimeDiffX(ch.vtlist.lasttime, now);
 80012b4:	4a28      	ldr	r2, [pc, #160]	; (8001358 <chSysTimerHandlerI+0xb8>)
 80012b6:	6a95      	ldr	r5, [r2, #40]	; 0x28
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 80012b8:	1b5d      	subs	r5, r3, r5

    /* The list scan is limited by the timers header having
       "ch.vtlist.vt_delta == (sysinterval_t)-1" which is
       greater than all deltas.*/
    if (nowdelta < vtp->delta) {
 80012ba:	68a2      	ldr	r2, [r4, #8]
 80012bc:	4295      	cmp	r5, r2
 80012be:	d327      	bcc.n	8001310 <chSysTimerHandlerI+0x70>
    /* Consuming all timers between "vtp->lasttime" and now.*/
    do {
      vtfunc_t fn;

      /* The "last time" becomes this timer's expiration time.*/
      ch.vtlist.lasttime += vtp->delta;
 80012c0:	68a1      	ldr	r1, [r4, #8]
 80012c2:	4b25      	ldr	r3, [pc, #148]	; (8001358 <chSysTimerHandlerI+0xb8>)
 80012c4:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 80012c6:	440a      	add	r2, r1
 80012c8:	629a      	str	r2, [r3, #40]	; 0x28
      nowdelta -= vtp->delta;
 80012ca:	68a2      	ldr	r2, [r4, #8]
 80012cc:	1aad      	subs	r5, r5, r2

      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 80012ce:	6821      	ldr	r1, [r4, #0]
 80012d0:	f103 021c 	add.w	r2, r3, #28
 80012d4:	604a      	str	r2, [r1, #4]
      ch.vtlist.next = vtp->next;
 80012d6:	6821      	ldr	r1, [r4, #0]
 80012d8:	61d9      	str	r1, [r3, #28]
      fn = vtp->func;
 80012da:	68e6      	ldr	r6, [r4, #12]
      vtp->func = NULL;
 80012dc:	2100      	movs	r1, #0
 80012de:	60e1      	str	r1, [r4, #12]

      /* if the list becomes empty then the timer is stopped.*/
      if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 80012e0:	69db      	ldr	r3, [r3, #28]
 80012e2:	4293      	cmp	r3, r2
 80012e4:	d011      	beq.n	800130a <chSysTimerHandlerI+0x6a>
  _dbg_check_unlock_from_isr();
 80012e6:	f000 ff33 	bl	8002150 <_dbg_check_unlock_from_isr>
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80012ea:	2300      	movs	r3, #0
 80012ec:	f383 8811 	msr	BASEPRI, r3
        port_timer_stop_alarm();
      }

      /* The callback is invoked outside the kernel critical zone.*/
      chSysUnlockFromISR();
      fn(vtp->par);
 80012f0:	6920      	ldr	r0, [r4, #16]
 80012f2:	47b0      	blx	r6
 80012f4:	2320      	movs	r3, #32
 80012f6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80012fa:	f000 ff41 	bl	8002180 <_dbg_check_lock_from_isr>
      chSysLockFromISR();

      /* Next element in the list.*/
      vtp = ch.vtlist.next;
 80012fe:	4b16      	ldr	r3, [pc, #88]	; (8001358 <chSysTimerHandlerI+0xb8>)
 8001300:	69dc      	ldr	r4, [r3, #28]
    }
    while (vtp->delta <= nowdelta);
 8001302:	68a3      	ldr	r3, [r4, #8]
 8001304:	429d      	cmp	r5, r3
 8001306:	d2db      	bcs.n	80012c0 <chSysTimerHandlerI+0x20>
 8001308:	e7d1      	b.n	80012ae <chSysTimerHandlerI+0xe>
 *
 * @notapi
 */
static inline void port_timer_stop_alarm(void) {

  stStopAlarm();
 800130a:	f7ff ffc1 	bl	8001290 <stStopAlarm>
 800130e:	e7ea      	b.n	80012e6 <chSysTimerHandlerI+0x46>
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8001310:	4911      	ldr	r1, [pc, #68]	; (8001358 <chSysTimerHandlerI+0xb8>)
 8001312:	f851 2f1c 	ldr.w	r2, [r1, #28]!
 8001316:	428a      	cmp	r2, r1
 8001318:	d017      	beq.n	800134a <chSysTimerHandlerI+0xaa>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  ch.vtlist.lasttime += nowdelta;
 800131a:	480f      	ldr	r0, [pc, #60]	; (8001358 <chSysTimerHandlerI+0xb8>)
 800131c:	6283      	str	r3, [r0, #40]	; 0x28
  ch.vtlist.next->delta -= nowdelta;
 800131e:	6891      	ldr	r1, [r2, #8]
 8001320:	1b49      	subs	r1, r1, r5
 8001322:	6091      	str	r1, [r2, #8]

  /* Recalculating the next alarm time.*/
  delta = chTimeDiffX(now, chTimeAddX(ch.vtlist.lasttime, vtp->delta));
 8001324:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8001326:	68a4      	ldr	r4, [r4, #8]
  return systime + (systime_t)interval;
 8001328:	4414      	add	r4, r2
  return (sysinterval_t)((systime_t)(end - start));
 800132a:	1ae4      	subs	r4, r4, r3
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 800132c:	2c01      	cmp	r4, #1
 800132e:	d90d      	bls.n	800134c <chSysTimerHandlerI+0xac>
  return systime + (systime_t)interval;
 8001330:	441c      	add	r4, r3
 *
 * @notapi
 */
static inline void port_timer_set_alarm(systime_t time) {

  stSetAlarm(time);
 8001332:	4620      	mov	r0, r4
 8001334:	f7ff ff9c 	bl	8001270 <stSetAlarm>
    delta = (sysinterval_t)TIME_MAX_SYSTIME;
  }
#endif
  port_timer_set_alarm(chTimeAddX(now, delta));

  chDbgAssert(chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX()) <=
 8001338:	4b07      	ldr	r3, [pc, #28]	; (8001358 <chSysTimerHandlerI+0xb8>)
 800133a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800133c:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001340:	6a52      	ldr	r2, [r2, #36]	; 0x24
  return (sysinterval_t)((systime_t)(end - start));
 8001342:	1ad2      	subs	r2, r2, r3
 8001344:	1ae3      	subs	r3, r4, r3
 8001346:	429a      	cmp	r2, r3
 8001348:	d802      	bhi.n	8001350 <chSysTimerHandlerI+0xb0>
 800134a:	bd70      	pop	{r4, r5, r6, pc}
    delta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 800134c:	2402      	movs	r4, #2
 800134e:	e7ef      	b.n	8001330 <chSysTimerHandlerI+0x90>
  chDbgAssert(chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX()) <=
 8001350:	4802      	ldr	r0, [pc, #8]	; (800135c <chSysTimerHandlerI+0xbc>)
 8001352:	f7ff fc65 	bl	8000c20 <chSysHalt>
 8001356:	bf00      	nop
 8001358:	20000a50 	.word	0x20000a50
 800135c:	08002cf8 	.word	0x08002cf8

08001360 <VectorB0>:
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8001360:	b510      	push	{r4, lr}
  OSAL_IRQ_PROLOGUE();
 8001362:	4811      	ldr	r0, [pc, #68]	; (80013a8 <VectorB0+0x48>)
 8001364:	f000 fbf4 	bl	8001b50 <_trace_isr_enter>
 8001368:	f000 fed2 	bl	8002110 <_dbg_check_enter_isr>
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 800136c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001370:	691b      	ldr	r3, [r3, #16]
 8001372:	f013 0f02 	tst.w	r3, #2
 8001376:	d107      	bne.n	8001388 <VectorB0+0x28>
  OSAL_IRQ_EPILOGUE();
 8001378:	f000 feaa 	bl	80020d0 <_dbg_check_leave_isr>
 800137c:	480a      	ldr	r0, [pc, #40]	; (80013a8 <VectorB0+0x48>)
 800137e:	f000 fbc7 	bl	8001b10 <_trace_isr_leave>
 8001382:	f001 fa0d 	bl	80027a0 <_port_irq_epilogue>
 8001386:	bd10      	pop	{r4, pc}
    STM32_ST_TIM->SR = 0U;
 8001388:	2400      	movs	r4, #0
 800138a:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800138e:	611c      	str	r4, [r3, #16]
 8001390:	2320      	movs	r3, #32
 8001392:	f383 8811 	msr	BASEPRI, r3
 8001396:	f000 fef3 	bl	8002180 <_dbg_check_lock_from_isr>
  chSysTimerHandlerI();
 800139a:	f7ff ff81 	bl	80012a0 <chSysTimerHandlerI>
  _dbg_check_unlock_from_isr();
 800139e:	f000 fed7 	bl	8002150 <_dbg_check_unlock_from_isr>
 80013a2:	f384 8811 	msr	BASEPRI, r4
 80013a6:	e7e7      	b.n	8001378 <VectorB0+0x18>
 80013a8:	08002d10 	.word	0x08002d10
 80013ac:	00000000 	.word	0x00000000

080013b0 <stStartAlarm>:
void stStartAlarm(systime_t abstime) {
 80013b0:	b508      	push	{r3, lr}
  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 80013b2:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80013b6:	68db      	ldr	r3, [r3, #12]
  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80013b8:	f013 0f02 	tst.w	r3, #2
 80013bc:	d107      	bne.n	80013ce <stStartAlarm+0x1e>
  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80013be:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80013c2:	6358      	str	r0, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80013c4:	2200      	movs	r2, #0
 80013c6:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80013c8:	2202      	movs	r2, #2
 80013ca:	60da      	str	r2, [r3, #12]
 80013cc:	bd08      	pop	{r3, pc}
 80013ce:	4801      	ldr	r0, [pc, #4]	; (80013d4 <stStartAlarm+0x24>)
 80013d0:	f7ff fc26 	bl	8000c20 <chSysHalt>
 80013d4:	08002d28 	.word	0x08002d28
	...

080013e0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 80013e0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();

  /* Platform low level initializations.*/
  hal_lld_init();
 80013e2:	f7ff fadd 	bl	80009a0 <hal_lld_init>
#endif
#if (HAL_USE_I2S == TRUE) || defined(__DOXYGEN__)
  i2sInit();
#endif
#if (HAL_USE_ICU == TRUE) || defined(__DOXYGEN__)
  icuInit();
 80013e6:	f7ff fb43 	bl	8000a70 <icuInit>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 80013ea:	f7ff fb21 	bl	8000a30 <pwmInit>
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 80013ee:	f7ff fb97 	bl	8000b20 <sdInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 80013f2:	f7ff fb9d 	bl	8000b30 <stInit>
 80013f6:	bd08      	pop	{r3, pc}
	...

08001400 <__init_ram_areas>:
/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8001400:	4a0b      	ldr	r2, [pc, #44]	; (8001430 <__init_ram_areas+0x30>)
 8001402:	e011      	b.n	8001428 <__init_ram_areas+0x28>
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
      *p = *tp;
 8001404:	f850 1b04 	ldr.w	r1, [r0], #4
 8001408:	f843 1b04 	str.w	r1, [r3], #4
    while (p < rap->clear_area) {
 800140c:	6891      	ldr	r1, [r2, #8]
 800140e:	428b      	cmp	r3, r1
 8001410:	d3f8      	bcc.n	8001404 <__init_ram_areas+0x4>
 8001412:	e002      	b.n	800141a <__init_ram_areas+0x1a>
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001414:	2100      	movs	r1, #0
 8001416:	f843 1b04 	str.w	r1, [r3], #4
    while (p < rap->no_init_area) {
 800141a:	68d1      	ldr	r1, [r2, #12]
 800141c:	428b      	cmp	r3, r1
 800141e:	d3f9      	bcc.n	8001414 <__init_ram_areas+0x14>
      p++;
    }
    rap++;
 8001420:	3210      	adds	r2, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8001422:	4b04      	ldr	r3, [pc, #16]	; (8001434 <__init_ram_areas+0x34>)
 8001424:	429a      	cmp	r2, r3
 8001426:	d202      	bcs.n	800142e <__init_ram_areas+0x2e>
    uint32_t *tp = rap->init_text_area;
 8001428:	6810      	ldr	r0, [r2, #0]
    uint32_t *p = rap->init_area;
 800142a:	6853      	ldr	r3, [r2, #4]
 800142c:	e7ee      	b.n	800140c <__init_ram_areas+0xc>
#endif
}
 800142e:	4770      	bx	lr
 8001430:	08002f48 	.word	0x08002f48
 8001434:	08002fc8 	.word	0x08002fc8
	...

08001440 <__default_exit>:
void __default_exit(void) {
 8001440:	e7fe      	b.n	8001440 <__default_exit>
 8001442:	bf00      	nop
	...

08001450 <__late_init>:
void __late_init(void) {}
 8001450:	4770      	bx	lr
 8001452:	bf00      	nop
	...

08001460 <__core_init>:
void __core_init(void) {
 8001460:	4770      	bx	lr
 8001462:	bf00      	nop
	...

08001470 <sdStart>:
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8001470:	b538      	push	{r3, r4, r5, lr}
  osalDbgCheck(sdp != NULL);
 8001472:	b170      	cbz	r0, 8001492 <sdStart+0x22>
 8001474:	460d      	mov	r5, r1
 8001476:	4604      	mov	r4, r0
 8001478:	2320      	movs	r3, #32
 800147a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800147e:	f000 feff 	bl	8002280 <_dbg_check_lock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
 8001482:	7a23      	ldrb	r3, [r4, #8]
 8001484:	3b01      	subs	r3, #1
 8001486:	b2db      	uxtb	r3, r3
 8001488:	2b01      	cmp	r3, #1
 800148a:	d905      	bls.n	8001498 <sdStart+0x28>
 800148c:	480e      	ldr	r0, [pc, #56]	; (80014c8 <sdStart+0x58>)
 800148e:	f7ff fbc7 	bl	8000c20 <chSysHalt>
  osalDbgCheck(sdp != NULL);
 8001492:	480d      	ldr	r0, [pc, #52]	; (80014c8 <sdStart+0x58>)
 8001494:	f7ff fbc4 	bl	8000c20 <chSysHalt>
  sd_lld_start(sdp, config);
 8001498:	4629      	mov	r1, r5
 800149a:	4620      	mov	r0, r4
 800149c:	f7ff fa08 	bl	80008b0 <sd_lld_start>
  sdp->state = SD_READY;
 80014a0:	2302      	movs	r3, #2
 80014a2:	7223      	strb	r3, [r4, #8]
  _dbg_check_unlock();
 80014a4:	f000 febc 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80014a8:	4b08      	ldr	r3, [pc, #32]	; (80014cc <sdStart+0x5c>)
 80014aa:	681a      	ldr	r2, [r3, #0]
 80014ac:	429a      	cmp	r2, r3
 80014ae:	d004      	beq.n	80014ba <sdStart+0x4a>
 80014b0:	699b      	ldr	r3, [r3, #24]
 80014b2:	6899      	ldr	r1, [r3, #8]
 80014b4:	6893      	ldr	r3, [r2, #8]
 80014b6:	4299      	cmp	r1, r3
 80014b8:	d303      	bcc.n	80014c2 <sdStart+0x52>
 80014ba:	2300      	movs	r3, #0
 80014bc:	f383 8811 	msr	BASEPRI, r3
 80014c0:	bd38      	pop	{r3, r4, r5, pc}
 80014c2:	4803      	ldr	r0, [pc, #12]	; (80014d0 <sdStart+0x60>)
 80014c4:	f7ff fbac 	bl	8000c20 <chSysHalt>
 80014c8:	08002de0 	.word	0x08002de0
 80014cc:	20000a50 	.word	0x20000a50
 80014d0:	08002cec 	.word	0x08002cec
	...

080014e0 <chSysUnlock.lto_priv.10>:
static inline void chSysUnlock(void) {
 80014e0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 80014e2:	f000 fe9d 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80014e6:	4b08      	ldr	r3, [pc, #32]	; (8001508 <chSysUnlock.lto_priv.10+0x28>)
 80014e8:	681a      	ldr	r2, [r3, #0]
 80014ea:	429a      	cmp	r2, r3
 80014ec:	d004      	beq.n	80014f8 <chSysUnlock.lto_priv.10+0x18>
 80014ee:	699b      	ldr	r3, [r3, #24]
 80014f0:	6899      	ldr	r1, [r3, #8]
 80014f2:	6893      	ldr	r3, [r2, #8]
 80014f4:	4299      	cmp	r1, r3
 80014f6:	d303      	bcc.n	8001500 <chSysUnlock.lto_priv.10+0x20>
 80014f8:	2300      	movs	r3, #0
 80014fa:	f383 8811 	msr	BASEPRI, r3
 80014fe:	bd08      	pop	{r3, pc}
 8001500:	4802      	ldr	r0, [pc, #8]	; (800150c <chSysUnlock.lto_priv.10+0x2c>)
 8001502:	f7ff fb8d 	bl	8000c20 <chSysHalt>
 8001506:	bf00      	nop
 8001508:	20000a50 	.word	0x20000a50
 800150c:	08002ce0 	.word	0x08002ce0

08001510 <pwmEnableChannelNotification>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] channel   PWM channel identifier (0...channels-1)
 *
 * @api
 */
void pwmEnableChannelNotification(PWMDriver *pwmp, pwmchannel_t channel) {
 8001510:	b538      	push	{r3, r4, r5, lr}

  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 8001512:	b120      	cbz	r0, 800151e <pwmEnableChannelNotification+0xe>
 8001514:	460d      	mov	r5, r1
 8001516:	4604      	mov	r4, r0
 8001518:	7c03      	ldrb	r3, [r0, #16]
 800151a:	428b      	cmp	r3, r1
 800151c:	d802      	bhi.n	8001524 <pwmEnableChannelNotification+0x14>
 800151e:	4813      	ldr	r0, [pc, #76]	; (800156c <pwmEnableChannelNotification+0x5c>)
 8001520:	f7ff fb7e 	bl	8000c20 <chSysHalt>
 8001524:	2320      	movs	r3, #32
 8001526:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800152a:	f000 fea9 	bl	8002280 <_dbg_check_lock>

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 800152e:	7823      	ldrb	r3, [r4, #0]
 8001530:	2b02      	cmp	r3, #2
 8001532:	d002      	beq.n	800153a <pwmEnableChannelNotification+0x2a>
 8001534:	480d      	ldr	r0, [pc, #52]	; (800156c <pwmEnableChannelNotification+0x5c>)
 8001536:	f7ff fb73 	bl	8000c20 <chSysHalt>
  osalDbgAssert((pwmp->enabled & ((pwmchnmsk_t)1U << (pwmchnmsk_t)channel)) != 0U,
 800153a:	68e3      	ldr	r3, [r4, #12]
 800153c:	40eb      	lsrs	r3, r5
 800153e:	f013 0f01 	tst.w	r3, #1
 8001542:	d00c      	beq.n	800155e <pwmEnableChannelNotification+0x4e>
                "channel not enabled");
  osalDbgAssert(pwmp->config->channels[channel].callback != NULL,
 8001544:	6863      	ldr	r3, [r4, #4]
 8001546:	1c6a      	adds	r2, r5, #1
 8001548:	eb03 03c2 	add.w	r3, r3, r2, lsl #3
 800154c:	689b      	ldr	r3, [r3, #8]
 800154e:	b14b      	cbz	r3, 8001564 <pwmEnableChannelNotification+0x54>
                "undefined channel callback");

  pwmEnableChannelNotificationI(pwmp, channel);
 8001550:	4629      	mov	r1, r5
 8001552:	4620      	mov	r0, r4
 8001554:	f7ff f86c 	bl	8000630 <pwm_lld_enable_channel_notification>
  chSysUnlock();
 8001558:	f7ff ffc2 	bl	80014e0 <chSysUnlock.lto_priv.10>
 800155c:	bd38      	pop	{r3, r4, r5, pc}
  osalDbgAssert((pwmp->enabled & ((pwmchnmsk_t)1U << (pwmchnmsk_t)channel)) != 0U,
 800155e:	4803      	ldr	r0, [pc, #12]	; (800156c <pwmEnableChannelNotification+0x5c>)
 8001560:	f7ff fb5e 	bl	8000c20 <chSysHalt>
  osalDbgAssert(pwmp->config->channels[channel].callback != NULL,
 8001564:	4801      	ldr	r0, [pc, #4]	; (800156c <pwmEnableChannelNotification+0x5c>)
 8001566:	f7ff fb5b 	bl	8000c20 <chSysHalt>
 800156a:	bf00      	nop
 800156c:	08002db8 	.word	0x08002db8

08001570 <pwmEnablePeriodicNotification>:
void pwmEnablePeriodicNotification(PWMDriver *pwmp) {
 8001570:	b510      	push	{r4, lr}
  osalDbgCheck(pwmp != NULL);
 8001572:	b158      	cbz	r0, 800158c <pwmEnablePeriodicNotification+0x1c>
 8001574:	4604      	mov	r4, r0
 8001576:	2320      	movs	r3, #32
 8001578:	f383 8811 	msr	BASEPRI, r3
 800157c:	f000 fe80 	bl	8002280 <_dbg_check_lock>
  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8001580:	7823      	ldrb	r3, [r4, #0]
 8001582:	2b02      	cmp	r3, #2
 8001584:	d005      	beq.n	8001592 <pwmEnablePeriodicNotification+0x22>
 8001586:	4809      	ldr	r0, [pc, #36]	; (80015ac <pwmEnablePeriodicNotification+0x3c>)
 8001588:	f7ff fb4a 	bl	8000c20 <chSysHalt>
  osalDbgCheck(pwmp != NULL);
 800158c:	4807      	ldr	r0, [pc, #28]	; (80015ac <pwmEnablePeriodicNotification+0x3c>)
 800158e:	f7ff fb47 	bl	8000c20 <chSysHalt>
  osalDbgAssert(pwmp->config->callback != NULL, "undefined periodic callback");
 8001592:	6863      	ldr	r3, [r4, #4]
 8001594:	689b      	ldr	r3, [r3, #8]
 8001596:	b12b      	cbz	r3, 80015a4 <pwmEnablePeriodicNotification+0x34>
  pwmEnablePeriodicNotificationI(pwmp);
 8001598:	4620      	mov	r0, r4
 800159a:	f7ff f859 	bl	8000650 <pwm_lld_enable_periodic_notification>
 800159e:	f7ff ff9f 	bl	80014e0 <chSysUnlock.lto_priv.10>
 80015a2:	bd10      	pop	{r4, pc}
  osalDbgAssert(pwmp->config->callback != NULL, "undefined periodic callback");
 80015a4:	4801      	ldr	r0, [pc, #4]	; (80015ac <pwmEnablePeriodicNotification+0x3c>)
 80015a6:	f7ff fb3b 	bl	8000c20 <chSysHalt>
 80015aa:	bf00      	nop
 80015ac:	08002d98 	.word	0x08002d98

080015b0 <pwmEnableChannel>:
                      pwmcnt_t width) {
 80015b0:	b570      	push	{r4, r5, r6, lr}
  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 80015b2:	b128      	cbz	r0, 80015c0 <pwmEnableChannel+0x10>
 80015b4:	460d      	mov	r5, r1
 80015b6:	4616      	mov	r6, r2
 80015b8:	4604      	mov	r4, r0
 80015ba:	7c03      	ldrb	r3, [r0, #16]
 80015bc:	428b      	cmp	r3, r1
 80015be:	d802      	bhi.n	80015c6 <pwmEnableChannel+0x16>
 80015c0:	480d      	ldr	r0, [pc, #52]	; (80015f8 <pwmEnableChannel+0x48>)
 80015c2:	f7ff fb2d 	bl	8000c20 <chSysHalt>
 80015c6:	2320      	movs	r3, #32
 80015c8:	f383 8811 	msr	BASEPRI, r3
 80015cc:	f000 fe58 	bl	8002280 <_dbg_check_lock>
  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 80015d0:	7823      	ldrb	r3, [r4, #0]
 80015d2:	2b02      	cmp	r3, #2
 80015d4:	d002      	beq.n	80015dc <pwmEnableChannel+0x2c>
 80015d6:	4808      	ldr	r0, [pc, #32]	; (80015f8 <pwmEnableChannel+0x48>)
 80015d8:	f7ff fb22 	bl	8000c20 <chSysHalt>
  pwmEnableChannelI(pwmp, channel, width);
 80015dc:	2301      	movs	r3, #1
 80015de:	fa03 f205 	lsl.w	r2, r3, r5
 80015e2:	68e3      	ldr	r3, [r4, #12]
 80015e4:	4313      	orrs	r3, r2
 80015e6:	60e3      	str	r3, [r4, #12]
 80015e8:	4632      	mov	r2, r6
 80015ea:	4629      	mov	r1, r5
 80015ec:	4620      	mov	r0, r4
 80015ee:	f7ff f83f 	bl	8000670 <pwm_lld_enable_channel>
 80015f2:	f7ff ff75 	bl	80014e0 <chSysUnlock.lto_priv.10>
 80015f6:	bd70      	pop	{r4, r5, r6, pc}
 80015f8:	08002d78 	.word	0x08002d78
 80015fc:	00000000 	.word	0x00000000

08001600 <pwmStart>:
void pwmStart(PWMDriver *pwmp, const PWMConfig *config) {
 8001600:	b538      	push	{r3, r4, r5, lr}
  osalDbgCheck((pwmp != NULL) && (config != NULL));
 8001602:	b178      	cbz	r0, 8001624 <pwmStart+0x24>
 8001604:	460d      	mov	r5, r1
 8001606:	4604      	mov	r4, r0
 8001608:	b161      	cbz	r1, 8001624 <pwmStart+0x24>
 800160a:	2320      	movs	r3, #32
 800160c:	f383 8811 	msr	BASEPRI, r3
 8001610:	f000 fe36 	bl	8002280 <_dbg_check_lock>
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
 8001614:	7823      	ldrb	r3, [r4, #0]
 8001616:	3b01      	subs	r3, #1
 8001618:	b2db      	uxtb	r3, r3
 800161a:	2b01      	cmp	r3, #1
 800161c:	d905      	bls.n	800162a <pwmStart+0x2a>
 800161e:	4809      	ldr	r0, [pc, #36]	; (8001644 <pwmStart+0x44>)
 8001620:	f7ff fafe 	bl	8000c20 <chSysHalt>
  osalDbgCheck((pwmp != NULL) && (config != NULL));
 8001624:	4807      	ldr	r0, [pc, #28]	; (8001644 <pwmStart+0x44>)
 8001626:	f7ff fafb 	bl	8000c20 <chSysHalt>
  pwmp->config = config;
 800162a:	6065      	str	r5, [r4, #4]
  pwmp->period = config->period;
 800162c:	686b      	ldr	r3, [r5, #4]
 800162e:	60a3      	str	r3, [r4, #8]
  pwm_lld_start(pwmp);
 8001630:	4620      	mov	r0, r4
 8001632:	f7ff fb05 	bl	8000c40 <pwm_lld_start>
  pwmp->enabled = 0;
 8001636:	2300      	movs	r3, #0
 8001638:	60e3      	str	r3, [r4, #12]
  pwmp->state = PWM_READY;
 800163a:	2302      	movs	r3, #2
 800163c:	7023      	strb	r3, [r4, #0]
 800163e:	f7ff ff4f 	bl	80014e0 <chSysUnlock.lto_priv.10>
 8001642:	bd38      	pop	{r3, r4, r5, pc}
 8001644:	08002d44 	.word	0x08002d44
	...

08001650 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, sysinterval_t timeout) {
 8001650:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  qnotify_t nfy = oqp->q_notify;
 8001654:	f8d0 801c 	ldr.w	r8, [r0, #28]
  size_t max = n;

  osalDbgCheck(n > 0U);
 8001658:	b152      	cbz	r2, 8001670 <oqWriteTimeout+0x20>
 800165a:	4605      	mov	r5, r0
 800165c:	460e      	mov	r6, r1
 800165e:	469a      	mov	sl, r3
 8001660:	4691      	mov	r9, r2
 8001662:	2320      	movs	r3, #32
 8001664:	f383 8811 	msr	BASEPRI, r3
 8001668:	f000 fe0a 	bl	8002280 <_dbg_check_lock>
 800166c:	464c      	mov	r4, r9
 800166e:	e023      	b.n	80016b8 <oqWriteTimeout+0x68>
 8001670:	4821      	ldr	r0, [pc, #132]	; (80016f8 <oqWriteTimeout+0xa8>)
 8001672:	f7ff fad5 	bl	8000c20 <chSysHalt>
  return chThdEnqueueTimeoutS(tqp, timeout);
 8001676:	4651      	mov	r1, sl
 8001678:	4628      	mov	r0, r5
 800167a:	f001 f979 	bl	8002970 <chThdEnqueueTimeoutS>
    done = oq_write(oqp, bp, n);
    if (done == (size_t)0) {
      msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 800167e:	b1d8      	cbz	r0, 80016b8 <oqWriteTimeout+0x68>
  _dbg_check_unlock();
 8001680:	f000 fdce 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001684:	4b1d      	ldr	r3, [pc, #116]	; (80016fc <oqWriteTimeout+0xac>)
 8001686:	681a      	ldr	r2, [r3, #0]
 8001688:	429a      	cmp	r2, r3
 800168a:	d004      	beq.n	8001696 <oqWriteTimeout+0x46>
 800168c:	699b      	ldr	r3, [r3, #24]
 800168e:	6899      	ldr	r1, [r3, #8]
 8001690:	6893      	ldr	r3, [r2, #8]
 8001692:	4299      	cmp	r1, r3
 8001694:	d32d      	bcc.n	80016f2 <oqWriteTimeout+0xa2>
 8001696:	2300      	movs	r3, #0
 8001698:	f383 8811 	msr	BASEPRI, r3
    }
  }

  osalSysUnlock();
  return max - n;
}
 800169c:	eba9 0004 	sub.w	r0, r9, r4
 80016a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80016a4:	2300      	movs	r3, #0
 80016a6:	f383 8811 	msr	BASEPRI, r3
      n  -= done;
 80016aa:	1be4      	subs	r4, r4, r7
      bp += done;
 80016ac:	443e      	add	r6, r7
 80016ae:	2320      	movs	r3, #32
 80016b0:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80016b4:	f000 fde4 	bl	8002280 <_dbg_check_lock>
  while (n > 0U) {
 80016b8:	2c00      	cmp	r4, #0
 80016ba:	d0e1      	beq.n	8001680 <oqWriteTimeout+0x30>
    done = oq_write(oqp, bp, n);
 80016bc:	4622      	mov	r2, r4
 80016be:	4631      	mov	r1, r6
 80016c0:	4628      	mov	r0, r5
 80016c2:	f7ff fc25 	bl	8000f10 <oq_write>
    if (done == (size_t)0) {
 80016c6:	4607      	mov	r7, r0
 80016c8:	2800      	cmp	r0, #0
 80016ca:	d0d4      	beq.n	8001676 <oqWriteTimeout+0x26>
      if (nfy != NULL) {
 80016cc:	f1b8 0f00 	cmp.w	r8, #0
 80016d0:	d001      	beq.n	80016d6 <oqWriteTimeout+0x86>
        nfy(oqp);
 80016d2:	4628      	mov	r0, r5
 80016d4:	47c0      	blx	r8
  _dbg_check_unlock();
 80016d6:	f000 fda3 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80016da:	4b08      	ldr	r3, [pc, #32]	; (80016fc <oqWriteTimeout+0xac>)
 80016dc:	681a      	ldr	r2, [r3, #0]
 80016de:	429a      	cmp	r2, r3
 80016e0:	d0e0      	beq.n	80016a4 <oqWriteTimeout+0x54>
 80016e2:	699b      	ldr	r3, [r3, #24]
 80016e4:	6899      	ldr	r1, [r3, #8]
 80016e6:	6893      	ldr	r3, [r2, #8]
 80016e8:	4299      	cmp	r1, r3
 80016ea:	d2db      	bcs.n	80016a4 <oqWriteTimeout+0x54>
 80016ec:	4804      	ldr	r0, [pc, #16]	; (8001700 <oqWriteTimeout+0xb0>)
 80016ee:	f7ff fa97 	bl	8000c20 <chSysHalt>
 80016f2:	4803      	ldr	r0, [pc, #12]	; (8001700 <oqWriteTimeout+0xb0>)
 80016f4:	f7ff fa94 	bl	8000c20 <chSysHalt>
 80016f8:	08002e1c 	.word	0x08002e1c
 80016fc:	20000a50 	.word	0x20000a50
 8001700:	08002d04 	.word	0x08002d04
	...

08001710 <_writet>:
                      sysinterval_t timeout) {
 8001710:	b508      	push	{r3, lr}
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8001712:	3030      	adds	r0, #48	; 0x30
 8001714:	f7ff ff9c 	bl	8001650 <oqWriteTimeout>
}
 8001718:	bd08      	pop	{r3, pc}
 800171a:	bf00      	nop
 800171c:	0000      	movs	r0, r0
	...

08001720 <_write>:
static size_t _write(void *ip, const uint8_t *bp, size_t n) {
 8001720:	b508      	push	{r3, lr}
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8001722:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001726:	3030      	adds	r0, #48	; 0x30
 8001728:	f7ff ff92 	bl	8001650 <oqWriteTimeout>
}
 800172c:	bd08      	pop	{r3, pc}
 800172e:	bf00      	nop

08001730 <oqPutTimeout>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, sysinterval_t timeout) {
 8001730:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001732:	4604      	mov	r4, r0
 8001734:	460f      	mov	r7, r1
 8001736:	4616      	mov	r6, r2
 8001738:	2320      	movs	r3, #32
 800173a:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800173e:	f000 fd9f 	bl	8002280 <_dbg_check_lock>
  while (oqIsFullI(oqp)) {
 8001742:	68a3      	ldr	r3, [r4, #8]
 8001744:	b9bb      	cbnz	r3, 8001776 <oqPutTimeout+0x46>
 8001746:	4631      	mov	r1, r6
 8001748:	4620      	mov	r0, r4
 800174a:	f001 f911 	bl	8002970 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 800174e:	1e05      	subs	r5, r0, #0
 8001750:	daf7      	bge.n	8001742 <oqPutTimeout+0x12>
  _dbg_check_unlock();
 8001752:	f000 fd65 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001756:	4b1a      	ldr	r3, [pc, #104]	; (80017c0 <oqPutTimeout+0x90>)
 8001758:	681a      	ldr	r2, [r3, #0]
 800175a:	429a      	cmp	r2, r3
 800175c:	d004      	beq.n	8001768 <oqPutTimeout+0x38>
 800175e:	699b      	ldr	r3, [r3, #24]
 8001760:	6899      	ldr	r1, [r3, #8]
 8001762:	6893      	ldr	r3, [r2, #8]
 8001764:	4299      	cmp	r1, r3
 8001766:	d303      	bcc.n	8001770 <oqPutTimeout+0x40>
 8001768:	2300      	movs	r3, #0
 800176a:	f383 8811 	msr	BASEPRI, r3
 800176e:	e021      	b.n	80017b4 <oqPutTimeout+0x84>
 8001770:	4814      	ldr	r0, [pc, #80]	; (80017c4 <oqPutTimeout+0x94>)
 8001772:	f7ff fa55 	bl	8000c20 <chSysHalt>
  oqp->q_counter--;
 8001776:	68a3      	ldr	r3, [r4, #8]
 8001778:	3b01      	subs	r3, #1
 800177a:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800177c:	6963      	ldr	r3, [r4, #20]
 800177e:	1c5a      	adds	r2, r3, #1
 8001780:	6162      	str	r2, [r4, #20]
 8001782:	701f      	strb	r7, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8001784:	6962      	ldr	r2, [r4, #20]
 8001786:	6923      	ldr	r3, [r4, #16]
 8001788:	429a      	cmp	r2, r3
 800178a:	d301      	bcc.n	8001790 <oqPutTimeout+0x60>
    oqp->q_wrptr = oqp->q_buffer;
 800178c:	68e3      	ldr	r3, [r4, #12]
 800178e:	6163      	str	r3, [r4, #20]
  if (oqp->q_notify != NULL) {
 8001790:	69e3      	ldr	r3, [r4, #28]
 8001792:	b10b      	cbz	r3, 8001798 <oqPutTimeout+0x68>
    oqp->q_notify(oqp);
 8001794:	4620      	mov	r0, r4
 8001796:	4798      	blx	r3
  _dbg_check_unlock();
 8001798:	f000 fd42 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800179c:	4b08      	ldr	r3, [pc, #32]	; (80017c0 <oqPutTimeout+0x90>)
 800179e:	681a      	ldr	r2, [r3, #0]
 80017a0:	429a      	cmp	r2, r3
 80017a2:	d004      	beq.n	80017ae <oqPutTimeout+0x7e>
 80017a4:	699b      	ldr	r3, [r3, #24]
 80017a6:	6899      	ldr	r1, [r3, #8]
 80017a8:	6893      	ldr	r3, [r2, #8]
 80017aa:	4299      	cmp	r1, r3
 80017ac:	d304      	bcc.n	80017b8 <oqPutTimeout+0x88>
 80017ae:	2500      	movs	r5, #0
 80017b0:	f385 8811 	msr	BASEPRI, r5
}
 80017b4:	4628      	mov	r0, r5
 80017b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80017b8:	4802      	ldr	r0, [pc, #8]	; (80017c4 <oqPutTimeout+0x94>)
 80017ba:	f7ff fa31 	bl	8000c20 <chSysHalt>
 80017be:	bf00      	nop
 80017c0:	20000a50 	.word	0x20000a50
 80017c4:	08002d04 	.word	0x08002d04
	...

080017d0 <_putt>:
static msg_t _putt(void *ip, uint8_t b, sysinterval_t timeout) {
 80017d0:	b508      	push	{r3, lr}
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80017d2:	3030      	adds	r0, #48	; 0x30
 80017d4:	f7ff ffac 	bl	8001730 <oqPutTimeout>
}
 80017d8:	bd08      	pop	{r3, pc}
 80017da:	bf00      	nop
 80017dc:	0000      	movs	r0, r0
	...

080017e0 <_put>:
static msg_t _put(void *ip, uint8_t b) {
 80017e0:	b508      	push	{r3, lr}
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80017e2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80017e6:	3030      	adds	r0, #48	; 0x30
 80017e8:	f7ff ffa2 	bl	8001730 <oqPutTimeout>
}
 80017ec:	bd08      	pop	{r3, pc}
 80017ee:	bf00      	nop

080017f0 <iqReadTimeout>:
                     size_t n, sysinterval_t timeout) {
 80017f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  qnotify_t nfy = iqp->q_notify;
 80017f4:	f8d0 801c 	ldr.w	r8, [r0, #28]
  osalDbgCheck(n > 0U);
 80017f8:	b152      	cbz	r2, 8001810 <iqReadTimeout+0x20>
 80017fa:	4605      	mov	r5, r0
 80017fc:	460e      	mov	r6, r1
 80017fe:	469a      	mov	sl, r3
 8001800:	4691      	mov	r9, r2
 8001802:	2320      	movs	r3, #32
 8001804:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8001808:	f000 fd3a 	bl	8002280 <_dbg_check_lock>
 800180c:	464c      	mov	r4, r9
 800180e:	e023      	b.n	8001858 <iqReadTimeout+0x68>
 8001810:	4821      	ldr	r0, [pc, #132]	; (8001898 <iqReadTimeout+0xa8>)
 8001812:	f7ff fa05 	bl	8000c20 <chSysHalt>
 8001816:	4651      	mov	r1, sl
 8001818:	4628      	mov	r0, r5
 800181a:	f001 f8a9 	bl	8002970 <chThdEnqueueTimeoutS>
      if (msg != MSG_OK) {
 800181e:	b1d8      	cbz	r0, 8001858 <iqReadTimeout+0x68>
  _dbg_check_unlock();
 8001820:	f000 fcfe 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001824:	4b1d      	ldr	r3, [pc, #116]	; (800189c <iqReadTimeout+0xac>)
 8001826:	681a      	ldr	r2, [r3, #0]
 8001828:	429a      	cmp	r2, r3
 800182a:	d004      	beq.n	8001836 <iqReadTimeout+0x46>
 800182c:	699b      	ldr	r3, [r3, #24]
 800182e:	6899      	ldr	r1, [r3, #8]
 8001830:	6893      	ldr	r3, [r2, #8]
 8001832:	4299      	cmp	r1, r3
 8001834:	d32d      	bcc.n	8001892 <iqReadTimeout+0xa2>
 8001836:	2300      	movs	r3, #0
 8001838:	f383 8811 	msr	BASEPRI, r3
}
 800183c:	eba9 0004 	sub.w	r0, r9, r4
 8001840:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8001844:	2300      	movs	r3, #0
 8001846:	f383 8811 	msr	BASEPRI, r3
      n  -= done;
 800184a:	1be4      	subs	r4, r4, r7
      bp += done;
 800184c:	443e      	add	r6, r7
 800184e:	2320      	movs	r3, #32
 8001850:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8001854:	f000 fd14 	bl	8002280 <_dbg_check_lock>
  while (n > 0U) {
 8001858:	2c00      	cmp	r4, #0
 800185a:	d0e1      	beq.n	8001820 <iqReadTimeout+0x30>
    done = iq_read(iqp, bp, n);
 800185c:	4622      	mov	r2, r4
 800185e:	4631      	mov	r1, r6
 8001860:	4628      	mov	r0, r5
 8001862:	f7ff fb95 	bl	8000f90 <iq_read>
    if (done == (size_t)0) {
 8001866:	4607      	mov	r7, r0
 8001868:	2800      	cmp	r0, #0
 800186a:	d0d4      	beq.n	8001816 <iqReadTimeout+0x26>
      if (nfy != NULL) {
 800186c:	f1b8 0f00 	cmp.w	r8, #0
 8001870:	d001      	beq.n	8001876 <iqReadTimeout+0x86>
        nfy(iqp);
 8001872:	4628      	mov	r0, r5
 8001874:	47c0      	blx	r8
  _dbg_check_unlock();
 8001876:	f000 fcd3 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800187a:	4b08      	ldr	r3, [pc, #32]	; (800189c <iqReadTimeout+0xac>)
 800187c:	681a      	ldr	r2, [r3, #0]
 800187e:	429a      	cmp	r2, r3
 8001880:	d0e0      	beq.n	8001844 <iqReadTimeout+0x54>
 8001882:	699b      	ldr	r3, [r3, #24]
 8001884:	6899      	ldr	r1, [r3, #8]
 8001886:	6893      	ldr	r3, [r2, #8]
 8001888:	4299      	cmp	r1, r3
 800188a:	d2db      	bcs.n	8001844 <iqReadTimeout+0x54>
 800188c:	4804      	ldr	r0, [pc, #16]	; (80018a0 <iqReadTimeout+0xb0>)
 800188e:	f7ff f9c7 	bl	8000c20 <chSysHalt>
 8001892:	4803      	ldr	r0, [pc, #12]	; (80018a0 <iqReadTimeout+0xb0>)
 8001894:	f7ff f9c4 	bl	8000c20 <chSysHalt>
 8001898:	08002e0c 	.word	0x08002e0c
 800189c:	20000a50 	.word	0x20000a50
 80018a0:	08002d04 	.word	0x08002d04
	...

080018b0 <_readt>:
                     sysinterval_t timeout) {
 80018b0:	b508      	push	{r3, lr}
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 80018b2:	300c      	adds	r0, #12
 80018b4:	f7ff ff9c 	bl	80017f0 <iqReadTimeout>
}
 80018b8:	bd08      	pop	{r3, pc}
 80018ba:	bf00      	nop
 80018bc:	0000      	movs	r0, r0
	...

080018c0 <_read>:
static size_t _read(void *ip, uint8_t *bp, size_t n) {
 80018c0:	b508      	push	{r3, lr}
  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 80018c2:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80018c6:	300c      	adds	r0, #12
 80018c8:	f7ff ff92 	bl	80017f0 <iqReadTimeout>
}
 80018cc:	bd08      	pop	{r3, pc}
 80018ce:	bf00      	nop

080018d0 <iqGetTimeout>:
msg_t iqGetTimeout(input_queue_t *iqp, sysinterval_t timeout) {
 80018d0:	b570      	push	{r4, r5, r6, lr}
 80018d2:	4604      	mov	r4, r0
 80018d4:	460e      	mov	r6, r1
 80018d6:	2320      	movs	r3, #32
 80018d8:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80018dc:	f000 fcd0 	bl	8002280 <_dbg_check_lock>
  while (iqIsEmptyI(iqp)) {
 80018e0:	68a3      	ldr	r3, [r4, #8]
 80018e2:	b9bb      	cbnz	r3, 8001914 <iqGetTimeout+0x44>
 80018e4:	4631      	mov	r1, r6
 80018e6:	4620      	mov	r0, r4
 80018e8:	f001 f842 	bl	8002970 <chThdEnqueueTimeoutS>
    if (msg < MSG_OK) {
 80018ec:	1e05      	subs	r5, r0, #0
 80018ee:	daf7      	bge.n	80018e0 <iqGetTimeout+0x10>
  _dbg_check_unlock();
 80018f0:	f000 fc96 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80018f4:	4b19      	ldr	r3, [pc, #100]	; (800195c <iqGetTimeout+0x8c>)
 80018f6:	681a      	ldr	r2, [r3, #0]
 80018f8:	429a      	cmp	r2, r3
 80018fa:	d004      	beq.n	8001906 <iqGetTimeout+0x36>
 80018fc:	699b      	ldr	r3, [r3, #24]
 80018fe:	6899      	ldr	r1, [r3, #8]
 8001900:	6893      	ldr	r3, [r2, #8]
 8001902:	4299      	cmp	r1, r3
 8001904:	d303      	bcc.n	800190e <iqGetTimeout+0x3e>
 8001906:	2300      	movs	r3, #0
 8001908:	f383 8811 	msr	BASEPRI, r3
 800190c:	e020      	b.n	8001950 <iqGetTimeout+0x80>
 800190e:	4814      	ldr	r0, [pc, #80]	; (8001960 <iqGetTimeout+0x90>)
 8001910:	f7ff f986 	bl	8000c20 <chSysHalt>
  iqp->q_counter--;
 8001914:	68a3      	ldr	r3, [r4, #8]
 8001916:	3b01      	subs	r3, #1
 8001918:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 800191a:	69a2      	ldr	r2, [r4, #24]
 800191c:	1c53      	adds	r3, r2, #1
 800191e:	61a3      	str	r3, [r4, #24]
 8001920:	7815      	ldrb	r5, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 8001922:	6922      	ldr	r2, [r4, #16]
 8001924:	4293      	cmp	r3, r2
 8001926:	d301      	bcc.n	800192c <iqGetTimeout+0x5c>
    iqp->q_rdptr = iqp->q_buffer;
 8001928:	68e3      	ldr	r3, [r4, #12]
 800192a:	61a3      	str	r3, [r4, #24]
  if (iqp->q_notify != NULL) {
 800192c:	69e3      	ldr	r3, [r4, #28]
 800192e:	b10b      	cbz	r3, 8001934 <iqGetTimeout+0x64>
    iqp->q_notify(iqp);
 8001930:	4620      	mov	r0, r4
 8001932:	4798      	blx	r3
  _dbg_check_unlock();
 8001934:	f000 fc74 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001938:	4b08      	ldr	r3, [pc, #32]	; (800195c <iqGetTimeout+0x8c>)
 800193a:	681a      	ldr	r2, [r3, #0]
 800193c:	429a      	cmp	r2, r3
 800193e:	d004      	beq.n	800194a <iqGetTimeout+0x7a>
 8001940:	699b      	ldr	r3, [r3, #24]
 8001942:	6899      	ldr	r1, [r3, #8]
 8001944:	6893      	ldr	r3, [r2, #8]
 8001946:	4299      	cmp	r1, r3
 8001948:	d304      	bcc.n	8001954 <iqGetTimeout+0x84>
 800194a:	2300      	movs	r3, #0
 800194c:	f383 8811 	msr	BASEPRI, r3
}
 8001950:	4628      	mov	r0, r5
 8001952:	bd70      	pop	{r4, r5, r6, pc}
 8001954:	4802      	ldr	r0, [pc, #8]	; (8001960 <iqGetTimeout+0x90>)
 8001956:	f7ff f963 	bl	8000c20 <chSysHalt>
 800195a:	bf00      	nop
 800195c:	20000a50 	.word	0x20000a50
 8001960:	08002d04 	.word	0x08002d04
	...

08001970 <_gett>:
static msg_t _gett(void *ip, sysinterval_t timeout) {
 8001970:	b508      	push	{r3, lr}
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8001972:	300c      	adds	r0, #12
 8001974:	f7ff ffac 	bl	80018d0 <iqGetTimeout>
}
 8001978:	bd08      	pop	{r3, pc}
 800197a:	bf00      	nop
 800197c:	0000      	movs	r0, r0
	...

08001980 <_get>:
static msg_t _get(void *ip) {
 8001980:	b508      	push	{r3, lr}
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8001982:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8001986:	300c      	adds	r0, #12
 8001988:	f7ff ffa2 	bl	80018d0 <iqGetTimeout>
}
 800198c:	bd08      	pop	{r3, pc}
 800198e:	bf00      	nop

08001990 <_thread_memfill>:
 * @param[in] endp      last address to fill +1
 * @param[in] v         filler value
 *
 * @notapi
 */
void _thread_memfill(uint8_t *startp, uint8_t *endp, uint8_t v) {
 8001990:	e001      	b.n	8001996 <_thread_memfill+0x6>

  while (startp < endp) {
    *startp++ = v;
 8001992:	7002      	strb	r2, [r0, #0]
 8001994:	3001      	adds	r0, #1
  while (startp < endp) {
 8001996:	4288      	cmp	r0, r1
 8001998:	d3fb      	bcc.n	8001992 <_thread_memfill+0x2>
  }
}
 800199a:	4770      	bx	lr
 800199c:	0000      	movs	r0, r0
	...

080019a0 <trace_next>:
 *
 * @notapi
 */
static NOINLINE void trace_next(void) {

  ch.dbg.trace_buffer.ptr->time    = chVTGetSystemTimeX();
 80019a0:	4b0c      	ldr	r3, [pc, #48]	; (80019d4 <trace_next+0x34>)
 80019a2:	6bda      	ldr	r2, [r3, #60]	; 0x3c
  return (systime_t)STM32_ST_TIM->CNT;
 80019a4:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 80019a8:	6a49      	ldr	r1, [r1, #36]	; 0x24
 80019aa:	6051      	str	r1, [r2, #4]
#if PORT_SUPPORTS_RT == TRUE
  ch.dbg.trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 80019ac:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80019ae:	490a      	ldr	r1, [pc, #40]	; (80019d8 <trace_next+0x38>)
 80019b0:	6848      	ldr	r0, [r1, #4]
 80019b2:	6811      	ldr	r1, [r2, #0]
 80019b4:	f360 211f 	bfi	r1, r0, #8, #24
 80019b8:	6011      	str	r1, [r2, #0]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(ch.dbg.trace_buffer.ptr);

  if (++ch.dbg.trace_buffer.ptr >=
 80019ba:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80019bc:	3210      	adds	r2, #16
 80019be:	63da      	str	r2, [r3, #60]	; 0x3c
 80019c0:	f503 6304 	add.w	r3, r3, #2112	; 0x840
 80019c4:	429a      	cmp	r2, r3
 80019c6:	d304      	bcc.n	80019d2 <trace_next+0x32>
      &ch.dbg.trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
    ch.dbg.trace_buffer.ptr = &ch.dbg.trace_buffer.buffer[0];
 80019c8:	f5a3 6304 	sub.w	r3, r3, #2112	; 0x840
 80019cc:	f103 0240 	add.w	r2, r3, #64	; 0x40
 80019d0:	63da      	str	r2, [r3, #60]	; 0x3c
 80019d2:	4770      	bx	lr
 80019d4:	20000a50 	.word	0x20000a50
 80019d8:	e0001000 	.word	0xe0001000
 80019dc:	00000000 	.word	0x00000000

080019e0 <_trace_switch>:
 */
void _trace_switch(thread_t *ntp, thread_t *otp) {

  (void)ntp;

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80019e0:	4b0e      	ldr	r3, [pc, #56]	; (8001a1c <_trace_switch+0x3c>)
 80019e2:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 80019e4:	f013 0f01 	tst.w	r3, #1
 80019e8:	d000      	beq.n	80019ec <_trace_switch+0xc>
 80019ea:	4770      	bx	lr
void _trace_switch(thread_t *ntp, thread_t *otp) {
 80019ec:	b510      	push	{r4, lr}
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80019ee:	4b0b      	ldr	r3, [pc, #44]	; (8001a1c <_trace_switch+0x3c>)
 80019f0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80019f2:	7810      	ldrb	r0, [r2, #0]
 80019f4:	2401      	movs	r4, #1
 80019f6:	f364 0002 	bfi	r0, r4, #0, #3
 80019fa:	7010      	strb	r0, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = (uint8_t)otp->state;
 80019fc:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80019fe:	f891 4020 	ldrb.w	r4, [r1, #32]
 8001a02:	7810      	ldrb	r0, [r2, #0]
 8001a04:	f364 00c7 	bfi	r0, r4, #3, #5
 8001a08:	7010      	strb	r0, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.sw.ntp    = currp;
 8001a0a:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001a0c:	6998      	ldr	r0, [r3, #24]
 8001a0e:	6090      	str	r0, [r2, #8]
    ch.dbg.trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8001a10:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001a12:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8001a14:	60da      	str	r2, [r3, #12]
    trace_next();
 8001a16:	f7ff ffc3 	bl	80019a0 <trace_next>
 8001a1a:	bd10      	pop	{r4, pc}
 8001a1c:	20000a50 	.word	0x20000a50

08001a20 <_thread_init>:
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {
 8001a20:	b410      	push	{r4}
  tp->prio      = prio;
 8001a22:	6082      	str	r2, [r0, #8]
  tp->state     = CH_STATE_WTSTART;
 8001a24:	2402      	movs	r4, #2
 8001a26:	f880 4020 	strb.w	r4, [r0, #32]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8001a2a:	2400      	movs	r4, #0
 8001a2c:	f880 4021 	strb.w	r4, [r0, #33]	; 0x21
  tp->realprio  = prio;
 8001a30:	63c2      	str	r2, [r0, #60]	; 0x3c
  tp->mtxlist   = NULL;
 8001a32:	6384      	str	r4, [r0, #56]	; 0x38
  tp->epending  = (eventmask_t)0;
 8001a34:	6344      	str	r4, [r0, #52]	; 0x34
  tp->refs      = (trefs_t)1;
 8001a36:	2201      	movs	r2, #1
 8001a38:	f880 2022 	strb.w	r2, [r0, #34]	; 0x22
  tp->name      = name;
 8001a3c:	6181      	str	r1, [r0, #24]
  REG_INSERT(tp);
 8001a3e:	4a08      	ldr	r2, [pc, #32]	; (8001a60 <_thread_init+0x40>)
 8001a40:	6102      	str	r2, [r0, #16]
 8001a42:	6951      	ldr	r1, [r2, #20]
 8001a44:	6141      	str	r1, [r0, #20]
 8001a46:	6108      	str	r0, [r1, #16]
 8001a48:	6150      	str	r0, [r2, #20]
  list_init(&tp->waiting);
 8001a4a:	f100 0228 	add.w	r2, r0, #40	; 0x28
  tlp->next = (thread_t *)tlp;
 8001a4e:	6282      	str	r2, [r0, #40]	; 0x28
  queue_init(&tp->msgqueue);
 8001a50:	f100 022c 	add.w	r2, r0, #44	; 0x2c
  tqp->next = (thread_t *)tqp;
 8001a54:	62c2      	str	r2, [r0, #44]	; 0x2c
  tqp->prev = (thread_t *)tqp;
 8001a56:	6302      	str	r2, [r0, #48]	; 0x30
}
 8001a58:	f85d 4b04 	ldr.w	r4, [sp], #4
 8001a5c:	4770      	bx	lr
 8001a5e:	bf00      	nop
 8001a60:	20000a50 	.word	0x20000a50
	...

08001a70 <chSchIsPreemptionRequired>:
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 8001a70:	4b04      	ldr	r3, [pc, #16]	; (8001a84 <chSchIsPreemptionRequired+0x14>)
 8001a72:	681a      	ldr	r2, [r3, #0]
 8001a74:	6890      	ldr	r0, [r2, #8]
  tprio_t p2 = currp->prio;
 8001a76:	699b      	ldr	r3, [r3, #24]
 8001a78:	689b      	ldr	r3, [r3, #8]
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
 8001a7a:	4298      	cmp	r0, r3
 8001a7c:	bf94      	ite	ls
 8001a7e:	2000      	movls	r0, #0
 8001a80:	2001      	movhi	r0, #1
 8001a82:	4770      	bx	lr
 8001a84:	20000a50 	.word	0x20000a50
	...

08001a90 <_scheduler_init>:
  tqp->next = (thread_t *)tqp;
 8001a90:	4b03      	ldr	r3, [pc, #12]	; (8001aa0 <_scheduler_init+0x10>)
 8001a92:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001a94:	605b      	str	r3, [r3, #4]
  ch.rlist.prio = NOPRIO;
 8001a96:	2200      	movs	r2, #0
 8001a98:	609a      	str	r2, [r3, #8]
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8001a9a:	611b      	str	r3, [r3, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8001a9c:	615b      	str	r3, [r3, #20]
 8001a9e:	4770      	bx	lr
 8001aa0:	20000a50 	.word	0x20000a50
	...

08001ab0 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8001ab0:	4b05      	ldr	r3, [pc, #20]	; (8001ac8 <_vt_init+0x18>)
 8001ab2:	f103 021c 	add.w	r2, r3, #28
 8001ab6:	61da      	str	r2, [r3, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8001ab8:	621a      	str	r2, [r3, #32]
  ch.vtlist.delta = (sysinterval_t)-1;
 8001aba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001abe:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8001ac0:	2200      	movs	r2, #0
 8001ac2:	629a      	str	r2, [r3, #40]	; 0x28
 8001ac4:	4770      	bx	lr
 8001ac6:	bf00      	nop
 8001ac8:	20000a50 	.word	0x20000a50
 8001acc:	00000000 	.word	0x00000000

08001ad0 <_trace_halt>:
 *
 * @notapi
 */
void _trace_halt(const char *reason) {

  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8001ad0:	4b0b      	ldr	r3, [pc, #44]	; (8001b00 <_trace_halt+0x30>)
 8001ad2:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8001ad4:	f013 0f04 	tst.w	r3, #4
 8001ad8:	d000      	beq.n	8001adc <_trace_halt+0xc>
 8001ada:	4770      	bx	lr
void _trace_halt(const char *reason) {
 8001adc:	b510      	push	{r4, lr}
    ch.dbg.trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8001ade:	4b08      	ldr	r3, [pc, #32]	; (8001b00 <_trace_halt+0x30>)
 8001ae0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001ae2:	7811      	ldrb	r1, [r2, #0]
 8001ae4:	2404      	movs	r4, #4
 8001ae6:	f364 0102 	bfi	r1, r4, #0, #3
 8001aea:	7011      	strb	r1, [r2, #0]
    ch.dbg.trace_buffer.ptr->state         = 0;
 8001aec:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001aee:	7811      	ldrb	r1, [r2, #0]
 8001af0:	f36f 01c7 	bfc	r1, #3, #5
 8001af4:	7011      	strb	r1, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.halt.reason = reason;
 8001af6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001af8:	6098      	str	r0, [r3, #8]
    trace_next();
 8001afa:	f7ff ff51 	bl	80019a0 <trace_next>
 8001afe:	bd10      	pop	{r4, pc}
 8001b00:	20000a50 	.word	0x20000a50
	...

08001b10 <_trace_isr_leave>:
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001b10:	4b0e      	ldr	r3, [pc, #56]	; (8001b4c <_trace_isr_leave+0x3c>)
 8001b12:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8001b14:	f013 0f02 	tst.w	r3, #2
 8001b18:	d000      	beq.n	8001b1c <_trace_isr_leave+0xc>
 8001b1a:	4770      	bx	lr
void _trace_isr_leave(const char *isr) {
 8001b1c:	b510      	push	{r4, lr}
 8001b1e:	2320      	movs	r3, #32
 8001b20:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8001b24:	4b09      	ldr	r3, [pc, #36]	; (8001b4c <_trace_isr_leave+0x3c>)
 8001b26:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001b28:	7811      	ldrb	r1, [r2, #0]
 8001b2a:	2403      	movs	r4, #3
 8001b2c:	f364 0102 	bfi	r1, r4, #0, #3
 8001b30:	7011      	strb	r1, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8001b32:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001b34:	7811      	ldrb	r1, [r2, #0]
 8001b36:	f36f 01c7 	bfc	r1, #3, #5
 8001b3a:	7011      	strb	r1, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8001b3c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001b3e:	6098      	str	r0, [r3, #8]
    trace_next();
 8001b40:	f7ff ff2e 	bl	80019a0 <trace_next>
 8001b44:	2300      	movs	r3, #0
 8001b46:	f383 8811 	msr	BASEPRI, r3
 8001b4a:	bd10      	pop	{r4, pc}
 8001b4c:	20000a50 	.word	0x20000a50

08001b50 <_trace_isr_enter>:
  if ((ch.dbg.trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8001b50:	4b0e      	ldr	r3, [pc, #56]	; (8001b8c <_trace_isr_enter+0x3c>)
 8001b52:	8f1b      	ldrh	r3, [r3, #56]	; 0x38
 8001b54:	f013 0f02 	tst.w	r3, #2
 8001b58:	d000      	beq.n	8001b5c <_trace_isr_enter+0xc>
 8001b5a:	4770      	bx	lr
void _trace_isr_enter(const char *isr) {
 8001b5c:	b510      	push	{r4, lr}
 8001b5e:	2320      	movs	r3, #32
 8001b60:	f383 8811 	msr	BASEPRI, r3
    ch.dbg.trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8001b64:	4b09      	ldr	r3, [pc, #36]	; (8001b8c <_trace_isr_enter+0x3c>)
 8001b66:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001b68:	7811      	ldrb	r1, [r2, #0]
 8001b6a:	2402      	movs	r4, #2
 8001b6c:	f364 0102 	bfi	r1, r4, #0, #3
 8001b70:	7011      	strb	r1, [r2, #0]
    ch.dbg.trace_buffer.ptr->state       = 0U;
 8001b72:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001b74:	7811      	ldrb	r1, [r2, #0]
 8001b76:	f36f 01c7 	bfc	r1, #3, #5
 8001b7a:	7011      	strb	r1, [r2, #0]
    ch.dbg.trace_buffer.ptr->u.isr.name  = isr;
 8001b7c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001b7e:	6098      	str	r0, [r3, #8]
    trace_next();
 8001b80:	f7ff ff0e 	bl	80019a0 <trace_next>
 8001b84:	2300      	movs	r3, #0
 8001b86:	f383 8811 	msr	BASEPRI, r3
 8001b8a:	bd10      	pop	{r4, pc}
 8001b8c:	20000a50 	.word	0x20000a50

08001b90 <_trace_init>:
  ch.dbg.trace_buffer.suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 8001b90:	4b0c      	ldr	r3, [pc, #48]	; (8001bc4 <_trace_init+0x34>)
 8001b92:	f64f 72f0 	movw	r2, #65520	; 0xfff0
 8001b96:	871a      	strh	r2, [r3, #56]	; 0x38
  ch.dbg.trace_buffer.size      = CH_DBG_TRACE_BUFFER_SIZE;
 8001b98:	2280      	movs	r2, #128	; 0x80
 8001b9a:	875a      	strh	r2, [r3, #58]	; 0x3a
  ch.dbg.trace_buffer.ptr       = &ch.dbg.trace_buffer.buffer[0];
 8001b9c:	f103 0240 	add.w	r2, r3, #64	; 0x40
 8001ba0:	63da      	str	r2, [r3, #60]	; 0x3c
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8001ba2:	2300      	movs	r3, #0
 8001ba4:	e00a      	b.n	8001bbc <_trace_init+0x2c>
    ch.dbg.trace_buffer.buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8001ba6:	1c5a      	adds	r2, r3, #1
 8001ba8:	4b06      	ldr	r3, [pc, #24]	; (8001bc4 <_trace_init+0x34>)
 8001baa:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 8001bae:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
 8001bb2:	f36f 0102 	bfc	r1, #0, #3
 8001bb6:	f883 1030 	strb.w	r1, [r3, #48]	; 0x30
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8001bba:	4613      	mov	r3, r2
 8001bbc:	2b7f      	cmp	r3, #127	; 0x7f
 8001bbe:	d9f2      	bls.n	8001ba6 <_trace_init+0x16>
}
 8001bc0:	4770      	bx	lr
 8001bc2:	bf00      	nop
 8001bc4:	20000a50 	.word	0x20000a50
	...

08001bd0 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8001bd0:	b508      	push	{r3, lr}

  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001bd2:	4b05      	ldr	r3, [pc, #20]	; (8001be8 <chDbgCheckClassS+0x18>)
 8001bd4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001bd6:	b923      	cbnz	r3, 8001be2 <chDbgCheckClassS+0x12>
 8001bd8:	4b03      	ldr	r3, [pc, #12]	; (8001be8 <chDbgCheckClassS+0x18>)
 8001bda:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001bdc:	2b00      	cmp	r3, #0
 8001bde:	dd00      	ble.n	8001be2 <chDbgCheckClassS+0x12>
 8001be0:	bd08      	pop	{r3, pc}
    chSysHalt("SV#11");
 8001be2:	4802      	ldr	r0, [pc, #8]	; (8001bec <chDbgCheckClassS+0x1c>)
 8001be4:	f7ff f81c 	bl	8000c20 <chSysHalt>
 8001be8:	20000a50 	.word	0x20000a50
 8001bec:	080030dc 	.word	0x080030dc

08001bf0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
 8001bf0:	b570      	push	{r4, r5, r6, lr}
 8001bf2:	4606      	mov	r6, r0
  thread_t *otp = currp;
 8001bf4:	4c0f      	ldr	r4, [pc, #60]	; (8001c34 <chSchGoSleepS+0x44>)
 8001bf6:	69a5      	ldr	r5, [r4, #24]
  chDbgCheckClassS();
 8001bf8:	f7ff ffea 	bl	8001bd0 <chDbgCheckClassS>
  otp->state = newstate;
 8001bfc:	f885 6020 	strb.w	r6, [r5, #32]
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8001c00:	6820      	ldr	r0, [r4, #0]

  tqp->next             = tp->queue.next;
 8001c02:	6803      	ldr	r3, [r0, #0]
 8001c04:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001c06:	605c      	str	r4, [r3, #4]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001c08:	61a0      	str	r0, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 8001c0a:	2301      	movs	r3, #1
 8001c0c:	f880 3020 	strb.w	r3, [r0, #32]
  chSysSwitch(currp, otp);
 8001c10:	4629      	mov	r1, r5
 8001c12:	f7ff fee5 	bl	80019e0 <_trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8001c16:	f3ef 8309 	mrs	r3, PSP
 8001c1a:	3b64      	subs	r3, #100	; 0x64
 8001c1c:	69ea      	ldr	r2, [r5, #28]
 8001c1e:	429a      	cmp	r2, r3
 8001c20:	d805      	bhi.n	8001c2e <chSchGoSleepS+0x3e>
 8001c22:	4629      	mov	r1, r5
 8001c24:	4b03      	ldr	r3, [pc, #12]	; (8001c34 <chSchGoSleepS+0x44>)
 8001c26:	6998      	ldr	r0, [r3, #24]
 8001c28:	f7fe fb6e 	bl	8000308 <_port_switch>
 8001c2c:	bd70      	pop	{r4, r5, r6, pc}
 8001c2e:	4802      	ldr	r0, [pc, #8]	; (8001c38 <chSchGoSleepS+0x48>)
 8001c30:	f7fe fff6 	bl	8000c20 <chSysHalt>
 8001c34:	20000a50 	.word	0x20000a50
 8001c38:	080030e4 	.word	0x080030e4
 8001c3c:	00000000 	.word	0x00000000

08001c40 <chDbgCheckClassI>:
void chDbgCheckClassI(void) {
 8001c40:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8001c42:	4b06      	ldr	r3, [pc, #24]	; (8001c5c <chDbgCheckClassI+0x1c>)
 8001c44:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001c46:	2b00      	cmp	r3, #0
 8001c48:	db04      	blt.n	8001c54 <chDbgCheckClassI+0x14>
 8001c4a:	4b04      	ldr	r3, [pc, #16]	; (8001c5c <chDbgCheckClassI+0x1c>)
 8001c4c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001c4e:	2b00      	cmp	r3, #0
 8001c50:	dd00      	ble.n	8001c54 <chDbgCheckClassI+0x14>
 8001c52:	bd08      	pop	{r3, pc}
    chSysHalt("SV#10");
 8001c54:	4802      	ldr	r0, [pc, #8]	; (8001c60 <chDbgCheckClassI+0x20>)
 8001c56:	f7fe ffe3 	bl	8000c20 <chSysHalt>
 8001c5a:	bf00      	nop
 8001c5c:	20000a50 	.word	0x20000a50
 8001c60:	080030d4 	.word	0x080030d4
	...

08001c70 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8001c70:	b510      	push	{r4, lr}
 8001c72:	4604      	mov	r4, r0
  thread_t *tp;

  chDbgCheckClassI();
 8001c74:	f7ff ffe4 	bl	8001c40 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 8001c78:	b184      	cbz	r4, 8001c9c <chThdCreateSuspendedI+0x2c>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8001c7a:	6863      	ldr	r3, [r4, #4]
 8001c7c:	f013 0f07 	tst.w	r3, #7
 8001c80:	d109      	bne.n	8001c96 <chThdCreateSuspendedI+0x26>
 8001c82:	68a2      	ldr	r2, [r4, #8]
 8001c84:	f012 0f07 	tst.w	r2, #7
 8001c88:	d105      	bne.n	8001c96 <chThdCreateSuspendedI+0x26>
 8001c8a:	4293      	cmp	r3, r2
 8001c8c:	d203      	bcs.n	8001c96 <chThdCreateSuspendedI+0x26>
 8001c8e:	1ad3      	subs	r3, r2, r3
 8001c90:	f5b3 7fa8 	cmp.w	r3, #336	; 0x150
 8001c94:	d205      	bcs.n	8001ca2 <chThdCreateSuspendedI+0x32>
 8001c96:	4812      	ldr	r0, [pc, #72]	; (8001ce0 <chThdCreateSuspendedI+0x70>)
 8001c98:	f7fe ffc2 	bl	8000c20 <chSysHalt>
  chDbgCheck(tdp != NULL);
 8001c9c:	4810      	ldr	r0, [pc, #64]	; (8001ce0 <chThdCreateSuspendedI+0x70>)
 8001c9e:	f7fe ffbf 	bl	8000c20 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8001ca2:	68e3      	ldr	r3, [r4, #12]
 8001ca4:	2bff      	cmp	r3, #255	; 0xff
 8001ca6:	d818      	bhi.n	8001cda <chThdCreateSuspendedI+0x6a>
 8001ca8:	6923      	ldr	r3, [r4, #16]
 8001caa:	b1b3      	cbz	r3, 8001cda <chThdCreateSuspendedI+0x6a>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8001cac:	68a0      	ldr	r0, [r4, #8]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8001cae:	6863      	ldr	r3, [r4, #4]
 8001cb0:	f840 3c2c 	str.w	r3, [r0, #-44]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8001cb4:	f1a0 03ac 	sub.w	r3, r0, #172	; 0xac
 8001cb8:	f840 3c3c 	str.w	r3, [r0, #-60]
 8001cbc:	6922      	ldr	r2, [r4, #16]
 8001cbe:	f840 2c6c 	str.w	r2, [r0, #-108]
 8001cc2:	6962      	ldr	r2, [r4, #20]
 8001cc4:	f840 2c68 	str.w	r2, [r0, #-104]
 8001cc8:	4a06      	ldr	r2, [pc, #24]	; (8001ce4 <chThdCreateSuspendedI+0x74>)
 8001cca:	f840 2c4c 	str.w	r2, [r0, #-76]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8001cce:	68e2      	ldr	r2, [r4, #12]
 8001cd0:	6821      	ldr	r1, [r4, #0]
 8001cd2:	3848      	subs	r0, #72	; 0x48
 8001cd4:	f7ff fea4 	bl	8001a20 <_thread_init>
}
 8001cd8:	bd10      	pop	{r4, pc}
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8001cda:	4801      	ldr	r0, [pc, #4]	; (8001ce0 <chThdCreateSuspendedI+0x70>)
 8001cdc:	f7fe ffa0 	bl	8000c20 <chSysHalt>
 8001ce0:	0800303c 	.word	0x0800303c
 8001ce4:	08000321 	.word	0x08000321
	...

08001cf0 <chSchReadyAheadI>:
thread_t *chSchReadyAheadI(thread_t *tp) {
 8001cf0:	b510      	push	{r4, lr}
 8001cf2:	4604      	mov	r4, r0
  chDbgCheckClassI();
 8001cf4:	f7ff ffa4 	bl	8001c40 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8001cf8:	b1a4      	cbz	r4, 8001d24 <chSchReadyAheadI+0x34>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8001cfa:	f894 3020 	ldrb.w	r3, [r4, #32]
 8001cfe:	b1a3      	cbz	r3, 8001d2a <chSchReadyAheadI+0x3a>
 8001d00:	2b0f      	cmp	r3, #15
 8001d02:	d012      	beq.n	8001d2a <chSchReadyAheadI+0x3a>
  tp->state = CH_STATE_READY;
 8001d04:	2300      	movs	r3, #0
 8001d06:	f884 3020 	strb.w	r3, [r4, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8001d0a:	4b09      	ldr	r3, [pc, #36]	; (8001d30 <chSchReadyAheadI+0x40>)
    cp = cp->queue.next;
 8001d0c:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
 8001d0e:	6899      	ldr	r1, [r3, #8]
 8001d10:	68a2      	ldr	r2, [r4, #8]
 8001d12:	4291      	cmp	r1, r2
 8001d14:	d8fa      	bhi.n	8001d0c <chSchReadyAheadI+0x1c>
  tp->queue.next             = cp;
 8001d16:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8001d18:	685a      	ldr	r2, [r3, #4]
 8001d1a:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8001d1c:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8001d1e:	605c      	str	r4, [r3, #4]
}
 8001d20:	4620      	mov	r0, r4
 8001d22:	bd10      	pop	{r4, pc}
  chDbgCheck(tp != NULL);
 8001d24:	4803      	ldr	r0, [pc, #12]	; (8001d34 <chSchReadyAheadI+0x44>)
 8001d26:	f7fe ff7b 	bl	8000c20 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8001d2a:	4802      	ldr	r0, [pc, #8]	; (8001d34 <chSchReadyAheadI+0x44>)
 8001d2c:	f7fe ff78 	bl	8000c20 <chSysHalt>
 8001d30:	20000a50 	.word	0x20000a50
 8001d34:	08003028 	.word	0x08003028
	...

08001d40 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8001d40:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 8001d42:	4c10      	ldr	r4, [pc, #64]	; (8001d84 <chSchDoReschedule+0x44>)
 8001d44:	69a0      	ldr	r0, [r4, #24]
  thread_t *tp = tqp->next;
 8001d46:	6823      	ldr	r3, [r4, #0]
  tqp->next             = tp->queue.next;
 8001d48:	681a      	ldr	r2, [r3, #0]
 8001d4a:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001d4c:	6054      	str	r4, [r2, #4]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001d4e:	61a3      	str	r3, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 8001d50:	2201      	movs	r2, #1
 8001d52:	f883 2020 	strb.w	r2, [r3, #32]
    otp = chSchReadyAheadI(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
 8001d56:	f7ff ffcb 	bl	8001cf0 <chSchReadyAheadI>
 8001d5a:	4605      	mov	r5, r0
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8001d5c:	4601      	mov	r1, r0
 8001d5e:	69a0      	ldr	r0, [r4, #24]
 8001d60:	f7ff fe3e 	bl	80019e0 <_trace_switch>
 8001d64:	f3ef 8309 	mrs	r3, PSP
 8001d68:	3b64      	subs	r3, #100	; 0x64
 8001d6a:	69ea      	ldr	r2, [r5, #28]
 8001d6c:	429a      	cmp	r2, r3
 8001d6e:	d805      	bhi.n	8001d7c <chSchDoReschedule+0x3c>
 8001d70:	4629      	mov	r1, r5
 8001d72:	4b04      	ldr	r3, [pc, #16]	; (8001d84 <chSchDoReschedule+0x44>)
 8001d74:	6998      	ldr	r0, [r3, #24]
 8001d76:	f7fe fac7 	bl	8000308 <_port_switch>
 8001d7a:	bd38      	pop	{r3, r4, r5, pc}
 8001d7c:	4802      	ldr	r0, [pc, #8]	; (8001d88 <chSchDoReschedule+0x48>)
 8001d7e:	f7fe ff4f 	bl	8000c20 <chSysHalt>
 8001d82:	bf00      	nop
 8001d84:	20000a50 	.word	0x20000a50
 8001d88:	080030e4 	.word	0x080030e4
 8001d8c:	00000000 	.word	0x00000000

08001d90 <chSchDoRescheduleAhead>:
void chSchDoRescheduleAhead(void) {
 8001d90:	b538      	push	{r3, r4, r5, lr}
  thread_t *otp = currp;
 8001d92:	4c10      	ldr	r4, [pc, #64]	; (8001dd4 <chSchDoRescheduleAhead+0x44>)
 8001d94:	69a0      	ldr	r0, [r4, #24]
  thread_t *tp = tqp->next;
 8001d96:	6823      	ldr	r3, [r4, #0]
  tqp->next             = tp->queue.next;
 8001d98:	681a      	ldr	r2, [r3, #0]
 8001d9a:	6022      	str	r2, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8001d9c:	6054      	str	r4, [r2, #4]
  currp = queue_fifo_remove(&ch.rlist.queue);
 8001d9e:	61a3      	str	r3, [r4, #24]
  currp->state = CH_STATE_CURRENT;
 8001da0:	2201      	movs	r2, #1
 8001da2:	f883 2020 	strb.w	r2, [r3, #32]
  otp = chSchReadyAheadI(otp);
 8001da6:	f7ff ffa3 	bl	8001cf0 <chSchReadyAheadI>
 8001daa:	4605      	mov	r5, r0
  chSysSwitch(currp, otp);
 8001dac:	4601      	mov	r1, r0
 8001dae:	69a0      	ldr	r0, [r4, #24]
 8001db0:	f7ff fe16 	bl	80019e0 <_trace_switch>
 8001db4:	f3ef 8309 	mrs	r3, PSP
 8001db8:	3b64      	subs	r3, #100	; 0x64
 8001dba:	69ea      	ldr	r2, [r5, #28]
 8001dbc:	429a      	cmp	r2, r3
 8001dbe:	d805      	bhi.n	8001dcc <chSchDoRescheduleAhead+0x3c>
 8001dc0:	4629      	mov	r1, r5
 8001dc2:	4b04      	ldr	r3, [pc, #16]	; (8001dd4 <chSchDoRescheduleAhead+0x44>)
 8001dc4:	6998      	ldr	r0, [r3, #24]
 8001dc6:	f7fe fa9f 	bl	8000308 <_port_switch>
 8001dca:	bd38      	pop	{r3, r4, r5, pc}
 8001dcc:	4802      	ldr	r0, [pc, #8]	; (8001dd8 <chSchDoRescheduleAhead+0x48>)
 8001dce:	f7fe ff27 	bl	8000c20 <chSysHalt>
 8001dd2:	bf00      	nop
 8001dd4:	20000a50 	.word	0x20000a50
 8001dd8:	080030e4 	.word	0x080030e4
 8001ddc:	00000000 	.word	0x00000000

08001de0 <chSchRescheduleS>:
void chSchRescheduleS(void) {
 8001de0:	b508      	push	{r3, lr}
  chDbgCheckClassS();
 8001de2:	f7ff fef5 	bl	8001bd0 <chDbgCheckClassS>
 *
 * @iclass
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();
 8001de6:	f7ff ff2b 	bl	8001c40 <chDbgCheckClassI>

  return firstprio(&ch.rlist.queue) > currp->prio;
 8001dea:	4b05      	ldr	r3, [pc, #20]	; (8001e00 <chSchRescheduleS+0x20>)
 8001dec:	681a      	ldr	r2, [r3, #0]
 8001dee:	6892      	ldr	r2, [r2, #8]
 8001df0:	699b      	ldr	r3, [r3, #24]
 8001df2:	689b      	ldr	r3, [r3, #8]
  if (chSchIsRescRequiredI()) {
 8001df4:	429a      	cmp	r2, r3
 8001df6:	d800      	bhi.n	8001dfa <chSchRescheduleS+0x1a>
 8001df8:	bd08      	pop	{r3, pc}
    chSchDoRescheduleAhead();
 8001dfa:	f7ff ffc9 	bl	8001d90 <chSchDoRescheduleAhead>
 8001dfe:	e7fb      	b.n	8001df8 <chSchRescheduleS+0x18>
 8001e00:	20000a50 	.word	0x20000a50
	...

08001e10 <chSchReadyI>:
thread_t *chSchReadyI(thread_t *tp) {
 8001e10:	b510      	push	{r4, lr}
 8001e12:	4604      	mov	r4, r0
  chDbgCheckClassI();
 8001e14:	f7ff ff14 	bl	8001c40 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 8001e18:	b1a4      	cbz	r4, 8001e44 <chSchReadyI+0x34>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8001e1a:	f894 3020 	ldrb.w	r3, [r4, #32]
 8001e1e:	b1a3      	cbz	r3, 8001e4a <chSchReadyI+0x3a>
 8001e20:	2b0f      	cmp	r3, #15
 8001e22:	d012      	beq.n	8001e4a <chSchReadyI+0x3a>
  tp->state = CH_STATE_READY;
 8001e24:	2300      	movs	r3, #0
 8001e26:	f884 3020 	strb.w	r3, [r4, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8001e2a:	4b09      	ldr	r3, [pc, #36]	; (8001e50 <chSchReadyI+0x40>)
    cp = cp->queue.next;
 8001e2c:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8001e2e:	6899      	ldr	r1, [r3, #8]
 8001e30:	68a2      	ldr	r2, [r4, #8]
 8001e32:	4291      	cmp	r1, r2
 8001e34:	d2fa      	bcs.n	8001e2c <chSchReadyI+0x1c>
  tp->queue.next             = cp;
 8001e36:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 8001e38:	685a      	ldr	r2, [r3, #4]
 8001e3a:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 8001e3c:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8001e3e:	605c      	str	r4, [r3, #4]
}
 8001e40:	4620      	mov	r0, r4
 8001e42:	bd10      	pop	{r4, pc}
  chDbgCheck(tp != NULL);
 8001e44:	4803      	ldr	r0, [pc, #12]	; (8001e54 <chSchReadyI+0x44>)
 8001e46:	f7fe feeb 	bl	8000c20 <chSysHalt>
  chDbgAssert((tp->state != CH_STATE_READY) &&
 8001e4a:	4802      	ldr	r0, [pc, #8]	; (8001e54 <chSchReadyI+0x44>)
 8001e4c:	f7fe fee8 	bl	8000c20 <chSysHalt>
 8001e50:	20000a50 	.word	0x20000a50
 8001e54:	08003010 	.word	0x08003010
	...

08001e60 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8001e60:	b508      	push	{r3, lr}
  thread_t *tp = currp;
 8001e62:	4b10      	ldr	r3, [pc, #64]	; (8001ea4 <chThdExitS+0x44>)
 8001e64:	699c      	ldr	r4, [r3, #24]

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8001e66:	6260      	str	r0, [r4, #36]	; 0x24
 8001e68:	e003      	b.n	8001e72 <chThdExitS+0x12>
  tlp->next = tp->queue.next;
 8001e6a:	6803      	ldr	r3, [r0, #0]
 8001e6c:	62a3      	str	r3, [r4, #40]	; 0x28
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
    (void) chSchReadyI(list_remove(&tp->waiting));
 8001e6e:	f7ff ffcf 	bl	8001e10 <chSchReadyI>
  while (list_notempty(&tp->waiting)) {
 8001e72:	f104 0328 	add.w	r3, r4, #40	; 0x28
  return (bool)(tlp->next != (thread_t *)tlp);
 8001e76:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8001e78:	4283      	cmp	r3, r0
 8001e7a:	d1f6      	bne.n	8001e6a <chThdExitS+0xa>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8001e7c:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8001e80:	b953      	cbnz	r3, 8001e98 <chThdExitS+0x38>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 8001e82:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
  if ((tp->refs == (trefs_t)0) &&
 8001e86:	f013 0f03 	tst.w	r3, #3
 8001e8a:	d105      	bne.n	8001e98 <chThdExitS+0x38>
    REG_REMOVE(tp);
 8001e8c:	6963      	ldr	r3, [r4, #20]
 8001e8e:	6922      	ldr	r2, [r4, #16]
 8001e90:	611a      	str	r2, [r3, #16]
 8001e92:	6923      	ldr	r3, [r4, #16]
 8001e94:	6962      	ldr	r2, [r4, #20]
 8001e96:	615a      	str	r2, [r3, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8001e98:	200f      	movs	r0, #15
 8001e9a:	f7ff fea9 	bl	8001bf0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8001e9e:	4802      	ldr	r0, [pc, #8]	; (8001ea8 <chThdExitS+0x48>)
 8001ea0:	f7fe febe 	bl	8000c20 <chSysHalt>
 8001ea4:	20000a50 	.word	0x20000a50
 8001ea8:	08003090 	.word	0x08003090
 8001eac:	00000000 	.word	0x00000000

08001eb0 <chSchWakeupS>:
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8001eb0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001eb2:	4604      	mov	r4, r0
 8001eb4:	460f      	mov	r7, r1
  thread_t *otp = currp;
 8001eb6:	4d19      	ldr	r5, [pc, #100]	; (8001f1c <chSchWakeupS+0x6c>)
 8001eb8:	69ae      	ldr	r6, [r5, #24]
  chDbgCheckClassS();
 8001eba:	f7ff fe89 	bl	8001bd0 <chDbgCheckClassS>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001ebe:	682b      	ldr	r3, [r5, #0]
 8001ec0:	42ab      	cmp	r3, r5
 8001ec2:	d004      	beq.n	8001ece <chSchWakeupS+0x1e>
 8001ec4:	69aa      	ldr	r2, [r5, #24]
 8001ec6:	6892      	ldr	r2, [r2, #8]
 8001ec8:	689b      	ldr	r3, [r3, #8]
 8001eca:	429a      	cmp	r2, r3
 8001ecc:	d31c      	bcc.n	8001f08 <chSchWakeupS+0x58>
  ntp->u.rdymsg = msg;
 8001ece:	6267      	str	r7, [r4, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
 8001ed0:	68a2      	ldr	r2, [r4, #8]
 8001ed2:	68b3      	ldr	r3, [r6, #8]
 8001ed4:	429a      	cmp	r2, r3
 8001ed6:	d91a      	bls.n	8001f0e <chSchWakeupS+0x5e>
    otp = chSchReadyI(otp);
 8001ed8:	4630      	mov	r0, r6
 8001eda:	f7ff ff99 	bl	8001e10 <chSchReadyI>
 8001ede:	4605      	mov	r5, r0
    currp = ntp;
 8001ee0:	4b0e      	ldr	r3, [pc, #56]	; (8001f1c <chSchWakeupS+0x6c>)
 8001ee2:	619c      	str	r4, [r3, #24]
    ntp->state = CH_STATE_CURRENT;
 8001ee4:	2301      	movs	r3, #1
 8001ee6:	f884 3020 	strb.w	r3, [r4, #32]
    chSysSwitch(ntp, otp);
 8001eea:	4601      	mov	r1, r0
 8001eec:	4620      	mov	r0, r4
 8001eee:	f7ff fd77 	bl	80019e0 <_trace_switch>
 8001ef2:	f3ef 8309 	mrs	r3, PSP
 8001ef6:	3b64      	subs	r3, #100	; 0x64
 8001ef8:	69ea      	ldr	r2, [r5, #28]
 8001efa:	429a      	cmp	r2, r3
 8001efc:	d80b      	bhi.n	8001f16 <chSchWakeupS+0x66>
 8001efe:	4629      	mov	r1, r5
 8001f00:	4620      	mov	r0, r4
 8001f02:	f7fe fa01 	bl	8000308 <_port_switch>
 8001f06:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8001f08:	4805      	ldr	r0, [pc, #20]	; (8001f20 <chSchWakeupS+0x70>)
 8001f0a:	f7fe fe89 	bl	8000c20 <chSysHalt>
    (void) chSchReadyI(ntp);
 8001f0e:	4620      	mov	r0, r4
 8001f10:	f7ff ff7e 	bl	8001e10 <chSchReadyI>
 8001f14:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    chSysSwitch(ntp, otp);
 8001f16:	4803      	ldr	r0, [pc, #12]	; (8001f24 <chSchWakeupS+0x74>)
 8001f18:	f7fe fe82 	bl	8000c20 <chSysHalt>
 8001f1c:	20000a50 	.word	0x20000a50
 8001f20:	08003070 	.word	0x08003070
 8001f24:	080030e4 	.word	0x080030e4
	...

08001f30 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8001f30:	b510      	push	{r4, lr}
 8001f32:	4604      	mov	r4, r0

  chDbgCheckClassI();
 8001f34:	f7ff fe84 	bl	8001c40 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8001f38:	b1b4      	cbz	r4, 8001f68 <chVTDoResetI+0x38>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 8001f3a:	68e3      	ldr	r3, [r4, #12]
 8001f3c:	b1bb      	cbz	r3, 8001f6e <chVTDoResetI+0x3e>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8001f3e:	4b20      	ldr	r3, [pc, #128]	; (8001fc0 <chVTDoResetI+0x90>)
 8001f40:	69db      	ldr	r3, [r3, #28]
 8001f42:	429c      	cmp	r4, r3
 8001f44:	d016      	beq.n	8001f74 <chVTDoResetI+0x44>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 8001f46:	6863      	ldr	r3, [r4, #4]
 8001f48:	6822      	ldr	r2, [r4, #0]
 8001f4a:	601a      	str	r2, [r3, #0]
    vtp->next->prev = vtp->prev;
 8001f4c:	6823      	ldr	r3, [r4, #0]
 8001f4e:	6862      	ldr	r2, [r4, #4]
 8001f50:	605a      	str	r2, [r3, #4]
    vtp->func = NULL;
 8001f52:	2300      	movs	r3, #0
 8001f54:	60e3      	str	r3, [r4, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8001f56:	6823      	ldr	r3, [r4, #0]
 8001f58:	4a1a      	ldr	r2, [pc, #104]	; (8001fc4 <chVTDoResetI+0x94>)
 8001f5a:	4293      	cmp	r3, r2
 8001f5c:	d029      	beq.n	8001fb2 <chVTDoResetI+0x82>
      vtp->next->delta += vtp->delta;
 8001f5e:	68a1      	ldr	r1, [r4, #8]
 8001f60:	689a      	ldr	r2, [r3, #8]
 8001f62:	440a      	add	r2, r1
 8001f64:	609a      	str	r2, [r3, #8]
 8001f66:	bd10      	pop	{r4, pc}
  chDbgCheck(vtp != NULL);
 8001f68:	4817      	ldr	r0, [pc, #92]	; (8001fc8 <chVTDoResetI+0x98>)
 8001f6a:	f7fe fe59 	bl	8000c20 <chSysHalt>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");
 8001f6e:	4816      	ldr	r0, [pc, #88]	; (8001fc8 <chVTDoResetI+0x98>)
 8001f70:	f7fe fe56 	bl	8000c20 <chSysHalt>

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 8001f74:	6821      	ldr	r1, [r4, #0]
 8001f76:	4a12      	ldr	r2, [pc, #72]	; (8001fc0 <chVTDoResetI+0x90>)
 8001f78:	4613      	mov	r3, r2
 8001f7a:	f843 1f1c 	str.w	r1, [r3, #28]!
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8001f7e:	604b      	str	r3, [r1, #4]
  vtp->func = NULL;
 8001f80:	2100      	movs	r1, #0
 8001f82:	60e1      	str	r1, [r4, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001f84:	69d2      	ldr	r2, [r2, #28]
 8001f86:	429a      	cmp	r2, r3
 8001f88:	d014      	beq.n	8001fb4 <chVTDoResetI+0x84>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8001f8a:	68a1      	ldr	r1, [r4, #8]
 8001f8c:	6893      	ldr	r3, [r2, #8]
 8001f8e:	440b      	add	r3, r1
 8001f90:	6093      	str	r3, [r2, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chTimeDiffX(ch.vtlist.lasttime, chVTGetSystemTimeX());
 8001f92:	4a0b      	ldr	r2, [pc, #44]	; (8001fc0 <chVTDoResetI+0x90>)
 8001f94:	6a90      	ldr	r0, [r2, #40]	; 0x28
 8001f96:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001f9a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001f9c:	1a1b      	subs	r3, r3, r0

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8001f9e:	69d2      	ldr	r2, [r2, #28]
 8001fa0:	6892      	ldr	r2, [r2, #8]
 8001fa2:	429a      	cmp	r2, r3
 8001fa4:	d905      	bls.n	8001fb2 <chVTDoResetI+0x82>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8001fa6:	1ad1      	subs	r1, r2, r3

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8001fa8:	2901      	cmp	r1, #1
 8001faa:	d906      	bls.n	8001fba <chVTDoResetI+0x8a>
 8001fac:	4410      	add	r0, r2
 8001fae:	f7ff f95f 	bl	8001270 <stSetAlarm>
 8001fb2:	bd10      	pop	{r4, pc}
  stStopAlarm();
 8001fb4:	f7ff f96c 	bl	8001290 <stStopAlarm>
 8001fb8:	bd10      	pop	{r4, pc}
    delta = nowdelta + (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8001fba:	1c9a      	adds	r2, r3, #2
 8001fbc:	e7f6      	b.n	8001fac <chVTDoResetI+0x7c>
 8001fbe:	bf00      	nop
 8001fc0:	20000a50 	.word	0x20000a50
 8001fc4:	20000a6c 	.word	0x20000a6c
 8001fc8:	08003054 	.word	0x08003054
 8001fcc:	00000000 	.word	0x00000000

08001fd0 <chVTDoSetI>:
                vtfunc_t vtfunc, void *par) {
 8001fd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001fd2:	4606      	mov	r6, r0
 8001fd4:	460f      	mov	r7, r1
 8001fd6:	4614      	mov	r4, r2
 8001fd8:	461d      	mov	r5, r3
  chDbgCheckClassI();
 8001fda:	f7ff fe31 	bl	8001c40 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8001fde:	b10e      	cbz	r6, 8001fe4 <chVTDoSetI+0x14>
 8001fe0:	b104      	cbz	r4, 8001fe4 <chVTDoSetI+0x14>
 8001fe2:	b917      	cbnz	r7, 8001fea <chVTDoSetI+0x1a>
 8001fe4:	4823      	ldr	r0, [pc, #140]	; (8002074 <chVTDoSetI+0xa4>)
 8001fe6:	f7fe fe1b 	bl	8000c20 <chSysHalt>
  vtp->par = par;
 8001fea:	6135      	str	r5, [r6, #16]
  vtp->func = vtfunc;
 8001fec:	60f4      	str	r4, [r6, #12]
 8001fee:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001ff2:	6a5d      	ldr	r5, [r3, #36]	; 0x24
    if (delay < (sysinterval_t)CH_CFG_ST_TIMEDELTA) {
 8001ff4:	2f01      	cmp	r7, #1
 8001ff6:	d90d      	bls.n	8002014 <chVTDoSetI+0x44>
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8001ff8:	4b1f      	ldr	r3, [pc, #124]	; (8002078 <chVTDoSetI+0xa8>)
 8001ffa:	f853 4f1c 	ldr.w	r4, [r3, #28]!
 8001ffe:	429c      	cmp	r4, r3
 8002000:	d00a      	beq.n	8002018 <chVTDoSetI+0x48>
    delta = chTimeDiffX(ch.vtlist.lasttime, now) + delay;
 8002002:	4b1d      	ldr	r3, [pc, #116]	; (8002078 <chVTDoSetI+0xa8>)
 8002004:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8002006:	1a2d      	subs	r5, r5, r0
    if (delta < chTimeDiffX(ch.vtlist.lasttime, now)) {
 8002008:	197d      	adds	r5, r7, r5
 800200a:	d313      	bcc.n	8002034 <chVTDoSetI+0x64>
      delta -= p->delta;
 800200c:	68a3      	ldr	r3, [r4, #8]
 800200e:	1aed      	subs	r5, r5, r3
      p = p->next;
 8002010:	6824      	ldr	r4, [r4, #0]
 8002012:	e019      	b.n	8002048 <chVTDoSetI+0x78>
      delay = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002014:	2702      	movs	r7, #2
 8002016:	e7ef      	b.n	8001ff8 <chVTDoSetI+0x28>
      ch.vtlist.lasttime = now;
 8002018:	4b17      	ldr	r3, [pc, #92]	; (8002078 <chVTDoSetI+0xa8>)
 800201a:	629d      	str	r5, [r3, #40]	; 0x28
      ch.vtlist.next = vtp;
 800201c:	61de      	str	r6, [r3, #28]
      ch.vtlist.prev = vtp;
 800201e:	621e      	str	r6, [r3, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8002020:	f103 021c 	add.w	r2, r3, #28
 8002024:	6032      	str	r2, [r6, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8002026:	6072      	str	r2, [r6, #4]
      vtp->delta = delay;
 8002028:	60b7      	str	r7, [r6, #8]
      port_timer_start_alarm(chTimeAddX(ch.vtlist.lasttime, delay));
 800202a:	6a98      	ldr	r0, [r3, #40]	; 0x28
  stStartAlarm(time);
 800202c:	4438      	add	r0, r7
 800202e:	f7ff f9bf 	bl	80013b0 <stStartAlarm>
 8002032:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    else if (delta < p->delta) {
 8002034:	68a3      	ldr	r3, [r4, #8]
 8002036:	429d      	cmp	r5, r3
 8002038:	d206      	bcs.n	8002048 <chVTDoSetI+0x78>
  stSetAlarm(time);
 800203a:	4428      	add	r0, r5
 800203c:	f7ff f918 	bl	8001270 <stSetAlarm>
 8002040:	e002      	b.n	8002048 <chVTDoSetI+0x78>
    delta -= p->delta;
 8002042:	68a3      	ldr	r3, [r4, #8]
 8002044:	1aed      	subs	r5, r5, r3
    p = p->next;
 8002046:	6824      	ldr	r4, [r4, #0]
  while (p->delta < delta) {
 8002048:	68a3      	ldr	r3, [r4, #8]
 800204a:	429d      	cmp	r5, r3
 800204c:	d904      	bls.n	8002058 <chVTDoSetI+0x88>
    chDbgAssert(p != vtp, "timer already armed");
 800204e:	42b4      	cmp	r4, r6
 8002050:	d1f7      	bne.n	8002042 <chVTDoSetI+0x72>
 8002052:	4808      	ldr	r0, [pc, #32]	; (8002074 <chVTDoSetI+0xa4>)
 8002054:	f7fe fde4 	bl	8000c20 <chSysHalt>
  vtp->next = p;
 8002058:	6034      	str	r4, [r6, #0]
  vtp->prev = vtp->next->prev;
 800205a:	6863      	ldr	r3, [r4, #4]
 800205c:	6073      	str	r3, [r6, #4]
  vtp->prev->next = vtp;
 800205e:	601e      	str	r6, [r3, #0]
  p->prev = vtp;
 8002060:	6066      	str	r6, [r4, #4]
  vtp->delta = delta;
 8002062:	60b5      	str	r5, [r6, #8]
  p->delta -= delta;
 8002064:	68a3      	ldr	r3, [r4, #8]
 8002066:	1b5d      	subs	r5, r3, r5
 8002068:	60a5      	str	r5, [r4, #8]
  ch.vtlist.delta = (sysinterval_t)-1;
 800206a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800206e:	4b02      	ldr	r3, [pc, #8]	; (8002078 <chVTDoSetI+0xa8>)
 8002070:	625a      	str	r2, [r3, #36]	; 0x24
 8002072:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8002074:	0800301c 	.word	0x0800301c
 8002078:	20000a50 	.word	0x20000a50
 800207c:	00000000 	.word	0x00000000

08002080 <chSchGoSleepTimeoutS>:
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8002080:	b530      	push	{r4, r5, lr}
 8002082:	b087      	sub	sp, #28
 8002084:	4605      	mov	r5, r0
 8002086:	460c      	mov	r4, r1
  chDbgCheckClassS();
 8002088:	f7ff fda2 	bl	8001bd0 <chDbgCheckClassS>
  if (TIME_INFINITE != timeout) {
 800208c:	f1b4 3fff 	cmp.w	r4, #4294967295	; 0xffffffff
 8002090:	d015      	beq.n	80020be <chSchGoSleepTimeoutS+0x3e>
    chVTDoSetI(&vt, timeout, wakeup, currp);
 8002092:	4b0d      	ldr	r3, [pc, #52]	; (80020c8 <chSchGoSleepTimeoutS+0x48>)
 8002094:	699b      	ldr	r3, [r3, #24]
 8002096:	4a0d      	ldr	r2, [pc, #52]	; (80020cc <chSchGoSleepTimeoutS+0x4c>)
 8002098:	4621      	mov	r1, r4
 800209a:	a801      	add	r0, sp, #4
 800209c:	f7ff ff98 	bl	8001fd0 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80020a0:	4628      	mov	r0, r5
 80020a2:	f7ff fda5 	bl	8001bf0 <chSchGoSleepS>
  chDbgCheckClassI();
 80020a6:	f7ff fdcb 	bl	8001c40 <chDbgCheckClassI>
  return (bool)(vtp->func != NULL);
 80020aa:	9b04      	ldr	r3, [sp, #16]
    if (chVTIsArmedI(&vt)) {
 80020ac:	b113      	cbz	r3, 80020b4 <chSchGoSleepTimeoutS+0x34>
      chVTDoResetI(&vt);
 80020ae:	a801      	add	r0, sp, #4
 80020b0:	f7ff ff3e 	bl	8001f30 <chVTDoResetI>
  return currp->u.rdymsg;
 80020b4:	4b04      	ldr	r3, [pc, #16]	; (80020c8 <chSchGoSleepTimeoutS+0x48>)
 80020b6:	699b      	ldr	r3, [r3, #24]
}
 80020b8:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80020ba:	b007      	add	sp, #28
 80020bc:	bd30      	pop	{r4, r5, pc}
    chSchGoSleepS(newstate);
 80020be:	4628      	mov	r0, r5
 80020c0:	f7ff fd96 	bl	8001bf0 <chSchGoSleepS>
 80020c4:	e7f6      	b.n	80020b4 <chSchGoSleepTimeoutS+0x34>
 80020c6:	bf00      	nop
 80020c8:	20000a50 	.word	0x20000a50
 80020cc:	080021b1 	.word	0x080021b1

080020d0 <_dbg_check_leave_isr>:
void _dbg_check_leave_isr(void) {
 80020d0:	b508      	push	{r3, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80020d2:	2320      	movs	r3, #32
 80020d4:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 80020d8:	4b08      	ldr	r3, [pc, #32]	; (80020fc <_dbg_check_leave_isr+0x2c>)
 80020da:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80020dc:	2b00      	cmp	r3, #0
 80020de:	dd02      	ble.n	80020e6 <_dbg_check_leave_isr+0x16>
 80020e0:	4b06      	ldr	r3, [pc, #24]	; (80020fc <_dbg_check_leave_isr+0x2c>)
 80020e2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80020e4:	b113      	cbz	r3, 80020ec <_dbg_check_leave_isr+0x1c>
    chSysHalt("SV#9");
 80020e6:	4806      	ldr	r0, [pc, #24]	; (8002100 <_dbg_check_leave_isr+0x30>)
 80020e8:	f7fe fd9a 	bl	8000c20 <chSysHalt>
  ch.dbg.isr_cnt--;
 80020ec:	4a03      	ldr	r2, [pc, #12]	; (80020fc <_dbg_check_leave_isr+0x2c>)
 80020ee:	6b13      	ldr	r3, [r2, #48]	; 0x30
 80020f0:	3b01      	subs	r3, #1
 80020f2:	6313      	str	r3, [r2, #48]	; 0x30
 80020f4:	2300      	movs	r3, #0
 80020f6:	f383 8811 	msr	BASEPRI, r3
 80020fa:	bd08      	pop	{r3, pc}
 80020fc:	20000a50 	.word	0x20000a50
 8002100:	080030ac 	.word	0x080030ac
	...

08002110 <_dbg_check_enter_isr>:
void _dbg_check_enter_isr(void) {
 8002110:	b508      	push	{r3, lr}
 8002112:	2320      	movs	r3, #32
 8002114:	f383 8811 	msr	BASEPRI, r3
  if ((ch.dbg.isr_cnt < (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002118:	4b08      	ldr	r3, [pc, #32]	; (800213c <_dbg_check_enter_isr+0x2c>)
 800211a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800211c:	2b00      	cmp	r3, #0
 800211e:	db02      	blt.n	8002126 <_dbg_check_enter_isr+0x16>
 8002120:	4b06      	ldr	r3, [pc, #24]	; (800213c <_dbg_check_enter_isr+0x2c>)
 8002122:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002124:	b113      	cbz	r3, 800212c <_dbg_check_enter_isr+0x1c>
    chSysHalt("SV#8");
 8002126:	4806      	ldr	r0, [pc, #24]	; (8002140 <_dbg_check_enter_isr+0x30>)
 8002128:	f7fe fd7a 	bl	8000c20 <chSysHalt>
  ch.dbg.isr_cnt++;
 800212c:	4a03      	ldr	r2, [pc, #12]	; (800213c <_dbg_check_enter_isr+0x2c>)
 800212e:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8002130:	3301      	adds	r3, #1
 8002132:	6313      	str	r3, [r2, #48]	; 0x30
 8002134:	2300      	movs	r3, #0
 8002136:	f383 8811 	msr	BASEPRI, r3
 800213a:	bd08      	pop	{r3, pc}
 800213c:	20000a50 	.word	0x20000a50
 8002140:	080030a4 	.word	0x080030a4
	...

08002150 <_dbg_check_unlock_from_isr>:
void _dbg_check_unlock_from_isr(void) {
 8002150:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002152:	4b07      	ldr	r3, [pc, #28]	; (8002170 <_dbg_check_unlock_from_isr+0x20>)
 8002154:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002156:	2b00      	cmp	r3, #0
 8002158:	dd07      	ble.n	800216a <_dbg_check_unlock_from_isr+0x1a>
 800215a:	4b05      	ldr	r3, [pc, #20]	; (8002170 <_dbg_check_unlock_from_isr+0x20>)
 800215c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800215e:	2b00      	cmp	r3, #0
 8002160:	dd03      	ble.n	800216a <_dbg_check_unlock_from_isr+0x1a>
  _dbg_leave_lock();
 8002162:	2200      	movs	r2, #0
 8002164:	4b02      	ldr	r3, [pc, #8]	; (8002170 <_dbg_check_unlock_from_isr+0x20>)
 8002166:	635a      	str	r2, [r3, #52]	; 0x34
 8002168:	bd08      	pop	{r3, pc}
    chSysHalt("SV#7");
 800216a:	4802      	ldr	r0, [pc, #8]	; (8002174 <_dbg_check_unlock_from_isr+0x24>)
 800216c:	f7fe fd58 	bl	8000c20 <chSysHalt>
 8002170:	20000a50 	.word	0x20000a50
 8002174:	080030cc 	.word	0x080030cc
	...

08002180 <_dbg_check_lock_from_isr>:
void _dbg_check_lock_from_isr(void) {
 8002180:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt <= (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002182:	4b07      	ldr	r3, [pc, #28]	; (80021a0 <_dbg_check_lock_from_isr+0x20>)
 8002184:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002186:	2b00      	cmp	r3, #0
 8002188:	dd02      	ble.n	8002190 <_dbg_check_lock_from_isr+0x10>
 800218a:	4b05      	ldr	r3, [pc, #20]	; (80021a0 <_dbg_check_lock_from_isr+0x20>)
 800218c:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800218e:	b113      	cbz	r3, 8002196 <_dbg_check_lock_from_isr+0x16>
    chSysHalt("SV#6");
 8002190:	4804      	ldr	r0, [pc, #16]	; (80021a4 <_dbg_check_lock_from_isr+0x24>)
 8002192:	f7fe fd45 	bl	8000c20 <chSysHalt>
  _dbg_enter_lock();
 8002196:	2201      	movs	r2, #1
 8002198:	4b01      	ldr	r3, [pc, #4]	; (80021a0 <_dbg_check_lock_from_isr+0x20>)
 800219a:	635a      	str	r2, [r3, #52]	; 0x34
 800219c:	bd08      	pop	{r3, pc}
 800219e:	bf00      	nop
 80021a0:	20000a50 	.word	0x20000a50
 80021a4:	080030bc 	.word	0x080030bc
	...

080021b0 <wakeup>:
static void wakeup(void *p) {
 80021b0:	b538      	push	{r3, r4, r5, lr}
 80021b2:	4604      	mov	r4, r0
 80021b4:	2320      	movs	r3, #32
 80021b6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock_from_isr();
 80021ba:	f7ff ffe1 	bl	8002180 <_dbg_check_lock_from_isr>
  switch (tp->state) {
 80021be:	f894 3020 	ldrb.w	r3, [r4, #32]
 80021c2:	2b07      	cmp	r3, #7
 80021c4:	d81b      	bhi.n	80021fe <wakeup+0x4e>
 80021c6:	e8df f003 	tbb	[pc, r3]
 80021ca:	1a04      	.short	0x1a04
 80021cc:	0e140a1a 	.word	0x0e140a1a
 80021d0:	141a      	.short	0x141a
  _dbg_check_unlock_from_isr();
 80021d2:	f7ff ffbd 	bl	8002150 <_dbg_check_unlock_from_isr>
 80021d6:	2300      	movs	r3, #0
 80021d8:	f383 8811 	msr	BASEPRI, r3
 80021dc:	bd38      	pop	{r3, r4, r5, pc}
    *tp->u.wttrp = NULL;
 80021de:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80021e0:	2200      	movs	r2, #0
 80021e2:	601a      	str	r2, [r3, #0]
 80021e4:	e00b      	b.n	80021fe <wakeup+0x4e>
    chSemFastSignalI(tp->u.wtsemp);
 80021e6:	6a65      	ldr	r5, [r4, #36]	; 0x24
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();
 80021e8:	f7ff fd2a 	bl	8001c40 <chDbgCheckClassI>

  sp->cnt++;
 80021ec:	68ab      	ldr	r3, [r5, #8]
 80021ee:	3301      	adds	r3, #1
 80021f0:	60ab      	str	r3, [r5, #8]
  tp->queue.prev->queue.next = tp->queue.next;
 80021f2:	6863      	ldr	r3, [r4, #4]
 80021f4:	6822      	ldr	r2, [r4, #0]
 80021f6:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80021f8:	6823      	ldr	r3, [r4, #0]
 80021fa:	6862      	ldr	r2, [r4, #4]
 80021fc:	605a      	str	r2, [r3, #4]
  tp->u.rdymsg = MSG_TIMEOUT;
 80021fe:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002202:	6263      	str	r3, [r4, #36]	; 0x24
  (void) chSchReadyI(tp);
 8002204:	4620      	mov	r0, r4
 8002206:	f7ff fe03 	bl	8001e10 <chSchReadyI>
 800220a:	f7ff ffa1 	bl	8002150 <_dbg_check_unlock_from_isr>
 800220e:	2300      	movs	r3, #0
 8002210:	f383 8811 	msr	BASEPRI, r3
 8002214:	bd38      	pop	{r3, r4, r5, pc}
 8002216:	bf00      	nop
	...

08002220 <_dbg_check_unlock>:
void _dbg_check_unlock(void) {
 8002220:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt <= (cnt_t)0)) {
 8002222:	4b07      	ldr	r3, [pc, #28]	; (8002240 <_dbg_check_unlock+0x20>)
 8002224:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002226:	b93b      	cbnz	r3, 8002238 <_dbg_check_unlock+0x18>
 8002228:	4b05      	ldr	r3, [pc, #20]	; (8002240 <_dbg_check_unlock+0x20>)
 800222a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800222c:	2b00      	cmp	r3, #0
 800222e:	dd03      	ble.n	8002238 <_dbg_check_unlock+0x18>
  _dbg_leave_lock();
 8002230:	2200      	movs	r2, #0
 8002232:	4b03      	ldr	r3, [pc, #12]	; (8002240 <_dbg_check_unlock+0x20>)
 8002234:	635a      	str	r2, [r3, #52]	; 0x34
 8002236:	bd08      	pop	{r3, pc}
    chSysHalt("SV#5");
 8002238:	4802      	ldr	r0, [pc, #8]	; (8002244 <_dbg_check_unlock+0x24>)
 800223a:	f7fe fcf1 	bl	8000c20 <chSysHalt>
 800223e:	bf00      	nop
 8002240:	20000a50 	.word	0x20000a50
 8002244:	080030c4 	.word	0x080030c4
	...

08002250 <chSysUnlock>:
static inline void chSysUnlock(void) {
 8002250:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8002252:	f7ff ffe5 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002256:	4b08      	ldr	r3, [pc, #32]	; (8002278 <chSysUnlock+0x28>)
 8002258:	681a      	ldr	r2, [r3, #0]
 800225a:	429a      	cmp	r2, r3
 800225c:	d004      	beq.n	8002268 <chSysUnlock+0x18>
 800225e:	699b      	ldr	r3, [r3, #24]
 8002260:	6899      	ldr	r1, [r3, #8]
 8002262:	6893      	ldr	r3, [r2, #8]
 8002264:	4299      	cmp	r1, r3
 8002266:	d303      	bcc.n	8002270 <chSysUnlock+0x20>
 8002268:	2300      	movs	r3, #0
 800226a:	f383 8811 	msr	BASEPRI, r3
 800226e:	bd08      	pop	{r3, pc}
 8002270:	4802      	ldr	r0, [pc, #8]	; (800227c <chSysUnlock+0x2c>)
 8002272:	f7fe fcd5 	bl	8000c20 <chSysHalt>
 8002276:	bf00      	nop
 8002278:	20000a50 	.word	0x20000a50
 800227c:	08002ff8 	.word	0x08002ff8

08002280 <_dbg_check_lock>:
void _dbg_check_lock(void) {
 8002280:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002282:	4b06      	ldr	r3, [pc, #24]	; (800229c <_dbg_check_lock+0x1c>)
 8002284:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002286:	b913      	cbnz	r3, 800228e <_dbg_check_lock+0xe>
 8002288:	4b04      	ldr	r3, [pc, #16]	; (800229c <_dbg_check_lock+0x1c>)
 800228a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800228c:	b113      	cbz	r3, 8002294 <_dbg_check_lock+0x14>
    chSysHalt("SV#4");
 800228e:	4804      	ldr	r0, [pc, #16]	; (80022a0 <_dbg_check_lock+0x20>)
 8002290:	f7fe fcc6 	bl	8000c20 <chSysHalt>
  _dbg_enter_lock();
 8002294:	2201      	movs	r2, #1
 8002296:	4b01      	ldr	r3, [pc, #4]	; (800229c <_dbg_check_lock+0x1c>)
 8002298:	635a      	str	r2, [r3, #52]	; 0x34
 800229a:	bd08      	pop	{r3, pc}
 800229c:	20000a50 	.word	0x20000a50
 80022a0:	080030b4 	.word	0x080030b4
	...

080022b0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 80022b0:	b510      	push	{r4, lr}
 80022b2:	4604      	mov	r4, r0
 80022b4:	2320      	movs	r3, #32
 80022b6:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80022ba:	f7ff ffe1 	bl	8002280 <_dbg_check_lock>
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {

  chDbgCheck(ticks != TIME_IMMEDIATE);
 80022be:	b194      	cbz	r4, 80022e6 <chThdSleep+0x36>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 80022c0:	4621      	mov	r1, r4
 80022c2:	2008      	movs	r0, #8
 80022c4:	f7ff fedc 	bl	8002080 <chSchGoSleepTimeoutS>
  _dbg_check_unlock();
 80022c8:	f7ff ffaa 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80022cc:	4b09      	ldr	r3, [pc, #36]	; (80022f4 <chThdSleep+0x44>)
 80022ce:	681a      	ldr	r2, [r3, #0]
 80022d0:	429a      	cmp	r2, r3
 80022d2:	d004      	beq.n	80022de <chThdSleep+0x2e>
 80022d4:	699b      	ldr	r3, [r3, #24]
 80022d6:	6899      	ldr	r1, [r3, #8]
 80022d8:	6893      	ldr	r3, [r2, #8]
 80022da:	4299      	cmp	r1, r3
 80022dc:	d306      	bcc.n	80022ec <chThdSleep+0x3c>
 80022de:	2300      	movs	r3, #0
 80022e0:	f383 8811 	msr	BASEPRI, r3
 80022e4:	bd10      	pop	{r4, pc}
  chDbgCheck(ticks != TIME_IMMEDIATE);
 80022e6:	4804      	ldr	r0, [pc, #16]	; (80022f8 <chThdSleep+0x48>)
 80022e8:	f7fe fc9a 	bl	8000c20 <chSysHalt>
 80022ec:	4803      	ldr	r0, [pc, #12]	; (80022fc <chThdSleep+0x4c>)
 80022ee:	f7fe fc97 	bl	8000c20 <chSysHalt>
 80022f2:	bf00      	nop
 80022f4:	20000a50 	.word	0x20000a50
 80022f8:	08003004 	.word	0x08003004
 80022fc:	08002ff8 	.word	0x08002ff8

08002300 <chThdExit>:
void chThdExit(msg_t msg) {
 8002300:	b508      	push	{r3, lr}
 8002302:	4604      	mov	r4, r0
 8002304:	2320      	movs	r3, #32
 8002306:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 800230a:	f7ff ffb9 	bl	8002280 <_dbg_check_lock>
  chThdExitS(msg);
 800230e:	4620      	mov	r0, r4
 8002310:	f7ff fda6 	bl	8001e60 <chThdExitS>
	...

08002320 <chThdRelease>:
void chThdRelease(thread_t *tp) {
 8002320:	b510      	push	{r4, lr}
 8002322:	4604      	mov	r4, r0
 8002324:	2320      	movs	r3, #32
 8002326:	f383 8811 	msr	BASEPRI, r3
 800232a:	f7ff ffa9 	bl	8002280 <_dbg_check_lock>
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 800232e:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8002332:	b1c3      	cbz	r3, 8002366 <chThdRelease+0x46>
  tp->refs--;
 8002334:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8002338:	3b01      	subs	r3, #1
 800233a:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 800233e:	6a23      	ldr	r3, [r4, #32]
 8002340:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8002344:	2b0f      	cmp	r3, #15
 8002346:	d011      	beq.n	800236c <chThdRelease+0x4c>
  _dbg_check_unlock();
 8002348:	f7ff ff6a 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800234c:	4b1d      	ldr	r3, [pc, #116]	; (80023c4 <chThdRelease+0xa4>)
 800234e:	681a      	ldr	r2, [r3, #0]
 8002350:	429a      	cmp	r2, r3
 8002352:	d004      	beq.n	800235e <chThdRelease+0x3e>
 8002354:	699b      	ldr	r3, [r3, #24]
 8002356:	6899      	ldr	r1, [r3, #8]
 8002358:	6893      	ldr	r3, [r2, #8]
 800235a:	4299      	cmp	r1, r3
 800235c:	d32f      	bcc.n	80023be <chThdRelease+0x9e>
 800235e:	2300      	movs	r3, #0
 8002360:	f383 8811 	msr	BASEPRI, r3
 8002364:	bd10      	pop	{r4, pc}
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
 8002366:	4818      	ldr	r0, [pc, #96]	; (80023c8 <chThdRelease+0xa8>)
 8002368:	f7fe fc5a 	bl	8000c20 <chSysHalt>
    REG_REMOVE(tp);
 800236c:	6963      	ldr	r3, [r4, #20]
 800236e:	6922      	ldr	r2, [r4, #16]
 8002370:	611a      	str	r2, [r3, #16]
 8002372:	6923      	ldr	r3, [r4, #16]
 8002374:	6962      	ldr	r2, [r4, #20]
 8002376:	615a      	str	r2, [r3, #20]
  _dbg_check_unlock();
 8002378:	f7ff ff52 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 800237c:	4b11      	ldr	r3, [pc, #68]	; (80023c4 <chThdRelease+0xa4>)
 800237e:	681a      	ldr	r2, [r3, #0]
 8002380:	429a      	cmp	r2, r3
 8002382:	d004      	beq.n	800238e <chThdRelease+0x6e>
 8002384:	699b      	ldr	r3, [r3, #24]
 8002386:	6899      	ldr	r1, [r3, #8]
 8002388:	6893      	ldr	r3, [r2, #8]
 800238a:	4299      	cmp	r1, r3
 800238c:	d30b      	bcc.n	80023a6 <chThdRelease+0x86>
 800238e:	2300      	movs	r3, #0
 8002390:	f383 8811 	msr	BASEPRI, r3
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8002394:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 8002398:	f003 0303 	and.w	r3, r3, #3
 800239c:	2b01      	cmp	r3, #1
 800239e:	d005      	beq.n	80023ac <chThdRelease+0x8c>
 80023a0:	2b02      	cmp	r3, #2
 80023a2:	d007      	beq.n	80023b4 <chThdRelease+0x94>
 80023a4:	bd10      	pop	{r4, pc}
 80023a6:	4809      	ldr	r0, [pc, #36]	; (80023cc <chThdRelease+0xac>)
 80023a8:	f7fe fc3a 	bl	8000c20 <chSysHalt>
      chHeapFree(chThdGetWorkingAreaX(tp));
 80023ac:	69e0      	ldr	r0, [r4, #28]
 80023ae:	f000 fbc7 	bl	8002b40 <chHeapFree>
 80023b2:	bd10      	pop	{r4, pc}
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 80023b4:	69e1      	ldr	r1, [r4, #28]
 80023b6:	6c20      	ldr	r0, [r4, #64]	; 0x40
 80023b8:	f000 faf2 	bl	80029a0 <chPoolFree>
 80023bc:	bd10      	pop	{r4, pc}
 80023be:	4803      	ldr	r0, [pc, #12]	; (80023cc <chThdRelease+0xac>)
 80023c0:	f7fe fc2e 	bl	8000c20 <chSysHalt>
 80023c4:	20000a50 	.word	0x20000a50
 80023c8:	08003080 	.word	0x08003080
 80023cc:	08002ff8 	.word	0x08002ff8

080023d0 <chThdCreate>:
thread_t *chThdCreate(const thread_descriptor_t *tdp) {
 80023d0:	b510      	push	{r4, lr}
 80023d2:	4604      	mov	r4, r0
  chDbgAssert(chRegFindThreadByWorkingArea(tdp->wbase) == NULL,
 80023d4:	6840      	ldr	r0, [r0, #4]
 80023d6:	f000 fc73 	bl	8002cc0 <chRegFindThreadByWorkingArea>
 80023da:	b110      	cbz	r0, 80023e2 <chThdCreate+0x12>
 80023dc:	480b      	ldr	r0, [pc, #44]	; (800240c <chThdCreate+0x3c>)
 80023de:	f7fe fc1f 	bl	8000c20 <chSysHalt>
  _thread_memfill((uint8_t *)tdp->wbase,
 80023e2:	2255      	movs	r2, #85	; 0x55
 80023e4:	68a1      	ldr	r1, [r4, #8]
 80023e6:	6860      	ldr	r0, [r4, #4]
 80023e8:	f7ff fad2 	bl	8001990 <_thread_memfill>
 80023ec:	2320      	movs	r3, #32
 80023ee:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80023f2:	f7ff ff45 	bl	8002280 <_dbg_check_lock>
  tp = chThdCreateSuspendedI(tdp);
 80023f6:	4620      	mov	r0, r4
 80023f8:	f7ff fc3a 	bl	8001c70 <chThdCreateSuspendedI>
 80023fc:	4604      	mov	r4, r0
  chSchWakeupS(tp, MSG_OK);
 80023fe:	2100      	movs	r1, #0
 8002400:	f7ff fd56 	bl	8001eb0 <chSchWakeupS>
  chSysUnlock();
 8002404:	f7ff ff24 	bl	8002250 <chSysUnlock>
}
 8002408:	4620      	mov	r0, r4
 800240a:	bd10      	pop	{r4, pc}
 800240c:	08003064 	.word	0x08003064

08002410 <_dbg_check_enable>:
void _dbg_check_enable(void) {
 8002410:	b508      	push	{r3, lr}
  if ((ch.dbg.isr_cnt != (cnt_t)0) || (ch.dbg.lock_cnt != (cnt_t)0)) {
 8002412:	4b05      	ldr	r3, [pc, #20]	; (8002428 <_dbg_check_enable+0x18>)
 8002414:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8002416:	b913      	cbnz	r3, 800241e <_dbg_check_enable+0xe>
 8002418:	4b03      	ldr	r3, [pc, #12]	; (8002428 <_dbg_check_enable+0x18>)
 800241a:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800241c:	b113      	cbz	r3, 8002424 <_dbg_check_enable+0x14>
    chSysHalt("SV#3");
 800241e:	4803      	ldr	r0, [pc, #12]	; (800242c <_dbg_check_enable+0x1c>)
 8002420:	f7fe fbfe 	bl	8000c20 <chSysHalt>
 8002424:	bd08      	pop	{r3, pc}
 8002426:	bf00      	nop
 8002428:	20000a50 	.word	0x20000a50
 800242c:	0800309c 	.word	0x0800309c

08002430 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8002430:	b430      	push	{r4, r5}
 8002432:	4b0e      	ldr	r3, [pc, #56]	; (800246c <chTMStopMeasurementX+0x3c>)
 8002434:	685b      	ldr	r3, [r3, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8002436:	4a0e      	ldr	r2, [pc, #56]	; (8002470 <chTMStopMeasurementX+0x40>)
 8002438:	f8d2 1884 	ldr.w	r1, [r2, #2180]	; 0x884
  tmp->n++;
 800243c:	68c2      	ldr	r2, [r0, #12]
 800243e:	3201      	adds	r2, #1
 8002440:	60c2      	str	r2, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
 8002442:	6882      	ldr	r2, [r0, #8]
 8002444:	1a9b      	subs	r3, r3, r2
 8002446:	1a5b      	subs	r3, r3, r1
 8002448:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 800244a:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
 800244e:	18e4      	adds	r4, r4, r3
 8002450:	f145 0500 	adc.w	r5, r5, #0
 8002454:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
 8002458:	6842      	ldr	r2, [r0, #4]
 800245a:	4293      	cmp	r3, r2
 800245c:	d900      	bls.n	8002460 <chTMStopMeasurementX+0x30>
    tmp->worst = tmp->last;
 800245e:	6043      	str	r3, [r0, #4]
  if (tmp->last < tmp->best) {
 8002460:	6802      	ldr	r2, [r0, #0]
 8002462:	4293      	cmp	r3, r2
 8002464:	d200      	bcs.n	8002468 <chTMStopMeasurementX+0x38>
    tmp->best = tmp->last;
 8002466:	6003      	str	r3, [r0, #0]
}
 8002468:	bc30      	pop	{r4, r5}
 800246a:	4770      	bx	lr
 800246c:	e0001000 	.word	0xe0001000
 8002470:	20000a50 	.word	0x20000a50
	...

08002480 <chTMStartMeasurementX>:
 8002480:	4b01      	ldr	r3, [pc, #4]	; (8002488 <chTMStartMeasurementX+0x8>)
 8002482:	685b      	ldr	r3, [r3, #4]
  tmp->last = chSysGetRealtimeCounterX();
 8002484:	6083      	str	r3, [r0, #8]
 8002486:	4770      	bx	lr
 8002488:	e0001000 	.word	0xe0001000
 800248c:	00000000 	.word	0x00000000

08002490 <chTMObjectInit>:
  tmp->best       = (rtcnt_t)-1;
 8002490:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002494:	6003      	str	r3, [r0, #0]
  tmp->worst      = (rtcnt_t)0;
 8002496:	2300      	movs	r3, #0
 8002498:	6043      	str	r3, [r0, #4]
  tmp->last       = (rtcnt_t)0;
 800249a:	6083      	str	r3, [r0, #8]
  tmp->n          = (ucnt_t)0;
 800249c:	60c3      	str	r3, [r0, #12]
  tmp->cumulative = (rttime_t)0;
 800249e:	2200      	movs	r2, #0
 80024a0:	2300      	movs	r3, #0
 80024a2:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80024a6:	4770      	bx	lr
	...

080024b0 <app_main>:
  sdStart(&SD2, &ser_cfg);
  pwm_init();
}

static void app_main(void) 
{
 80024b0:	b508      	push	{r3, lr}
  //*/

  // Begin main loop
  while (true)
  {
    chThdSleepMilliseconds(1000);
 80024b2:	f242 7010 	movw	r0, #10000	; 0x2710
 80024b6:	f7ff fefb 	bl	80022b0 <chThdSleep>
 80024ba:	e7fa      	b.n	80024b2 <app_main+0x2>
 80024bc:	0000      	movs	r0, r0
	...

080024c0 <pwm_init>:
};
//*/

//*
void pwm_init(void)
{
 80024c0:	b510      	push	{r4, lr}
  pwmStart(&PWMD1, &pwmcfg);
 80024c2:	4c16      	ldr	r4, [pc, #88]	; (800251c <pwm_init+0x5c>)
 80024c4:	4916      	ldr	r1, [pc, #88]	; (8002520 <pwm_init+0x60>)
 80024c6:	4620      	mov	r0, r4
 80024c8:	f7ff f89a 	bl	8001600 <pwmStart>
  pwmEnablePeriodicNotification(&PWMD1);
 80024cc:	4620      	mov	r0, r4
 80024ce:	f7ff f84f 	bl	8001570 <pwmEnablePeriodicNotification>
  
  palSetPadMode(GPIOA, 8, PAL_MODE_ALTERNATE(1));
 80024d2:	2282      	movs	r2, #130	; 0x82
 80024d4:	f44f 7180 	mov.w	r1, #256	; 0x100
 80024d8:	4812      	ldr	r0, [pc, #72]	; (8002524 <pwm_init+0x64>)
 80024da:	f7fe fe51 	bl	8001180 <_pal_lld_setgroupmode>
  chThdSleepMilliseconds(2000);
 80024de:	f644 6020 	movw	r0, #20000	; 0x4e20
 80024e2:	f7ff fee5 	bl	80022b0 <chThdSleep>

  // Changes the PWM channel 0 to 50% duty cycle.
  pwmEnableChannel(&PWMD1, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD1, 5000));
 80024e6:	68a3      	ldr	r3, [r4, #8]
 80024e8:	f241 3288 	movw	r2, #5000	; 0x1388
 80024ec:	fb02 f203 	mul.w	r2, r2, r3
 80024f0:	4b0d      	ldr	r3, [pc, #52]	; (8002528 <pwm_init+0x68>)
 80024f2:	fba3 3202 	umull	r3, r2, r3, r2
 80024f6:	0b52      	lsrs	r2, r2, #13
 80024f8:	2100      	movs	r1, #0
 80024fa:	4620      	mov	r0, r4
 80024fc:	f7ff f858 	bl	80015b0 <pwmEnableChannel>
  pwmEnableChannelNotification(&PWMD1, 0);
 8002500:	2100      	movs	r1, #0
 8002502:	4620      	mov	r0, r4
 8002504:	f7ff f804 	bl	8001510 <pwmEnableChannelNotification>
  chThdSleepMilliseconds(5000);
 8002508:	f24c 3050 	movw	r0, #50000	; 0xc350
 800250c:	f7ff fed0 	bl	80022b0 <chThdSleep>

  // Changes PWM period to half second the duty cycle becomes 50%
  // implicitly.
 // pwmChangePeriod(&PWMD1, 5000);
  chThdSleepMilliseconds(5000);
 8002510:	f24c 3050 	movw	r0, #50000	; 0xc350
 8002514:	f7ff fecc 	bl	80022b0 <chThdSleep>
 8002518:	bd10      	pop	{r4, pc}
 800251a:	bf00      	nop
 800251c:	200009b8 	.word	0x200009b8
 8002520:	20000800 	.word	0x20000800
 8002524:	40020000 	.word	0x40020000
 8002528:	d1b71759 	.word	0xd1b71759
 800252c:	00000000 	.word	0x00000000

08002530 <app_init>:
{
 8002530:	b508      	push	{r3, lr}
  sdStart(&SD2, &ser_cfg);
 8002532:	4903      	ldr	r1, [pc, #12]	; (8002540 <app_init+0x10>)
 8002534:	4803      	ldr	r0, [pc, #12]	; (8002544 <app_init+0x14>)
 8002536:	f7fe ff9b 	bl	8001470 <sdStart>
  pwm_init();
 800253a:	f7ff ffc1 	bl	80024c0 <pwm_init>
 800253e:	bd08      	pop	{r3, pc}
 8002540:	20000834 	.word	0x20000834
 8002544:	200009d4 	.word	0x200009d4
	...

08002550 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8002550:	b510      	push	{r4, lr}

  chDbgCheck((mp != NULL) &&
 8002552:	b140      	cbz	r0, 8002566 <chPoolObjectInitAligned+0x16>
 8002554:	4604      	mov	r4, r0
 8002556:	2903      	cmp	r1, #3
 8002558:	d905      	bls.n	8002566 <chPoolObjectInitAligned+0x16>
 800255a:	2a03      	cmp	r2, #3
 800255c:	d903      	bls.n	8002566 <chPoolObjectInitAligned+0x16>
 800255e:	b112      	cbz	r2, 8002566 <chPoolObjectInitAligned+0x16>
 8002560:	1e50      	subs	r0, r2, #1
 8002562:	4210      	tst	r0, r2
 8002564:	d002      	beq.n	800256c <chPoolObjectInitAligned+0x1c>
 8002566:	4804      	ldr	r0, [pc, #16]	; (8002578 <chPoolObjectInitAligned+0x28>)
 8002568:	f7fe fb5a 	bl	8000c20 <chSysHalt>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 800256c:	2000      	movs	r0, #0
 800256e:	6020      	str	r0, [r4, #0]
  mp->object_size = size;
 8002570:	6061      	str	r1, [r4, #4]
  mp->align = align;
 8002572:	60a2      	str	r2, [r4, #8]
  mp->provider = provider;
 8002574:	60e3      	str	r3, [r4, #12]
 8002576:	bd10      	pop	{r4, pc}
 8002578:	08003148 	.word	0x08003148
 800257c:	00000000 	.word	0x00000000

08002580 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8002580:	b508      	push	{r3, lr}

  chDbgCheck(mp != NULL);
 8002582:	b128      	cbz	r0, 8002590 <chMtxObjectInit+0x10>
 8002584:	4603      	mov	r3, r0
  tqp->next = (thread_t *)tqp;
 8002586:	6018      	str	r0, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002588:	6058      	str	r0, [r3, #4]

  queue_init(&mp->queue);
  mp->owner = NULL;
 800258a:	2200      	movs	r2, #0
 800258c:	6082      	str	r2, [r0, #8]
 800258e:	bd08      	pop	{r3, pc}
  chDbgCheck(mp != NULL);
 8002590:	4801      	ldr	r0, [pc, #4]	; (8002598 <chMtxObjectInit+0x18>)
 8002592:	f7fe fb45 	bl	8000c20 <chSysHalt>
 8002596:	bf00      	nop
 8002598:	08003138 	.word	0x08003138
 800259c:	00000000 	.word	0x00000000

080025a0 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 80025a0:	b538      	push	{r3, r4, r5, lr}
 80025a2:	4604      	mov	r4, r0
 80025a4:	460d      	mov	r5, r1
  struct pool_header *php = objp;

  chDbgCheckClassI();
 80025a6:	f7ff fb4b 	bl	8001c40 <chDbgCheckClassI>
  chDbgCheck((mp != NULL) &&
 80025aa:	b124      	cbz	r4, 80025b6 <chPoolFreeI+0x16>
 80025ac:	b11d      	cbz	r5, 80025b6 <chPoolFreeI+0x16>
 80025ae:	68a3      	ldr	r3, [r4, #8]
 80025b0:	3b01      	subs	r3, #1
 80025b2:	421d      	tst	r5, r3
 80025b4:	d002      	beq.n	80025bc <chPoolFreeI+0x1c>
 80025b6:	4803      	ldr	r0, [pc, #12]	; (80025c4 <chPoolFreeI+0x24>)
 80025b8:	f7fe fb32 	bl	8000c20 <chSysHalt>
             (objp != NULL) &&
             MEM_IS_ALIGNED(objp, mp->align));

  php->next = mp->next;
 80025bc:	6823      	ldr	r3, [r4, #0]
 80025be:	602b      	str	r3, [r5, #0]
  mp->next = php;
 80025c0:	6025      	str	r5, [r4, #0]
 80025c2:	bd38      	pop	{r3, r4, r5, pc}
 80025c4:	08003180 	.word	0x08003180
	...

080025d0 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 80025d0:	b570      	push	{r4, r5, r6, lr}
 80025d2:	4604      	mov	r4, r0
 80025d4:	460d      	mov	r5, r1
 80025d6:	4616      	mov	r6, r2
  uint8_t *p, *prev;

  chDbgCheckClassI();
 80025d8:	f7ff fb32 	bl	8001c40 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 80025dc:	b115      	cbz	r5, 80025e4 <chCoreAllocFromTopI+0x14>
 80025de:	1e6b      	subs	r3, r5, #1
 80025e0:	422b      	tst	r3, r5
 80025e2:	d002      	beq.n	80025ea <chCoreAllocFromTopI+0x1a>
 80025e4:	480a      	ldr	r0, [pc, #40]	; (8002610 <chCoreAllocFromTopI+0x40>)
 80025e6:	f7fe fb1b 	bl	8000c20 <chSysHalt>

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 80025ea:	4b0a      	ldr	r3, [pc, #40]	; (8002614 <chCoreAllocFromTopI+0x44>)
 80025ec:	6859      	ldr	r1, [r3, #4]
 80025ee:	1b08      	subs	r0, r1, r4
 80025f0:	426d      	negs	r5, r5
 80025f2:	4028      	ands	r0, r5
  prev = p - offset;
 80025f4:	1b86      	subs	r6, r0, r6

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 80025f6:	681b      	ldr	r3, [r3, #0]
 80025f8:	429e      	cmp	r6, r3
 80025fa:	d304      	bcc.n	8002606 <chCoreAllocFromTopI+0x36>
 80025fc:	42b1      	cmp	r1, r6
 80025fe:	d304      	bcc.n	800260a <chCoreAllocFromTopI+0x3a>
    return NULL;
  }

  ch_memcore.topmem = prev;
 8002600:	4b04      	ldr	r3, [pc, #16]	; (8002614 <chCoreAllocFromTopI+0x44>)
 8002602:	605e      	str	r6, [r3, #4]
 8002604:	bd70      	pop	{r4, r5, r6, pc}
    return NULL;
 8002606:	2000      	movs	r0, #0
 8002608:	bd70      	pop	{r4, r5, r6, pc}
 800260a:	2000      	movs	r0, #0

  return p;
}
 800260c:	bd70      	pop	{r4, r5, r6, pc}
 800260e:	bf00      	nop
 8002610:	0800316c 	.word	0x0800316c
 8002614:	20001320 	.word	0x20001320
	...

08002620 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8002620:	b508      	push	{r3, lr}

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8002622:	2200      	movs	r2, #0
 8002624:	f7ff ffd4 	bl	80025d0 <chCoreAllocFromTopI>
}
 8002628:	bd08      	pop	{r3, pc}
 800262a:	bf00      	nop
 800262c:	0000      	movs	r0, r0
	...

08002630 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8002630:	b538      	push	{r3, r4, r5, lr}
 8002632:	4604      	mov	r4, r0
 8002634:	460d      	mov	r5, r1

  chDbgCheckClassI();
 8002636:	f7ff fb03 	bl	8001c40 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800263a:	b14c      	cbz	r4, 8002650 <chEvtSignalI+0x20>

  tp->epending |= events;
 800263c:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800263e:	4329      	orrs	r1, r5
 8002640:	6361      	str	r1, [r4, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002642:	f894 3020 	ldrb.w	r3, [r4, #32]
 8002646:	2b0a      	cmp	r3, #10
 8002648:	d005      	beq.n	8002656 <chEvtSignalI+0x26>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 800264a:	2b0b      	cmp	r3, #11
 800264c:	d00c      	beq.n	8002668 <chEvtSignalI+0x38>
 800264e:	bd38      	pop	{r3, r4, r5, pc}
  chDbgCheck(tp != NULL);
 8002650:	4807      	ldr	r0, [pc, #28]	; (8002670 <chEvtSignalI+0x40>)
 8002652:	f7fe fae5 	bl	8000c20 <chSysHalt>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8002656:	6a62      	ldr	r2, [r4, #36]	; 0x24
  if (((tp->state == CH_STATE_WTOREVT) &&
 8002658:	4211      	tst	r1, r2
 800265a:	d0f6      	beq.n	800264a <chEvtSignalI+0x1a>
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 800265c:	2300      	movs	r3, #0
 800265e:	6263      	str	r3, [r4, #36]	; 0x24
    (void) chSchReadyI(tp);
 8002660:	4620      	mov	r0, r4
 8002662:	f7ff fbd5 	bl	8001e10 <chSchReadyI>
 8002666:	e7f2      	b.n	800264e <chEvtSignalI+0x1e>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8002668:	6a63      	ldr	r3, [r4, #36]	; 0x24
      ((tp->state == CH_STATE_WTANDEVT) &&
 800266a:	438b      	bics	r3, r1
 800266c:	d1ef      	bne.n	800264e <chEvtSignalI+0x1e>
 800266e:	e7f5      	b.n	800265c <chEvtSignalI+0x2c>
 8002670:	080031bc 	.word	0x080031bc
	...

08002680 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8002680:	b570      	push	{r4, r5, r6, lr}
 8002682:	4605      	mov	r5, r0
  thread_t *ctp = currp;
 8002684:	4b39      	ldr	r3, [pc, #228]	; (800276c <chMtxLockS+0xec>)
 8002686:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
 8002688:	f7ff faa2 	bl	8001bd0 <chDbgCheckClassS>
  chDbgCheck(mp != NULL);
 800268c:	b33d      	cbz	r5, 80026de <chMtxLockS+0x5e>

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 800268e:	68a8      	ldr	r0, [r5, #8]
 8002690:	2800      	cmp	r0, #0
 8002692:	d065      	beq.n	8002760 <chMtxLockS+0xe0>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8002694:	6882      	ldr	r2, [r0, #8]
 8002696:	68a3      	ldr	r3, [r4, #8]
 8002698:	429a      	cmp	r2, r3
 800269a:	d208      	bcs.n	80026ae <chMtxLockS+0x2e>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 800269c:	6083      	str	r3, [r0, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800269e:	f890 3020 	ldrb.w	r3, [r0, #32]
 80026a2:	2b06      	cmp	r3, #6
 80026a4:	d01e      	beq.n	80026e4 <chMtxLockS+0x64>
 80026a6:	2b07      	cmp	r3, #7
 80026a8:	d033      	beq.n	8002712 <chMtxLockS+0x92>
 80026aa:	2b00      	cmp	r3, #0
 80026ac:	d046      	beq.n	800273c <chMtxLockS+0xbc>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
 80026ae:	4628      	mov	r0, r5
  thread_t *cp = (thread_t *)tqp;
 80026b0:	462b      	mov	r3, r5
    cp = cp->queue.next;
 80026b2:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80026b4:	4298      	cmp	r0, r3
 80026b6:	d003      	beq.n	80026c0 <chMtxLockS+0x40>
 80026b8:	6899      	ldr	r1, [r3, #8]
 80026ba:	68a2      	ldr	r2, [r4, #8]
 80026bc:	4291      	cmp	r1, r2
 80026be:	d2f8      	bcs.n	80026b2 <chMtxLockS+0x32>
  tp->queue.next             = cp;
 80026c0:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
 80026c2:	685a      	ldr	r2, [r3, #4]
 80026c4:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
 80026c6:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80026c8:	605c      	str	r4, [r3, #4]
      ctp->u.wtmtxp = mp;
 80026ca:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 80026cc:	2006      	movs	r0, #6
 80026ce:	f7ff fa8f 	bl	8001bf0 <chSchGoSleepS>

      /* It is assumed that the thread performing the unlock operation assigns
         the mutex to this thread.*/
      chDbgAssert(mp->owner == ctp, "not owner");
 80026d2:	68ab      	ldr	r3, [r5, #8]
 80026d4:	429c      	cmp	r4, r3
 80026d6:	d03d      	beq.n	8002754 <chMtxLockS+0xd4>
 80026d8:	4825      	ldr	r0, [pc, #148]	; (8002770 <chMtxLockS+0xf0>)
 80026da:	f7fe faa1 	bl	8000c20 <chSysHalt>
  chDbgCheck(mp != NULL);
 80026de:	4824      	ldr	r0, [pc, #144]	; (8002770 <chMtxLockS+0xf0>)
 80026e0:	f7fe fa9e 	bl	8000c20 <chSysHalt>
  tp->queue.prev->queue.next = tp->queue.next;
 80026e4:	6843      	ldr	r3, [r0, #4]
 80026e6:	6802      	ldr	r2, [r0, #0]
 80026e8:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80026ea:	6803      	ldr	r3, [r0, #0]
 80026ec:	6842      	ldr	r2, [r0, #4]
 80026ee:	605a      	str	r2, [r3, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 80026f0:	6a46      	ldr	r6, [r0, #36]	; 0x24
  thread_t *cp = (thread_t *)tqp;
 80026f2:	4633      	mov	r3, r6
    cp = cp->queue.next;
 80026f4:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80026f6:	429e      	cmp	r6, r3
 80026f8:	d003      	beq.n	8002702 <chMtxLockS+0x82>
 80026fa:	6899      	ldr	r1, [r3, #8]
 80026fc:	6882      	ldr	r2, [r0, #8]
 80026fe:	4291      	cmp	r1, r2
 8002700:	d2f8      	bcs.n	80026f4 <chMtxLockS+0x74>
  tp->queue.next             = cp;
 8002702:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8002704:	685a      	ldr	r2, [r3, #4]
 8002706:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8002708:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 800270a:	6058      	str	r0, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 800270c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800270e:	6898      	ldr	r0, [r3, #8]
 8002710:	e7c0      	b.n	8002694 <chMtxLockS+0x14>
  tp->queue.prev->queue.next = tp->queue.next;
 8002712:	6843      	ldr	r3, [r0, #4]
 8002714:	6802      	ldr	r2, [r0, #0]
 8002716:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8002718:	6803      	ldr	r3, [r0, #0]
 800271a:	6842      	ldr	r2, [r0, #4]
 800271c:	605a      	str	r2, [r3, #4]
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800271e:	6a46      	ldr	r6, [r0, #36]	; 0x24
  thread_t *cp = (thread_t *)tqp;
 8002720:	4633      	mov	r3, r6
    cp = cp->queue.next;
 8002722:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8002724:	429e      	cmp	r6, r3
 8002726:	d003      	beq.n	8002730 <chMtxLockS+0xb0>
 8002728:	6899      	ldr	r1, [r3, #8]
 800272a:	6882      	ldr	r2, [r0, #8]
 800272c:	4291      	cmp	r1, r2
 800272e:	d2f8      	bcs.n	8002722 <chMtxLockS+0xa2>
  tp->queue.next             = cp;
 8002730:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
 8002732:	685a      	ldr	r2, [r3, #4]
 8002734:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
 8002736:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8002738:	6058      	str	r0, [r3, #4]
 800273a:	e7b8      	b.n	80026ae <chMtxLockS+0x2e>
          tp->state = CH_STATE_CURRENT;
 800273c:	2301      	movs	r3, #1
 800273e:	f880 3020 	strb.w	r3, [r0, #32]
  tp->queue.prev->queue.next = tp->queue.next;
 8002742:	6843      	ldr	r3, [r0, #4]
 8002744:	6802      	ldr	r2, [r0, #0]
 8002746:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8002748:	6803      	ldr	r3, [r0, #0]
 800274a:	6842      	ldr	r2, [r0, #4]
 800274c:	605a      	str	r2, [r3, #4]
          (void) chSchReadyI(queue_dequeue(tp));
 800274e:	f7ff fb5f 	bl	8001e10 <chSchReadyI>
 8002752:	e7ac      	b.n	80026ae <chMtxLockS+0x2e>
      chDbgAssert(ctp->mtxlist == mp, "not owned");
 8002754:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002756:	429d      	cmp	r5, r3
 8002758:	d006      	beq.n	8002768 <chMtxLockS+0xe8>
 800275a:	4805      	ldr	r0, [pc, #20]	; (8002770 <chMtxLockS+0xf0>)
 800275c:	f7fe fa60 	bl	8000c20 <chSysHalt>
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 8002760:	60ac      	str	r4, [r5, #8]
    mp->next = ctp->mtxlist;
 8002762:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002764:	60eb      	str	r3, [r5, #12]
    ctp->mtxlist = mp;
 8002766:	63a5      	str	r5, [r4, #56]	; 0x38
 8002768:	bd70      	pop	{r4, r5, r6, pc}
 800276a:	bf00      	nop
 800276c:	20000a50 	.word	0x20000a50
 8002770:	08003160 	.word	0x08003160
	...

08002780 <main>:
  }
}

int main(void) 
{
 8002780:	b508      	push	{r3, lr}
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8002782:	f7fe fe2d 	bl	80013e0 <halInit>
  chSysInit();
 8002786:	f7fe fc43 	bl	8001010 <chSysInit>

  // Initialize and start app
  app_init();
 800278a:	f7ff fed1 	bl	8002530 <app_init>
  app_main();
 800278e:	f7ff fe8f 	bl	80024b0 <app_main>
 8002792:	bf00      	nop
	...

080027a0 <_port_irq_epilogue>:
 80027a0:	2320      	movs	r3, #32
 80027a2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80027a6:	4b12      	ldr	r3, [pc, #72]	; (80027f0 <_port_irq_epilogue+0x50>)
 80027a8:	685b      	ldr	r3, [r3, #4]
 80027aa:	f413 6f00 	tst.w	r3, #2048	; 0x800
 80027ae:	d103      	bne.n	80027b8 <_port_irq_epilogue+0x18>
 80027b0:	2300      	movs	r3, #0
 80027b2:	f383 8811 	msr	BASEPRI, r3
 80027b6:	4770      	bx	lr
void _port_irq_epilogue(void) {
 80027b8:	b510      	push	{r4, lr}
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  return __builtin_arm_get_fpscr();
#else
  uint32_t result;

  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 80027ba:	eef1 3a10 	vmrs	r3, fpscr
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 80027be:	f3ef 8409 	mrs	r4, PSP
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80027c2:	f1a4 0368 	sub.w	r3, r4, #104	; 0x68

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80027c6:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80027ca:	f844 2c4c 	str.w	r2, [r4, #-76]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 80027ce:	4a09      	ldr	r2, [pc, #36]	; (80027f4 <_port_irq_epilogue+0x54>)
 80027d0:	68d2      	ldr	r2, [r2, #12]
 80027d2:	f844 2c08 	str.w	r2, [r4, #-8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 80027d6:	f383 8809 	msr	PSP, r3
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80027da:	f7ff f949 	bl	8001a70 <chSchIsPreemptionRequired>
 80027de:	b118      	cbz	r0, 80027e8 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80027e0:	4b05      	ldr	r3, [pc, #20]	; (80027f8 <_port_irq_epilogue+0x58>)
 80027e2:	f844 3c50 	str.w	r3, [r4, #-80]
 80027e6:	bd10      	pop	{r4, pc}
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80027e8:	4b04      	ldr	r3, [pc, #16]	; (80027fc <_port_irq_epilogue+0x5c>)
 80027ea:	f844 3c50 	str.w	r3, [r4, #-80]
 80027ee:	bd10      	pop	{r4, pc}
 80027f0:	e000ed00 	.word	0xe000ed00
 80027f4:	e000ef30 	.word	0xe000ef30
 80027f8:	08000337 	.word	0x08000337
 80027fc:	08000342 	.word	0x08000342

08002800 <SVC_Handler>:
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8002800:	4a06      	ldr	r2, [pc, #24]	; (800281c <SVC_Handler+0x1c>)
 8002802:	6853      	ldr	r3, [r2, #4]
 8002804:	f023 0301 	bic.w	r3, r3, #1
 8002808:	6053      	str	r3, [r2, #4]
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 800280a:	f3ef 8309 	mrs	r3, PSP
  ctxp++;
 800280e:	3368      	adds	r3, #104	; 0x68
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8002810:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002814:	2300      	movs	r3, #0
 8002816:	f383 8811 	msr	BASEPRI, r3
 800281a:	4770      	bx	lr
 800281c:	e000ef30 	.word	0xe000ef30

08002820 <_factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void _factory_init(void) {
 8002820:	b538      	push	{r3, r4, r5, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8002822:	4c12      	ldr	r4, [pc, #72]	; (800286c <_factory_init+0x4c>)
 8002824:	4620      	mov	r0, r4
 8002826:	f7ff feab 	bl	8002580 <chMtxObjectInit>
  dlp->next = (dyn_element_t *)dlp;
 800282a:	f104 0310 	add.w	r3, r4, #16
 800282e:	6123      	str	r3, [r4, #16]
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 8002830:	4d0f      	ldr	r5, [pc, #60]	; (8002870 <_factory_init+0x50>)
 8002832:	462b      	mov	r3, r5
 8002834:	2204      	movs	r2, #4
 8002836:	2114      	movs	r1, #20
 8002838:	1860      	adds	r0, r4, r1
 800283a:	f7ff fe89 	bl	8002550 <chPoolObjectInitAligned>
 800283e:	f104 0324 	add.w	r3, r4, #36	; 0x24
 8002842:	6263      	str	r3, [r4, #36]	; 0x24
 8002844:	f104 0328 	add.w	r3, r4, #40	; 0x28
 8002848:	62a3      	str	r3, [r4, #40]	; 0x28
 800284a:	462b      	mov	r3, r5
 800284c:	2204      	movs	r2, #4
 800284e:	211c      	movs	r1, #28
 8002850:	f104 002c 	add.w	r0, r4, #44	; 0x2c
 8002854:	f7ff fe7c 	bl	8002550 <chPoolObjectInitAligned>
 8002858:	f104 033c 	add.w	r3, r4, #60	; 0x3c
 800285c:	63e3      	str	r3, [r4, #60]	; 0x3c
 800285e:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8002862:	6423      	str	r3, [r4, #64]	; 0x40
 8002864:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8002868:	6463      	str	r3, [r4, #68]	; 0x44
 800286a:	bd38      	pop	{r3, r4, r5, pc}
 800286c:	200012d8 	.word	0x200012d8
 8002870:	08002621 	.word	0x08002621
	...

08002880 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 8002880:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8002882:	4805      	ldr	r0, [pc, #20]	; (8002898 <_heap_init+0x18>)
 8002884:	4b05      	ldr	r3, [pc, #20]	; (800289c <_heap_init+0x1c>)
 8002886:	6003      	str	r3, [r0, #0]
  H_NEXT(&default_heap.header) = NULL;
 8002888:	2300      	movs	r3, #0
 800288a:	6043      	str	r3, [r0, #4]
  H_PAGES(&default_heap.header) = 0;
 800288c:	6083      	str	r3, [r0, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 800288e:	300c      	adds	r0, #12
 8002890:	f7ff fe76 	bl	8002580 <chMtxObjectInit>
 8002894:	bd08      	pop	{r3, pc}
 8002896:	bf00      	nop
 8002898:	20001328 	.word	0x20001328
 800289c:	080029f1 	.word	0x080029f1

080028a0 <_core_init>:
  ch_memcore.basemem = __heap_base__;
 80028a0:	4b02      	ldr	r3, [pc, #8]	; (80028ac <_core_init+0xc>)
 80028a2:	4a03      	ldr	r2, [pc, #12]	; (80028b0 <_core_init+0x10>)
 80028a4:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
 80028a6:	4a03      	ldr	r2, [pc, #12]	; (80028b4 <_core_init+0x14>)
 80028a8:	605a      	str	r2, [r3, #4]
 80028aa:	4770      	bx	lr
 80028ac:	20001320 	.word	0x20001320
 80028b0:	20001348 	.word	0x20001348
 80028b4:	20020000 	.word	0x20020000
	...

080028c0 <chEvtBroadcastFlagsI>:
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80028c0:	b570      	push	{r4, r5, r6, lr}
 80028c2:	4606      	mov	r6, r0
 80028c4:	460d      	mov	r5, r1
  chDbgCheckClassI();
 80028c6:	f7ff f9bb 	bl	8001c40 <chDbgCheckClassI>
  chDbgCheck(esp != NULL);
 80028ca:	b10e      	cbz	r6, 80028d0 <chEvtBroadcastFlagsI+0x10>
  elp = esp->next;
 80028cc:	6834      	ldr	r4, [r6, #0]
 80028ce:	e007      	b.n	80028e0 <chEvtBroadcastFlagsI+0x20>
  chDbgCheck(esp != NULL);
 80028d0:	4809      	ldr	r0, [pc, #36]	; (80028f8 <chEvtBroadcastFlagsI+0x38>)
 80028d2:	f7fe f9a5 	bl	8000c20 <chSysHalt>
      chEvtSignalI(elp->listener, elp->events);
 80028d6:	68a1      	ldr	r1, [r4, #8]
 80028d8:	6860      	ldr	r0, [r4, #4]
 80028da:	f7ff fea9 	bl	8002630 <chEvtSignalI>
    elp = elp->next;
 80028de:	6824      	ldr	r4, [r4, #0]
  while (elp != (event_listener_t *)esp) {
 80028e0:	42b4      	cmp	r4, r6
 80028e2:	d008      	beq.n	80028f6 <chEvtBroadcastFlagsI+0x36>
    elp->flags |= flags;
 80028e4:	68e3      	ldr	r3, [r4, #12]
 80028e6:	432b      	orrs	r3, r5
 80028e8:	60e3      	str	r3, [r4, #12]
    if ((flags == (eventflags_t)0) ||
 80028ea:	2d00      	cmp	r5, #0
 80028ec:	d0f3      	beq.n	80028d6 <chEvtBroadcastFlagsI+0x16>
        ((flags & elp->wflags) != (eventflags_t)0)) {
 80028ee:	6923      	ldr	r3, [r4, #16]
    if ((flags == (eventflags_t)0) ||
 80028f0:	421d      	tst	r5, r3
 80028f2:	d0f4      	beq.n	80028de <chEvtBroadcastFlagsI+0x1e>
 80028f4:	e7ef      	b.n	80028d6 <chEvtBroadcastFlagsI+0x16>
}
 80028f6:	bd70      	pop	{r4, r5, r6, pc}
 80028f8:	0800318c 	.word	0x0800318c
 80028fc:	00000000 	.word	0x00000000

08002900 <_tm_init>:
void _tm_init(void) {
 8002900:	b510      	push	{r4, lr}
 8002902:	b086      	sub	sp, #24
  ch.tm.offset = (rtcnt_t)0;
 8002904:	4c08      	ldr	r4, [pc, #32]	; (8002928 <_tm_init+0x28>)
 8002906:	2300      	movs	r3, #0
 8002908:	f8c4 3884 	str.w	r3, [r4, #2180]	; 0x884
  chTMObjectInit(&tm);
 800290c:	4668      	mov	r0, sp
 800290e:	f7ff fdbf 	bl	8002490 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 8002912:	4668      	mov	r0, sp
 8002914:	f7ff fdb4 	bl	8002480 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 8002918:	4668      	mov	r0, sp
 800291a:	f7ff fd89 	bl	8002430 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 800291e:	9b02      	ldr	r3, [sp, #8]
 8002920:	f8c4 3884 	str.w	r3, [r4, #2180]	; 0x884
}
 8002924:	b006      	add	sp, #24
 8002926:	bd10      	pop	{r4, pc}
 8002928:	20000a50 	.word	0x20000a50
 800292c:	00000000 	.word	0x00000000

08002930 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8002930:	b508      	push	{r3, lr}
  return (bool)(tqp->next != (const thread_t *)tqp);
 8002932:	6803      	ldr	r3, [r0, #0]

  if (queue_notempty(tqp)) {
 8002934:	4298      	cmp	r0, r3
 8002936:	d012      	beq.n	800295e <chThdDequeueNextI+0x2e>
 8002938:	4603      	mov	r3, r0
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");
 800293a:	d00a      	beq.n	8002952 <chThdDequeueNextI+0x22>
  thread_t *tp = tqp->next;
 800293c:	6800      	ldr	r0, [r0, #0]
  tqp->next             = tp->queue.next;
 800293e:	6802      	ldr	r2, [r0, #0]
 8002940:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002942:	6053      	str	r3, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");
 8002944:	f890 3020 	ldrb.w	r3, [r0, #32]
 8002948:	2b04      	cmp	r3, #4
 800294a:	d005      	beq.n	8002958 <chThdDequeueNextI+0x28>
 800294c:	4804      	ldr	r0, [pc, #16]	; (8002960 <chThdDequeueNextI+0x30>)
 800294e:	f7fe f967 	bl	8000c20 <chSysHalt>
  chDbgAssert(queue_notempty(tqp), "empty queue");
 8002952:	4803      	ldr	r0, [pc, #12]	; (8002960 <chThdDequeueNextI+0x30>)
 8002954:	f7fe f964 	bl	8000c20 <chSysHalt>

  tp->u.rdymsg = msg;
 8002958:	6241      	str	r1, [r0, #36]	; 0x24
  (void) chSchReadyI(tp);
 800295a:	f7ff fa59 	bl	8001e10 <chSchReadyI>
 800295e:	bd08      	pop	{r3, pc}
 8002960:	08003118 	.word	0x08003118
	...

08002970 <chThdEnqueueTimeoutS>:
  if (TIME_IMMEDIATE == timeout) {
 8002970:	b159      	cbz	r1, 800298a <chThdEnqueueTimeoutS+0x1a>
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, sysinterval_t timeout) {
 8002972:	b508      	push	{r3, lr}
  queue_insert(currp, tqp);
 8002974:	4b06      	ldr	r3, [pc, #24]	; (8002990 <chThdEnqueueTimeoutS+0x20>)
 8002976:	699b      	ldr	r3, [r3, #24]
  tp->queue.next             = (thread_t *)tqp;
 8002978:	6018      	str	r0, [r3, #0]
  tp->queue.prev             = tqp->prev;
 800297a:	6842      	ldr	r2, [r0, #4]
 800297c:	605a      	str	r2, [r3, #4]
  tp->queue.prev->queue.next = tp;
 800297e:	6013      	str	r3, [r2, #0]
  tqp->prev                  = tp;
 8002980:	6043      	str	r3, [r0, #4]
  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8002982:	2004      	movs	r0, #4
 8002984:	f7ff fb7c 	bl	8002080 <chSchGoSleepTimeoutS>
 8002988:	bd08      	pop	{r3, pc}
    return MSG_TIMEOUT;
 800298a:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800298e:	4770      	bx	lr
 8002990:	20000a50 	.word	0x20000a50
	...

080029a0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 80029a0:	b538      	push	{r3, r4, r5, lr}
 80029a2:	4604      	mov	r4, r0
 80029a4:	460d      	mov	r5, r1
 80029a6:	2320      	movs	r3, #32
 80029a8:	f383 8811 	msr	BASEPRI, r3
 80029ac:	f7ff fc68 	bl	8002280 <_dbg_check_lock>

  chSysLock();
  chPoolFreeI(mp, objp);
 80029b0:	4629      	mov	r1, r5
 80029b2:	4620      	mov	r0, r4
 80029b4:	f7ff fdf4 	bl	80025a0 <chPoolFreeI>
  _dbg_check_unlock();
 80029b8:	f7ff fc32 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 80029bc:	4b07      	ldr	r3, [pc, #28]	; (80029dc <chPoolFree+0x3c>)
 80029be:	681a      	ldr	r2, [r3, #0]
 80029c0:	429a      	cmp	r2, r3
 80029c2:	d004      	beq.n	80029ce <chPoolFree+0x2e>
 80029c4:	699b      	ldr	r3, [r3, #24]
 80029c6:	6899      	ldr	r1, [r3, #8]
 80029c8:	6893      	ldr	r3, [r2, #8]
 80029ca:	4299      	cmp	r1, r3
 80029cc:	d303      	bcc.n	80029d6 <chPoolFree+0x36>
 80029ce:	2300      	movs	r3, #0
 80029d0:	f383 8811 	msr	BASEPRI, r3
 80029d4:	bd38      	pop	{r3, r4, r5, pc}
 80029d6:	4802      	ldr	r0, [pc, #8]	; (80029e0 <chPoolFree+0x40>)
 80029d8:	f7fe f922 	bl	8000c20 <chSysHalt>
 80029dc:	20000a50 	.word	0x20000a50
 80029e0:	0800310c 	.word	0x0800310c
	...

080029f0 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 80029f0:	b570      	push	{r4, r5, r6, lr}
 80029f2:	4604      	mov	r4, r0
 80029f4:	460d      	mov	r5, r1
 80029f6:	4616      	mov	r6, r2
 80029f8:	2320      	movs	r3, #32
 80029fa:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 80029fe:	f7ff fc3f 	bl	8002280 <_dbg_check_lock>
  void *p;

  chSysLock();
  p = chCoreAllocFromTopI(size, align, offset);
 8002a02:	4632      	mov	r2, r6
 8002a04:	4629      	mov	r1, r5
 8002a06:	4620      	mov	r0, r4
 8002a08:	f7ff fde2 	bl	80025d0 <chCoreAllocFromTopI>
 8002a0c:	4604      	mov	r4, r0
  _dbg_check_unlock();
 8002a0e:	f7ff fc07 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002a12:	4b08      	ldr	r3, [pc, #32]	; (8002a34 <chCoreAllocFromTop+0x44>)
 8002a14:	681a      	ldr	r2, [r3, #0]
 8002a16:	429a      	cmp	r2, r3
 8002a18:	d004      	beq.n	8002a24 <chCoreAllocFromTop+0x34>
 8002a1a:	699b      	ldr	r3, [r3, #24]
 8002a1c:	6899      	ldr	r1, [r3, #8]
 8002a1e:	6893      	ldr	r3, [r2, #8]
 8002a20:	4299      	cmp	r1, r3
 8002a22:	d304      	bcc.n	8002a2e <chCoreAllocFromTop+0x3e>
 8002a24:	2300      	movs	r3, #0
 8002a26:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return p;
}
 8002a2a:	4620      	mov	r0, r4
 8002a2c:	bd70      	pop	{r4, r5, r6, pc}
 8002a2e:	4802      	ldr	r0, [pc, #8]	; (8002a38 <chCoreAllocFromTop+0x48>)
 8002a30:	f7fe f8f6 	bl	8000c20 <chSysHalt>
 8002a34:	20000a50 	.word	0x20000a50
 8002a38:	08003100 	.word	0x08003100
 8002a3c:	00000000 	.word	0x00000000

08002a40 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8002a40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  thread_t *ctp = currp;
 8002a42:	4b2b      	ldr	r3, [pc, #172]	; (8002af0 <chMtxUnlock+0xb0>)
 8002a44:	699c      	ldr	r4, [r3, #24]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);
 8002a46:	b170      	cbz	r0, 8002a66 <chMtxUnlock+0x26>
 8002a48:	4606      	mov	r6, r0
 8002a4a:	2320      	movs	r3, #32
 8002a4c:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002a50:	f7ff fc16 	bl	8002280 <_dbg_check_lock>

  chSysLock();

  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8002a54:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002a56:	b14b      	cbz	r3, 8002a6c <chMtxUnlock+0x2c>
  chDbgAssert(ctp->mtxlist->owner == ctp, "ownership failure");
 8002a58:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002a5a:	689b      	ldr	r3, [r3, #8]
 8002a5c:	429c      	cmp	r4, r3
 8002a5e:	d008      	beq.n	8002a72 <chMtxUnlock+0x32>
 8002a60:	4824      	ldr	r0, [pc, #144]	; (8002af4 <chMtxUnlock+0xb4>)
 8002a62:	f7fe f8dd 	bl	8000c20 <chSysHalt>
  chDbgCheck(mp != NULL);
 8002a66:	4823      	ldr	r0, [pc, #140]	; (8002af4 <chMtxUnlock+0xb4>)
 8002a68:	f7fe f8da 	bl	8000c20 <chSysHalt>
  chDbgAssert(ctp->mtxlist != NULL, "owned mutexes list empty");
 8002a6c:	4821      	ldr	r0, [pc, #132]	; (8002af4 <chMtxUnlock+0xb4>)
 8002a6e:	f7fe f8d7 	bl	8000c20 <chSysHalt>
  chDbgAssert(mp->cnt >= (cnt_t)1, "counter is not positive");

  if (--mp->cnt == (cnt_t)0) {
#endif

    chDbgAssert(ctp->mtxlist == mp, "not next in list");
 8002a72:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8002a74:	429e      	cmp	r6, r3
 8002a76:	d002      	beq.n	8002a7e <chMtxUnlock+0x3e>
 8002a78:	481e      	ldr	r0, [pc, #120]	; (8002af4 <chMtxUnlock+0xb4>)
 8002a7a:	f7fe f8d1 	bl	8000c20 <chSysHalt>

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 8002a7e:	68f3      	ldr	r3, [r6, #12]
 8002a80:	63a3      	str	r3, [r4, #56]	; 0x38
 *
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {

  chDbgCheckClassS();
 8002a82:	f7ff f8a5 	bl	8001bd0 <chDbgCheckClassS>
  return (bool)(tqp->next != (const thread_t *)tqp);
 8002a86:	6833      	ldr	r3, [r6, #0]

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002a88:	429e      	cmp	r6, r3
 8002a8a:	d02a      	beq.n	8002ae2 <chMtxUnlock+0xa2>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8002a8c:	6be7      	ldr	r7, [r4, #60]	; 0x3c
      lmp = ctp->mtxlist;
 8002a8e:	6ba5      	ldr	r5, [r4, #56]	; 0x38
 8002a90:	e000      	b.n	8002a94 <chMtxUnlock+0x54>
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
            (lmp->queue.next->prio > newprio)) {
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8002a92:	68ed      	ldr	r5, [r5, #12]
      while (lmp != NULL) {
 8002a94:	b14d      	cbz	r5, 8002aaa <chMtxUnlock+0x6a>
 8002a96:	f7ff f89b 	bl	8001bd0 <chDbgCheckClassS>
 8002a9a:	682b      	ldr	r3, [r5, #0]
        if (chMtxQueueNotEmptyS(lmp) &&
 8002a9c:	429d      	cmp	r5, r3
 8002a9e:	d0f8      	beq.n	8002a92 <chMtxUnlock+0x52>
            (lmp->queue.next->prio > newprio)) {
 8002aa0:	689b      	ldr	r3, [r3, #8]
        if (chMtxQueueNotEmptyS(lmp) &&
 8002aa2:	429f      	cmp	r7, r3
 8002aa4:	d2f5      	bcs.n	8002a92 <chMtxUnlock+0x52>
          newprio = lmp->queue.next->prio;
 8002aa6:	461f      	mov	r7, r3
 8002aa8:	e7f3      	b.n	8002a92 <chMtxUnlock+0x52>
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8002aaa:	60a7      	str	r7, [r4, #8]
  thread_t *tp = tqp->next;
 8002aac:	6830      	ldr	r0, [r6, #0]
  tqp->next             = tp->queue.next;
 8002aae:	6803      	ldr	r3, [r0, #0]
 8002ab0:	6033      	str	r3, [r6, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8002ab2:	605e      	str	r6, [r3, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 8002ab4:	60b0      	str	r0, [r6, #8]
      mp->next = tp->mtxlist;
 8002ab6:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8002ab8:	60f3      	str	r3, [r6, #12]
      tp->mtxlist = mp;
 8002aba:	6386      	str	r6, [r0, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8002abc:	f7ff f9a8 	bl	8001e10 <chSchReadyI>
      chSchRescheduleS();
 8002ac0:	f7ff f98e 	bl	8001de0 <chSchRescheduleS>
  _dbg_check_unlock();
 8002ac4:	f7ff fbac 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002ac8:	4b09      	ldr	r3, [pc, #36]	; (8002af0 <chMtxUnlock+0xb0>)
 8002aca:	681a      	ldr	r2, [r3, #0]
 8002acc:	429a      	cmp	r2, r3
 8002ace:	d004      	beq.n	8002ada <chMtxUnlock+0x9a>
 8002ad0:	699b      	ldr	r3, [r3, #24]
 8002ad2:	6899      	ldr	r1, [r3, #8]
 8002ad4:	6893      	ldr	r3, [r2, #8]
 8002ad6:	4299      	cmp	r1, r3
 8002ad8:	d306      	bcc.n	8002ae8 <chMtxUnlock+0xa8>
 8002ada:	2300      	movs	r3, #0
 8002adc:	f383 8811 	msr	BASEPRI, r3
 8002ae0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    }
    else {
      mp->owner = NULL;
 8002ae2:	2300      	movs	r3, #0
 8002ae4:	60b3      	str	r3, [r6, #8]
 8002ae6:	e7ed      	b.n	8002ac4 <chMtxUnlock+0x84>
 8002ae8:	4803      	ldr	r0, [pc, #12]	; (8002af8 <chMtxUnlock+0xb8>)
 8002aea:	f7fe f899 	bl	8000c20 <chSysHalt>
 8002aee:	bf00      	nop
 8002af0:	20000a50 	.word	0x20000a50
 8002af4:	080031b0 	.word	0x080031b0
 8002af8:	080030f4 	.word	0x080030f4
 8002afc:	00000000 	.word	0x00000000

08002b00 <chMtxLock>:
void chMtxLock(mutex_t *mp) {
 8002b00:	b510      	push	{r4, lr}
 8002b02:	4604      	mov	r4, r0
 8002b04:	2320      	movs	r3, #32
 8002b06:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002b0a:	f7ff fbb9 	bl	8002280 <_dbg_check_lock>
  chMtxLockS(mp);
 8002b0e:	4620      	mov	r0, r4
 8002b10:	f7ff fdb6 	bl	8002680 <chMtxLockS>
  _dbg_check_unlock();
 8002b14:	f7ff fb84 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002b18:	4b07      	ldr	r3, [pc, #28]	; (8002b38 <chMtxLock+0x38>)
 8002b1a:	681a      	ldr	r2, [r3, #0]
 8002b1c:	429a      	cmp	r2, r3
 8002b1e:	d004      	beq.n	8002b2a <chMtxLock+0x2a>
 8002b20:	699b      	ldr	r3, [r3, #24]
 8002b22:	6899      	ldr	r1, [r3, #8]
 8002b24:	6893      	ldr	r3, [r2, #8]
 8002b26:	4299      	cmp	r1, r3
 8002b28:	d303      	bcc.n	8002b32 <chMtxLock+0x32>
 8002b2a:	2300      	movs	r3, #0
 8002b2c:	f383 8811 	msr	BASEPRI, r3
 8002b30:	bd10      	pop	{r4, pc}
 8002b32:	4802      	ldr	r0, [pc, #8]	; (8002b3c <chMtxLock+0x3c>)
 8002b34:	f7fe f874 	bl	8000c20 <chSysHalt>
 8002b38:	20000a50 	.word	0x20000a50
 8002b3c:	080030f4 	.word	0x080030f4

08002b40 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8002b40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  heap_header_t *qp, *hp;
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));
 8002b42:	b118      	cbz	r0, 8002b4c <chHeapFree+0xc>
 8002b44:	4606      	mov	r6, r0
 8002b46:	f010 0f07 	tst.w	r0, #7
 8002b4a:	d002      	beq.n	8002b52 <chHeapFree+0x12>
 8002b4c:	4827      	ldr	r0, [pc, #156]	; (8002bec <chHeapFree+0xac>)
 8002b4e:	f7fe f867 	bl	8000c20 <chSysHalt>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8002b52:	f1a0 0408 	sub.w	r4, r0, #8
  /*lint -restore*/
  heapp = H_HEAP(hp);
 8002b56:	f850 7c08 	ldr.w	r7, [r0, #-8]
  qp = &heapp->header;
 8002b5a:	1d3d      	adds	r5, r7, #4

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8002b5c:	f850 3c04 	ldr.w	r3, [r0, #-4]
 8002b60:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8002b62:	08db      	lsrs	r3, r3, #3
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8002b64:	f840 3c04 	str.w	r3, [r0, #-4]

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8002b68:	370c      	adds	r7, #12
 8002b6a:	4638      	mov	r0, r7
 8002b6c:	f7ff ffc8 	bl	8002b00 <chMtxLock>
  qp = &heapp->header;
 8002b70:	462b      	mov	r3, r5
 8002b72:	e008      	b.n	8002b86 <chHeapFree+0x46>

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 8002b74:	42ab      	cmp	r3, r5
 8002b76:	d001      	beq.n	8002b7c <chHeapFree+0x3c>
 8002b78:	42a3      	cmp	r3, r4
 8002b7a:	d203      	bcs.n	8002b84 <chHeapFree+0x44>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8002b7c:	681a      	ldr	r2, [r3, #0]
    if (((qp == &heapp->header) || (hp > qp)) &&
 8002b7e:	b16a      	cbz	r2, 8002b9c <chHeapFree+0x5c>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8002b80:	4294      	cmp	r4, r2
 8002b82:	d30b      	bcc.n	8002b9c <chHeapFree+0x5c>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
      }
      break;
    }
    qp = H_NEXT(qp);
 8002b84:	681b      	ldr	r3, [r3, #0]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");
 8002b86:	42a3      	cmp	r3, r4
 8002b88:	d8f4      	bhi.n	8002b74 <chHeapFree+0x34>
 8002b8a:	685a      	ldr	r2, [r3, #4]
 8002b8c:	3201      	adds	r2, #1
 8002b8e:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8002b92:	4294      	cmp	r4, r2
 8002b94:	d2ee      	bcs.n	8002b74 <chHeapFree+0x34>
 8002b96:	4815      	ldr	r0, [pc, #84]	; (8002bec <chHeapFree+0xac>)
 8002b98:	f7fe f842 	bl	8000c20 <chSysHalt>
      H_NEXT(hp) = H_NEXT(qp);
 8002b9c:	f846 2c08 	str.w	r2, [r6, #-8]
      H_NEXT(qp) = hp;
 8002ba0:	601c      	str	r4, [r3, #0]
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8002ba2:	f856 1c04 	ldr.w	r1, [r6, #-4]
 8002ba6:	1c4a      	adds	r2, r1, #1
 8002ba8:	eb04 02c2 	add.w	r2, r4, r2, lsl #3
 8002bac:	f856 0c08 	ldr.w	r0, [r6, #-8]
 8002bb0:	4282      	cmp	r2, r0
 8002bb2:	d009      	beq.n	8002bc8 <chHeapFree+0x88>
      if ((H_LIMIT(qp) == hp)) {
 8002bb4:	6859      	ldr	r1, [r3, #4]
 8002bb6:	1c4a      	adds	r2, r1, #1
 8002bb8:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8002bbc:	4294      	cmp	r4, r2
 8002bbe:	d00c      	beq.n	8002bda <chHeapFree+0x9a>
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8002bc0:	4638      	mov	r0, r7
 8002bc2:	f7ff ff3d 	bl	8002a40 <chMtxUnlock>
 8002bc6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8002bc8:	6842      	ldr	r2, [r0, #4]
 8002bca:	440a      	add	r2, r1
 8002bcc:	3201      	adds	r2, #1
 8002bce:	f846 2c04 	str.w	r2, [r6, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8002bd2:	6802      	ldr	r2, [r0, #0]
 8002bd4:	f846 2c08 	str.w	r2, [r6, #-8]
 8002bd8:	e7ec      	b.n	8002bb4 <chHeapFree+0x74>
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8002bda:	f856 2c04 	ldr.w	r2, [r6, #-4]
 8002bde:	440a      	add	r2, r1
 8002be0:	3201      	adds	r2, #1
 8002be2:	605a      	str	r2, [r3, #4]
        H_NEXT(qp) = H_NEXT(hp);
 8002be4:	f856 2c08 	ldr.w	r2, [r6, #-8]
 8002be8:	601a      	str	r2, [r3, #0]
 8002bea:	e7e9      	b.n	8002bc0 <chHeapFree+0x80>
 8002bec:	080031a4 	.word	0x080031a4

08002bf0 <chSysUnlock.lto_priv.0>:
static inline void chSysUnlock(void) {
 8002bf0:	b508      	push	{r3, lr}
  _dbg_check_unlock();
 8002bf2:	f7ff fb15 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002bf6:	4b08      	ldr	r3, [pc, #32]	; (8002c18 <chSysUnlock.lto_priv.0+0x28>)
 8002bf8:	681a      	ldr	r2, [r3, #0]
 8002bfa:	429a      	cmp	r2, r3
 8002bfc:	d004      	beq.n	8002c08 <chSysUnlock.lto_priv.0+0x18>
 8002bfe:	699b      	ldr	r3, [r3, #24]
 8002c00:	6899      	ldr	r1, [r3, #8]
 8002c02:	6893      	ldr	r3, [r2, #8]
 8002c04:	4299      	cmp	r1, r3
 8002c06:	d303      	bcc.n	8002c10 <chSysUnlock.lto_priv.0+0x20>
 8002c08:	2300      	movs	r3, #0
 8002c0a:	f383 8811 	msr	BASEPRI, r3
 8002c0e:	bd08      	pop	{r3, pc}
 8002c10:	4802      	ldr	r0, [pc, #8]	; (8002c1c <chSysUnlock.lto_priv.0+0x2c>)
 8002c12:	f7fe f805 	bl	8000c20 <chSysHalt>
 8002c16:	bf00      	nop
 8002c18:	20000a50 	.word	0x20000a50
 8002c1c:	0800312c 	.word	0x0800312c

08002c20 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8002c20:	b510      	push	{r4, lr}
 8002c22:	2320      	movs	r3, #32
 8002c24:	f383 8811 	msr	BASEPRI, r3
  _dbg_check_lock();
 8002c28:	f7ff fb2a 	bl	8002280 <_dbg_check_lock>
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 8002c2c:	4b05      	ldr	r3, [pc, #20]	; (8002c44 <chRegFirstThread+0x24>)
 8002c2e:	691c      	ldr	r4, [r3, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8002c30:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8002c34:	3301      	adds	r3, #1
 8002c36:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
#endif
  chSysUnlock();
 8002c3a:	f7ff ffd9 	bl	8002bf0 <chSysUnlock.lto_priv.0>

  return tp;
}
 8002c3e:	4620      	mov	r0, r4
 8002c40:	bd10      	pop	{r4, pc}
 8002c42:	bf00      	nop
 8002c44:	20000a50 	.word	0x20000a50
	...

08002c50 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8002c50:	b538      	push	{r3, r4, r5, lr}
 8002c52:	4605      	mov	r5, r0
 8002c54:	2320      	movs	r3, #32
 8002c56:	f383 8811 	msr	BASEPRI, r3
 8002c5a:	f7ff fb11 	bl	8002280 <_dbg_check_lock>
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
 8002c5e:	692c      	ldr	r4, [r5, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8002c60:	4b13      	ldr	r3, [pc, #76]	; (8002cb0 <chRegNextThread+0x60>)
 8002c62:	429c      	cmp	r4, r3
 8002c64:	d01e      	beq.n	8002ca4 <chRegNextThread+0x54>
  /*lint -restore*/
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8002c66:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8002c6a:	2bff      	cmp	r3, #255	; 0xff
 8002c6c:	d017      	beq.n	8002c9e <chRegNextThread+0x4e>
    ntp->refs++;
 8002c6e:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8002c72:	3301      	adds	r3, #1
 8002c74:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
  _dbg_check_unlock();
 8002c78:	f7ff fad2 	bl	8002220 <_dbg_check_unlock>
  chDbgAssert((ch.rlist.queue.next == (thread_t *)&ch.rlist.queue) ||
 8002c7c:	4b0c      	ldr	r3, [pc, #48]	; (8002cb0 <chRegNextThread+0x60>)
 8002c7e:	681a      	ldr	r2, [r3, #0]
 8002c80:	429a      	cmp	r2, r3
 8002c82:	d004      	beq.n	8002c8e <chRegNextThread+0x3e>
 8002c84:	699b      	ldr	r3, [r3, #24]
 8002c86:	6899      	ldr	r1, [r3, #8]
 8002c88:	6893      	ldr	r3, [r2, #8]
 8002c8a:	4299      	cmp	r1, r3
 8002c8c:	d30c      	bcc.n	8002ca8 <chRegNextThread+0x58>
 8002c8e:	2300      	movs	r3, #0
 8002c90:	f383 8811 	msr	BASEPRI, r3
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8002c94:	4628      	mov	r0, r5
 8002c96:	f7ff fb43 	bl	8002320 <chThdRelease>
#endif

  return ntp;
}
 8002c9a:	4620      	mov	r0, r4
 8002c9c:	bd38      	pop	{r3, r4, r5, pc}
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
 8002c9e:	4805      	ldr	r0, [pc, #20]	; (8002cb4 <chRegNextThread+0x64>)
 8002ca0:	f7fd ffbe 	bl	8000c20 <chSysHalt>
    ntp = NULL;
 8002ca4:	2400      	movs	r4, #0
 8002ca6:	e7e7      	b.n	8002c78 <chRegNextThread+0x28>
 8002ca8:	4803      	ldr	r0, [pc, #12]	; (8002cb8 <chRegNextThread+0x68>)
 8002caa:	f7fd ffb9 	bl	8000c20 <chSysHalt>
 8002cae:	bf00      	nop
 8002cb0:	20000a50 	.word	0x20000a50
 8002cb4:	080031cc 	.word	0x080031cc
 8002cb8:	0800312c 	.word	0x0800312c
 8002cbc:	00000000 	.word	0x00000000

08002cc0 <chRegFindThreadByWorkingArea>:
 * @return              A pointer to the found thread.
 * @retval NULL         if a matching thread has not been found.
 *
 * @api
 */
thread_t *chRegFindThreadByWorkingArea(stkalign_t *wa) {
 8002cc0:	b510      	push	{r4, lr}
 8002cc2:	4604      	mov	r4, r0
  thread_t *ctp;

  /* Scanning registry.*/
  ctp = chRegFirstThread();
 8002cc4:	f7ff ffac 	bl	8002c20 <chRegFirstThread>
 8002cc8:	4603      	mov	r3, r0
  return tp->wabase;
 8002cca:	69da      	ldr	r2, [r3, #28]
  do {
    if (chThdGetWorkingAreaX(ctp) == wa) {
 8002ccc:	42a2      	cmp	r2, r4
 8002cce:	d005      	beq.n	8002cdc <chRegFindThreadByWorkingArea+0x1c>
      return ctp;
    }
    ctp = chRegNextThread(ctp);
 8002cd0:	4618      	mov	r0, r3
 8002cd2:	f7ff ffbd 	bl	8002c50 <chRegNextThread>
  } while (ctp != NULL);
 8002cd6:	4603      	mov	r3, r0
 8002cd8:	2800      	cmp	r0, #0
 8002cda:	d1f6      	bne.n	8002cca <chRegFindThreadByWorkingArea+0xa>

  return NULL;
}
 8002cdc:	4618      	mov	r0, r3
 8002cde:	bd10      	pop	{r4, pc}
